
lab2_main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000009a  00800200  00002dc6  00002e5a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002dc6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000017bc  0080029a  0080029a  00002ef4  2**0
                  ALLOC
  3 .stab         00000c6c  00000000  00000000  00002ef4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000002ae  00000000  00000000  00003b60  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000348  00000000  00000000  00003e10  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005a6c  00000000  00000000  00004158  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000219c  00000000  00000000  00009bc4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001c10  00000000  00000000  0000bd60  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000e40  00000000  00000000  0000d970  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001ebe  00000000  00000000  0000e7b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000410a  00000000  00000000  0001066e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001e8  00000000  00000000  00014778  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__ctors_end>
       4:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
       8:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
       c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      10:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      14:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      18:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      1c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      20:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      24:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      28:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      2c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      30:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      34:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      38:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      3c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      40:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      44:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      48:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      4c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      50:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      54:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      58:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      5c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      60:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      64:	0c 94 07 08 	jmp	0x100e	; 0x100e <__vector_25>
      68:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      6c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      70:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      74:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      78:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      7c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      80:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      84:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      88:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      8c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      90:	0c 94 54 08 	jmp	0x10a8	; 0x10a8 <__vector_36>
      94:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      98:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      9c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      a0:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      a4:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      a8:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      ac:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      b0:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      b4:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      b8:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      bc:	0c 94 60 0a 	jmp	0x14c0	; 0x14c0 <__vector_47>
      c0:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      c4:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      c8:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>

000000cc <_ZZ4mainE3__c>:
      cc:	4d 45 34 30 35 20 4c 61 62 20 31 20 53 74 61 72     ME405 Lab 1 Star
      dc:	74 69 6e 67 20 50 72 6f 67 72 61 6d 00              ting Program.

000000e9 <_ZZN8frt_taskC1EPKchjP8emstreamE3__c>:
      e9:	54 61 73 6b 20 00                                   Task .

000000ef <_ZZN8frt_taskC1EPKchjP8emstreamE3__c_0>:
      ef:	20 63 72 65 61 74 65 64 00                           created.

000000f8 <_ZZN8frt_taskC1EPKchjP8emstreamE3__c_1>:
      f8:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000106 <_ZZN8frt_taskC1EPKchjP8emstreamE3__c_2>:
     106:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     116:	61 73 6b 20 00                                      ask .

0000011b <_ZZN8frt_task15emergency_resetEvE3__c>:
     11b:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

0000012a <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     12a:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000134 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     134:	09 00                                               ..

00000136 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     136:	09 00                                               ..

00000138 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     138:	2f 00                                               /.

0000013a <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     13a:	09 00                                               ..

0000013c <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     13c:	09 00                                               ..

0000013e <_ZZ15print_task_listP8emstreamE3__c>:
     13e:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000149 <_ZZ15print_task_listP8emstreamE3__c_0>:
     149:	09 53 74 61 63 6b 00                                .Stack.

00000150 <_ZZ15print_task_listP8emstreamE3__c_1>:
     150:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000161 <_ZZ15print_task_listP8emstreamE3__c_2>:
     161:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

0000016d <_ZZ15print_task_listP8emstreamE3__c_3>:
     16d:	09 52 75 6e 73 00                                   .Runs.

00000173 <_ZZ15print_task_listP8emstreamE3__c_4>:
     173:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

00000184 <_ZZ15print_task_listP8emstreamE3__c_5>:
     184:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

00000190 <_ZZ15print_task_listP8emstreamE3__c_6>:
     190:	09 2d 2d 2d 2d 00                                   .----.

00000196 <_ZZ15print_task_listP8emstreamE3__c_7>:
     196:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000001a1 <_ZZ15print_task_listP8emstreamE3__c_8>:
     1a1:	2f 00                                               /.

000001a3 <_ZZ15print_task_listP8emstreamE3__c_9>:
     1a3:	09 09 00                                            ...

000001a6 <__ctors_start>:
     1a6:	2c 16       	cp	r2, r28

000001a8 <__ctors_end>:
     1a8:	11 24       	eor	r1, r1
     1aa:	1f be       	out	0x3f, r1	; 63
     1ac:	cf ef       	ldi	r28, 0xFF	; 255
     1ae:	d1 e2       	ldi	r29, 0x21	; 33
     1b0:	de bf       	out	0x3e, r29	; 62
     1b2:	cd bf       	out	0x3d, r28	; 61

000001b4 <__do_copy_data>:
     1b4:	12 e0       	ldi	r17, 0x02	; 2
     1b6:	a0 e0       	ldi	r26, 0x00	; 0
     1b8:	b2 e0       	ldi	r27, 0x02	; 2
     1ba:	e6 ec       	ldi	r30, 0xC6	; 198
     1bc:	fd e2       	ldi	r31, 0x2D	; 45
     1be:	00 e0       	ldi	r16, 0x00	; 0
     1c0:	0b bf       	out	0x3b, r16	; 59
     1c2:	02 c0       	rjmp	.+4      	; 0x1c8 <__do_copy_data+0x14>
     1c4:	07 90       	elpm	r0, Z+
     1c6:	0d 92       	st	X+, r0
     1c8:	aa 39       	cpi	r26, 0x9A	; 154
     1ca:	b1 07       	cpc	r27, r17
     1cc:	d9 f7       	brne	.-10     	; 0x1c4 <__do_copy_data+0x10>
     1ce:	1b be       	out	0x3b, r1	; 59

000001d0 <__do_clear_bss>:
     1d0:	1a e1       	ldi	r17, 0x1A	; 26
     1d2:	aa e9       	ldi	r26, 0x9A	; 154
     1d4:	b2 e0       	ldi	r27, 0x02	; 2
     1d6:	01 c0       	rjmp	.+2      	; 0x1da <.do_clear_bss_start>

000001d8 <.do_clear_bss_loop>:
     1d8:	1d 92       	st	X+, r1

000001da <.do_clear_bss_start>:
     1da:	a6 35       	cpi	r26, 0x56	; 86
     1dc:	b1 07       	cpc	r27, r17
     1de:	e1 f7       	brne	.-8      	; 0x1d8 <.do_clear_bss_loop>

000001e0 <__do_global_ctors>:
     1e0:	11 e0       	ldi	r17, 0x01	; 1
     1e2:	c8 ea       	ldi	r28, 0xA8	; 168
     1e4:	d1 e0       	ldi	r29, 0x01	; 1
     1e6:	00 e0       	ldi	r16, 0x00	; 0
     1e8:	06 c0       	rjmp	.+12     	; 0x1f6 <__do_global_ctors+0x16>
     1ea:	22 97       	sbiw	r28, 0x02	; 2
     1ec:	01 09       	sbc	r16, r1
     1ee:	fe 01       	movw	r30, r28
     1f0:	0b bf       	out	0x3b, r16	; 59
     1f2:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <__tablejump_elpm__>
     1f6:	c6 3a       	cpi	r28, 0xA6	; 166
     1f8:	d1 07       	cpc	r29, r17
     1fa:	80 e0       	ldi	r24, 0x00	; 0
     1fc:	08 07       	cpc	r16, r24
     1fe:	a9 f7       	brne	.-22     	; 0x1ea <__do_global_ctors+0xa>
     200:	1b be       	out	0x3b, r1	; 59
     202:	0e 94 e2 15 	call	0x2bc4	; 0x2bc4 <main>
     206:	0c 94 e1 16 	jmp	0x2dc2	; 0x2dc2 <_exit>

0000020a <__bad_interrupt>:
     20a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000020e <_ZN16motor_controller3runEv>:
 *  loop, it reads the A/D converter and change the selected motors speed. Each loop
 *  also check the two additional buttons.
 */

void motor_controller::run(void)
{
     20e:	cf 93       	push	r28
     210:	df 93       	push	r29
     212:	00 d0       	rcall	.+0      	; 0x214 <_ZN16motor_controller3runEv+0x6>
     214:	00 d0       	rcall	.+0      	; 0x216 <_ZN16motor_controller3runEv+0x8>
     216:	00 d0       	rcall	.+0      	; 0x218 <_ZN16motor_controller3runEv+0xa>
     218:	cd b7       	in	r28, 0x3d	; 61
     21a:	de b7       	in	r29, 0x3e	; 62
     21c:	9e 83       	std	Y+6, r25	; 0x06
     21e:	8d 83       	std	Y+5, r24	; 0x05
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     220:	0e 94 43 10 	call	0x2086	; 0x2086 <xTaskGetTickCount>
     224:	dc 01       	movw	r26, r24
     226:	cb 01       	movw	r24, r22
     228:	89 83       	std	Y+1, r24	; 0x01
     22a:	9a 83       	std	Y+2, r25	; 0x02
     22c:	ab 83       	std	Y+3, r26	; 0x03
     22e:	bc 83       	std	Y+4, r27	; 0x04

	// (1 << COM1A1) | (1 << COM1B1) | (1 << COM1C1) | (1 << WGM10) Fast PWM 8-bit
   // (1 << WGM12) | (1 << CS11) | (1 << CS10) clk/64 (prescaler)
   // outputs 16E6/64/255 = 980Hz PWM
	motor_driver *p_my_motor_driver1 = new motor_driver(p_serial, &DDRC, 0x06, &DDRB, 0x20, &PORTC, 0x05, 0x06, &TCCR1A, 0xA9, &TCCR1B, 0x0B, &OCR1B);
     230:	88 e0       	ldi	r24, 0x08	; 8
     232:	90 e0       	ldi	r25, 0x00	; 0
     234:	0e 94 61 05 	call	0xac2	; 0xac2 <_Znwj>
     238:	3c 01       	movw	r6, r24
     23a:	8d b7       	in	r24, 0x3d	; 61
     23c:	9e b7       	in	r25, 0x3e	; 62
     23e:	08 97       	sbiw	r24, 0x08	; 8
     240:	0f b6       	in	r0, 0x3f	; 63
     242:	f8 94       	cli
     244:	9e bf       	out	0x3e, r25	; 62
     246:	0f be       	out	0x3f, r0	; 63
     248:	8d bf       	out	0x3d, r24	; 61
     24a:	ed b7       	in	r30, 0x3d	; 61
     24c:	fe b7       	in	r31, 0x3e	; 62
     24e:	31 96       	adiw	r30, 0x01	; 1
     250:	ad 81       	ldd	r26, Y+5	; 0x05
     252:	be 81       	ldd	r27, Y+6	; 0x06
     254:	16 96       	adiw	r26, 0x06	; 6
     256:	6d 91       	ld	r22, X+
     258:	7c 91       	ld	r23, X
     25a:	17 97       	sbiw	r26, 0x07	; 7
     25c:	80 e8       	ldi	r24, 0x80	; 128
     25e:	90 e0       	ldi	r25, 0x00	; 0
     260:	ad b7       	in	r26, 0x3d	; 61
     262:	be b7       	in	r27, 0x3e	; 62
     264:	12 96       	adiw	r26, 0x02	; 2
     266:	9c 93       	st	X, r25
     268:	8e 93       	st	-X, r24
     26a:	11 97       	sbiw	r26, 0x01	; 1
     26c:	89 ea       	ldi	r24, 0xA9	; 169
     26e:	82 83       	std	Z+2, r24	; 0x02
     270:	81 e8       	ldi	r24, 0x81	; 129
     272:	90 e0       	ldi	r25, 0x00	; 0
     274:	94 83       	std	Z+4, r25	; 0x04
     276:	83 83       	std	Z+3, r24	; 0x03
     278:	8b e0       	ldi	r24, 0x0B	; 11
     27a:	85 83       	std	Z+5, r24	; 0x05
     27c:	8a e8       	ldi	r24, 0x8A	; 138
     27e:	90 e0       	ldi	r25, 0x00	; 0
     280:	97 83       	std	Z+7, r25	; 0x07
     282:	86 83       	std	Z+6, r24	; 0x06
     284:	c3 01       	movw	r24, r6
     286:	47 e2       	ldi	r20, 0x27	; 39
     288:	50 e0       	ldi	r21, 0x00	; 0
     28a:	26 e0       	ldi	r18, 0x06	; 6
     28c:	04 e2       	ldi	r16, 0x24	; 36
     28e:	10 e0       	ldi	r17, 0x00	; 0
     290:	30 e2       	ldi	r19, 0x20	; 32
     292:	e3 2e       	mov	r14, r19
     294:	38 e2       	ldi	r19, 0x28	; 40
     296:	c3 2e       	mov	r12, r19
     298:	d1 2c       	mov	r13, r1
     29a:	35 e0       	ldi	r19, 0x05	; 5
     29c:	a3 2e       	mov	r10, r19
     29e:	36 e0       	ldi	r19, 0x06	; 6
     2a0:	83 2e       	mov	r8, r19
     2a2:	0e 94 28 02 	call	0x450	; 0x450 <_ZN12motor_driverC1EP8emstreamPVhhS3_hS3_hhS3_hS3_hPVj>
     2a6:	8d b7       	in	r24, 0x3d	; 61
     2a8:	9e b7       	in	r25, 0x3e	; 62
     2aa:	08 96       	adiw	r24, 0x08	; 8
     2ac:	0f b6       	in	r0, 0x3f	; 63
     2ae:	f8 94       	cli
     2b0:	9e bf       	out	0x3e, r25	; 62
     2b2:	0f be       	out	0x3f, r0	; 63
     2b4:	8d bf       	out	0x3d, r24	; 61

	// This is the task loop for the motor control task. This loop runs until the
	// power is turned off or something equally dramatic occurs.
	for (;;)
	{
      p_my_motor_driver1->sample();
     2b6:	c3 01       	movw	r24, r6
     2b8:	0e 94 6d 02 	call	0x4da	; 0x4da <_ZN12motor_driver6sampleEv>
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     2bc:	ce 01       	movw	r24, r28
     2be:	01 96       	adiw	r24, 0x01	; 1
     2c0:	44 e6       	ldi	r20, 0x64	; 100
     2c2:	50 e0       	ldi	r21, 0x00	; 0
     2c4:	60 e0       	ldi	r22, 0x00	; 0
     2c6:	70 e0       	ldi	r23, 0x00	; 0
     2c8:	0e 94 2c 12 	call	0x2458	; 0x2458 <vTaskDelayUntil>
     2cc:	f4 cf       	rjmp	.-24     	; 0x2b6 <_ZN16motor_controller3runEv+0xa8>

000002ce <_ZN16motor_controllerC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

motor_controller::motor_controller(const char* a_name, 
     2ce:	0f 93       	push	r16
     2d0:	1f 93       	push	r17
     2d2:	cf 93       	push	r28
     2d4:	df 93       	push	r29
     2d6:	ec 01       	movw	r28, r24
								 unsigned portBASE_TYPE a_priority, 
								 size_t a_stack_size,
								 emstream* p_ser_dev
								)
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     2d8:	0e 94 9b 02 	call	0x536	; 0x536 <_ZN8frt_taskC1EPKchjP8emstream>
     2dc:	8b e0       	ldi	r24, 0x0B	; 11
     2de:	92 e0       	ldi	r25, 0x02	; 2
     2e0:	99 83       	std	Y+1, r25	; 0x01
     2e2:	88 83       	st	Y, r24
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     2e4:	df 91       	pop	r29
     2e6:	cf 91       	pop	r28
     2e8:	1f 91       	pop	r17
     2ea:	0f 91       	pop	r16
     2ec:	08 95       	ret

000002ee <_ZN3adcC1EP8emstream>:
/** \brief This constructor sets up an A/D converter. 
 *  \details \b Details: The A/D converter is enabled and the division factor is set to 32.
 *  @param p_serial_port A pointer to the serial port where debugging info is written. 
 */

adc::adc (emstream* p_serial_port) {  
     2ee:	cf 93       	push	r28
     2f0:	df 93       	push	r29
     2f2:	fc 01       	movw	r30, r24
	ptr_to_serial = p_serial_port;
     2f4:	71 83       	std	Z+1, r23	; 0x01
     2f6:	60 83       	st	Z, r22
   
   // Set AVCC with external capacitor at AREF pin.
	ADMUX = (1 << REFS0);
     2f8:	80 e4       	ldi	r24, 0x40	; 64
     2fa:	80 93 7c 00 	sts	0x007C, r24
	ADMUX_init = ADMUX;
     2fe:	80 91 7c 00 	lds	r24, 0x007C
     302:	82 83       	std	Z+2, r24	; 0x02
	
	// Enable ADC and set prescaler to 32.
	ADCSRA = (1 << ADEN) | (1 << ADPS2) | (1 << ADPS0);
     304:	85 e8       	ldi	r24, 0x85	; 133
     306:	80 93 7a 00 	sts	0x007A, r24

	// Print a handy debugging message
  	DBG (ptr_to_serial, "A/D constructor OK" << endl);
     30a:	c0 81       	ld	r28, Z
     30c:	d1 81       	ldd	r29, Z+1	; 0x01
     30e:	20 97       	sbiw	r28, 0x00	; 0
     310:	49 f0       	breq	.+18     	; 0x324 <_ZN3adcC1EP8emstream+0x36>
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     312:	ce 01       	movw	r24, r28
     314:	6f e0       	ldi	r22, 0x0F	; 15
     316:	72 e0       	ldi	r23, 0x02	; 2
     318:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
     31c:	ce 01       	movw	r24, r28
     31e:	66 e0       	ldi	r22, 0x06	; 6
     320:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
}
     324:	df 91       	pop	r29
     326:	cf 91       	pop	r28
     328:	08 95       	ret

0000032a <_ZN3adc9read_onceEh>:

uint16_t adc::read_once (uint8_t ch) {
   uint8_t i = 0;
   uint16_t result;

   ADMUX = ADMUX_init;
     32a:	fc 01       	movw	r30, r24
     32c:	82 81       	ldd	r24, Z+2	; 0x02
     32e:	80 93 7c 00 	sts	0x007C, r24
   ADMUX |= ch;
     332:	80 91 7c 00 	lds	r24, 0x007C
     336:	68 2b       	or	r22, r24
     338:	60 93 7c 00 	sts	0x007C, r22

   // start conversion with ADSC
   ADCSRA |= (1 << ADSC);
     33c:	80 91 7a 00 	lds	r24, 0x007A
     340:	80 64       	ori	r24, 0x40	; 64
     342:	80 93 7a 00 	sts	0x007A, r24
   while (ADCSRA & (1 << ADSC) && i < 65) {
     346:	80 91 7a 00 	lds	r24, 0x007A
     34a:	86 ff       	sbrs	r24, 6
     34c:	1b c0       	rjmp	.+54     	; 0x384 <_ZN3adc9read_onceEh+0x5a>
     34e:	90 e0       	ldi	r25, 0x00	; 0
      i++;
     350:	9f 5f       	subi	r25, 0xFF	; 255
   ADMUX = ADMUX_init;
   ADMUX |= ch;

   // start conversion with ADSC
   ADCSRA |= (1 << ADSC);
   while (ADCSRA & (1 << ADSC) && i < 65) {
     352:	80 91 7a 00 	lds	r24, 0x007A
     356:	86 fd       	sbrc	r24, 6
     358:	0c c0       	rjmp	.+24     	; 0x372 <_ZN3adc9read_onceEh+0x48>
      i++;
   }
   
   result = ADCL | (ADCH << 8);
     35a:	80 91 78 00 	lds	r24, 0x0078
     35e:	40 91 79 00 	lds	r20, 0x0079
   //DBG (ptr_to_serial, "result: " << result << endl);
   return i == 65 ? -1 : result;
     362:	91 34       	cpi	r25, 0x41	; 65
     364:	c9 f0       	breq	.+50     	; 0x398 <_ZN3adc9read_onceEh+0x6e>
   ADCSRA |= (1 << ADSC);
   while (ADCSRA & (1 << ADSC) && i < 65) {
      i++;
   }
   
   result = ADCL | (ADCH << 8);
     366:	34 2f       	mov	r19, r20
     368:	20 e0       	ldi	r18, 0x00	; 0
     36a:	90 e0       	ldi	r25, 0x00	; 0
     36c:	82 2b       	or	r24, r18
     36e:	93 2b       	or	r25, r19
     370:	08 95       	ret
   ADMUX = ADMUX_init;
   ADMUX |= ch;

   // start conversion with ADSC
   ADCSRA |= (1 << ADSC);
   while (ADCSRA & (1 << ADSC) && i < 65) {
     372:	91 34       	cpi	r25, 0x41	; 65
     374:	69 f7       	brne	.-38     	; 0x350 <_ZN3adc9read_onceEh+0x26>
      i++;
   }
   
   result = ADCL | (ADCH << 8);
     376:	80 91 78 00 	lds	r24, 0x0078
     37a:	80 91 79 00 	lds	r24, 0x0079
   //DBG (ptr_to_serial, "result: " << result << endl);
   return i == 65 ? -1 : result;
     37e:	8f ef       	ldi	r24, 0xFF	; 255
     380:	9f ef       	ldi	r25, 0xFF	; 255
     382:	08 95       	ret
   ADCSRA |= (1 << ADSC);
   while (ADCSRA & (1 << ADSC) && i < 65) {
      i++;
   }
   
   result = ADCL | (ADCH << 8);
     384:	80 91 78 00 	lds	r24, 0x0078
     388:	90 91 79 00 	lds	r25, 0x0079
     38c:	39 2f       	mov	r19, r25
     38e:	20 e0       	ldi	r18, 0x00	; 0
     390:	90 e0       	ldi	r25, 0x00	; 0
     392:	82 2b       	or	r24, r18
     394:	93 2b       	or	r25, r19
     396:	08 95       	ret
   //DBG (ptr_to_serial, "result: " << result << endl);
   return i == 65 ? -1 : result;
     398:	8f ef       	ldi	r24, 0xFF	; 255
     39a:	9f ef       	ldi	r25, 0xFF	; 255
}
     39c:	08 95       	ret

0000039e <_ZN3adc16read_oversampledEhh>:
 *  @param channel A selected channel to read from.
 *  @param samples The chosen number of samples.
 *  @return The average readings from a chosen number of samples.
 */

uint16_t adc::read_oversampled (uint8_t channel, uint8_t samples) {
     39e:	df 92       	push	r13
     3a0:	ef 92       	push	r14
     3a2:	ff 92       	push	r15
     3a4:	0f 93       	push	r16
     3a6:	1f 93       	push	r17
     3a8:	cf 93       	push	r28
     3aa:	df 93       	push	r29
     3ac:	8c 01       	movw	r16, r24
     3ae:	f6 2e       	mov	r15, r22
     3b0:	d4 2e       	mov	r13, r20
	uint16_t sum = 0;
     3b2:	80 e2       	ldi	r24, 0x20	; 32
     3b4:	84 17       	cp	r24, r20
     3b6:	e0 f4       	brcc	.+56     	; 0x3f0 <_ZN3adc16read_oversampledEhh+0x52>
     3b8:	80 e2       	ldi	r24, 0x20	; 32
     3ba:	d8 2e       	mov	r13, r24

   if (samples > 32) {
      samples = 32;
   }
   
   for (i = 0; i < samples; i++) {
     3bc:	ee 24       	eor	r14, r14
     3be:	c0 e0       	ldi	r28, 0x00	; 0
     3c0:	d0 e0       	ldi	r29, 0x00	; 0
      sum += read_once(channel);
     3c2:	c8 01       	movw	r24, r16
     3c4:	6f 2d       	mov	r22, r15
     3c6:	0e 94 95 01 	call	0x32a	; 0x32a <_ZN3adc9read_onceEh>
     3ca:	c8 0f       	add	r28, r24
     3cc:	d9 1f       	adc	r29, r25

   if (samples > 32) {
      samples = 32;
   }
   
   for (i = 0; i < samples; i++) {
     3ce:	e3 94       	inc	r14
     3d0:	ed 14       	cp	r14, r13
     3d2:	b9 f7       	brne	.-18     	; 0x3c2 <_ZN3adc16read_oversampledEhh+0x24>
      sum += read_once(channel);
   }

   //DBG (ptr_to_serial, "average: " << sum / samples << endl);
   return sum / samples;
     3d4:	6d 2d       	mov	r22, r13
     3d6:	ce 01       	movw	r24, r28
     3d8:	70 e0       	ldi	r23, 0x00	; 0
     3da:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <__udivmodhi4>
     3de:	cb 01       	movw	r24, r22
}
     3e0:	df 91       	pop	r29
     3e2:	cf 91       	pop	r28
     3e4:	1f 91       	pop	r17
     3e6:	0f 91       	pop	r16
     3e8:	ff 90       	pop	r15
     3ea:	ef 90       	pop	r14
     3ec:	df 90       	pop	r13
     3ee:	08 95       	ret

   if (samples > 32) {
      samples = 32;
   }
   
   for (i = 0; i < samples; i++) {
     3f0:	44 23       	and	r20, r20
     3f2:	21 f7       	brne	.-56     	; 0x3bc <_ZN3adc16read_oversampledEhh+0x1e>
 *  @param samples The chosen number of samples.
 *  @return The average readings from a chosen number of samples.
 */

uint16_t adc::read_oversampled (uint8_t channel, uint8_t samples) {
	uint16_t sum = 0;
     3f4:	c0 e0       	ldi	r28, 0x00	; 0
     3f6:	d0 e0       	ldi	r29, 0x00	; 0
     3f8:	ed cf       	rjmp	.-38     	; 0x3d4 <_ZN3adc16read_oversampledEhh+0x36>

000003fa <_ZlsR8emstreamR3adc>:
 *  @param a2d The A/D driver which is being printed.
 *  @return A reference to the same serial device that the information is written to.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& serpt, adc& a2d) {
     3fa:	cf 93       	push	r28
     3fc:	df 93       	push	r29
     3fe:	d8 2f       	mov	r29, r24
     400:	c9 2f       	mov	r28, r25
     402:	62 e2       	ldi	r22, 0x22	; 34
     404:	72 e0       	ldi	r23, 0x02	; 2
     406:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>

	serpt << "ADMUX: " << bin << ADMUX << endl;
     40a:	8d 2f       	mov	r24, r29
     40c:	9c 2f       	mov	r25, r28
     40e:	60 e0       	ldi	r22, 0x00	; 0
     410:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     414:	60 91 7c 00 	lds	r22, 0x007C
     418:	0e 94 aa 06 	call	0xd54	; 0xd54 <_ZN8emstreamlsEh>
     41c:	66 e0       	ldi	r22, 0x06	; 6
     41e:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     422:	8d 2f       	mov	r24, r29
     424:	9c 2f       	mov	r25, r28
     426:	6a e2       	ldi	r22, 0x2A	; 42
     428:	72 e0       	ldi	r23, 0x02	; 2
     42a:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
   serpt << "ADCSRA: " << bin << ADCSRA << endl;
     42e:	8d 2f       	mov	r24, r29
     430:	9c 2f       	mov	r25, r28
     432:	60 e0       	ldi	r22, 0x00	; 0
     434:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     438:	60 91 7a 00 	lds	r22, 0x007A
     43c:	0e 94 aa 06 	call	0xd54	; 0xd54 <_ZN8emstreamlsEh>
     440:	66 e0       	ldi	r22, 0x06	; 6
     442:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>

	return (serpt);
}
     446:	8d 2f       	mov	r24, r29
     448:	9c 2f       	mov	r25, r28
     44a:	df 91       	pop	r29
     44c:	cf 91       	pop	r28
     44e:	08 95       	ret

00000450 <_ZN12motor_driverC1EP8emstreamPVhhS3_hS3_hhS3_hS3_hPVj>:
 *  @param p_tccrb A pointer to the timer/counter register B.
 *  @param tccrb_mask Timer/counter register B mask.
 *  @param ocr A pointer to the output compare register.
 */

motor_driver::motor_driver(emstream *p_serial_port,
     450:	8f 92       	push	r8
     452:	af 92       	push	r10
     454:	cf 92       	push	r12
     456:	df 92       	push	r13
     458:	ef 92       	push	r14
     45a:	0f 93       	push	r16
     45c:	1f 93       	push	r17
     45e:	cf 93       	push	r28
     460:	df 93       	push	r29
     462:	cd b7       	in	r28, 0x3d	; 61
     464:	de b7       	in	r29, 0x3e	; 62
     466:	fc 01       	movw	r30, r24
                           uint8_t tccra_mask,
                           volatile uint8_t *p_tccrb,
                           uint8_t tccrb_mask,
                           volatile uint16_t *p_ocr) {  

   ptr_to_serial = p_serial_port;
     468:	71 83       	std	Z+1, r23	; 0x01
     46a:	60 83       	st	Z, r22
   compare = p_ocr;
     46c:	8a 89       	ldd	r24, Y+18	; 0x12
     46e:	9b 89       	ldd	r25, Y+19	; 0x13
     470:	93 83       	std	Z+3, r25	; 0x03
     472:	82 83       	std	Z+2, r24	; 0x02
   direction = p_port;
     474:	d5 82       	std	Z+5, r13	; 0x05
     476:	c4 82       	std	Z+4, r12	; 0x04
   cw = cw_mask;
     478:	a6 82       	std	Z+6, r10	; 0x06
   ccw = ccw_mask;
     47a:	87 82       	std	Z+7, r8	; 0x07

   *p_ddr = ddr_mask;
     47c:	da 01       	movw	r26, r20
     47e:	2c 93       	st	X, r18
   *p_pwm = pwm_mask;
     480:	d8 01       	movw	r26, r16
     482:	ec 92       	st	X, r14
   *p_port = cw_mask;
     484:	d6 01       	movw	r26, r12
     486:	ac 92       	st	X, r10
   *p_tccra = tccra_mask;
     488:	8e 85       	ldd	r24, Y+14	; 0x0e
     48a:	ac 85       	ldd	r26, Y+12	; 0x0c
     48c:	bd 85       	ldd	r27, Y+13	; 0x0d
     48e:	8c 93       	st	X, r24
   *p_tccrb = tccrb_mask;
     490:	89 89       	ldd	r24, Y+17	; 0x11
     492:	af 85       	ldd	r26, Y+15	; 0x0f
     494:	b8 89       	ldd	r27, Y+16	; 0x10
     496:	8c 93       	st	X, r24
   *compare = 128;
     498:	a2 81       	ldd	r26, Z+2	; 0x02
     49a:	b3 81       	ldd	r27, Z+3	; 0x03
     49c:	80 e8       	ldi	r24, 0x80	; 128
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	11 96       	adiw	r26, 0x01	; 1
     4a2:	9c 93       	st	X, r25
     4a4:	8e 93       	st	-X, r24
   // PORTC = (1 << 0) | (1 << 2);
   // TCCR1A = (1 << COM1A1) | (1 << COM1B1) | (1 << COM1C1) | (1 << WGM10); // Fast PWM 8-bit
   // TCCR1B = (1 << WGM12) | (1 << CS11) | (1 << CS10); // clk/64 (prescaler)
   // OCR1B = 50;

   DBG(ptr_to_serial, "Motor driver constructor OK" << endl);
     4a6:	00 81       	ld	r16, Z
     4a8:	11 81       	ldd	r17, Z+1	; 0x01
     4aa:	01 15       	cp	r16, r1
     4ac:	11 05       	cpc	r17, r1
     4ae:	49 f0       	breq	.+18     	; 0x4c2 <_ZN12motor_driverC1EP8emstreamPVhhS3_hS3_hhS3_hS3_hPVj+0x72>
     4b0:	c8 01       	movw	r24, r16
     4b2:	63 e3       	ldi	r22, 0x33	; 51
     4b4:	72 e0       	ldi	r23, 0x02	; 2
     4b6:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
     4ba:	c8 01       	movw	r24, r16
     4bc:	66 e0       	ldi	r22, 0x06	; 6
     4be:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
}
     4c2:	df 91       	pop	r29
     4c4:	cf 91       	pop	r28
     4c6:	1f 91       	pop	r17
     4c8:	0f 91       	pop	r16
     4ca:	ef 90       	pop	r14
     4cc:	df 90       	pop	r13
     4ce:	cf 90       	pop	r12
     4d0:	af 90       	pop	r10
     4d2:	8f 90       	pop	r8
     4d4:	08 95       	ret

000004d6 <_ZN12motor_driver9set_powerEi>:
void motor_driver::set_power(int16_t power) {
   // compare = something;
   // 128 = 0;
   // < 128 = negative;
   // > 128 = positive;
}
     4d6:	08 95       	ret

000004d8 <_ZN12motor_driver5brakeEv>:
 */

void motor_driver::brake(void) {


}
     4d8:	08 95       	ret

000004da <_ZN12motor_driver6sampleEv>:

void motor_driver::sample(void) {
     4da:	cf 93       	push	r28
     4dc:	df 93       	push	r29
   DBG(ptr_to_serial, "TCNT1: " << TCNT1 << endl);
     4de:	fc 01       	movw	r30, r24
     4e0:	c0 81       	ld	r28, Z
     4e2:	d1 81       	ldd	r29, Z+1	; 0x01
     4e4:	20 97       	sbiw	r28, 0x00	; 0
     4e6:	79 f0       	breq	.+30     	; 0x506 <_ZN12motor_driver6sampleEv+0x2c>
     4e8:	ce 01       	movw	r24, r28
     4ea:	6f e4       	ldi	r22, 0x4F	; 79
     4ec:	72 e0       	ldi	r23, 0x02	; 2
     4ee:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
     4f2:	60 91 84 00 	lds	r22, 0x0084
     4f6:	70 91 85 00 	lds	r23, 0x0085
     4fa:	ce 01       	movw	r24, r28
     4fc:	0e 94 2a 06 	call	0xc54	; 0xc54 <_ZN8emstreamlsEj>
     500:	66 e0       	ldi	r22, 0x06	; 6
     502:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     506:	df 91       	pop	r29
     508:	cf 91       	pop	r28
     50a:	08 95       	ret

0000050c <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
     50c:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
     50e:	e8 81       	ld	r30, Y
     510:	f9 81       	ldd	r31, Y+1	; 0x01
     512:	01 90       	ld	r0, Z+
     514:	f0 81       	ld	r31, Z
     516:	e0 2d       	mov	r30, r0
     518:	09 95       	icall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
     51a:	1b 82       	std	Y+3, r1	; 0x03
     51c:	1a 82       	std	Y+2, r1	; 0x02

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
     51e:	6f ef       	ldi	r22, 0xFF	; 255
     520:	7f ef       	ldi	r23, 0xFF	; 255
     522:	cb 01       	movw	r24, r22
     524:	0e 94 f6 11 	call	0x23ec	; 0x23ec <vTaskDelay>
     528:	fa cf       	rjmp	.-12     	; 0x51e <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

0000052a <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     52a:	0e 94 86 02 	call	0x50c	; 0x50c <_ZN8frt_task22_call_users_run_methodEPS_>

0000052e <_ZN8frt_task13transition_toEh>:
 *  variable 'state', and if transition logging is enabled, it logs the transition to 
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
     52e:	fc 01       	movw	r30, r24
	state = new_state;
     530:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
     532:	65 87       	std	Z+13, r22	; 0x0d
}
     534:	08 95       	ret

00000536 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
     536:	2f 92       	push	r2
     538:	3f 92       	push	r3
     53a:	4f 92       	push	r4
     53c:	5f 92       	push	r5
     53e:	6f 92       	push	r6
     540:	7f 92       	push	r7
     542:	8f 92       	push	r8
     544:	9f 92       	push	r9
     546:	af 92       	push	r10
     548:	bf 92       	push	r11
     54a:	cf 92       	push	r12
     54c:	df 92       	push	r13
     54e:	ef 92       	push	r14
     550:	ff 92       	push	r15
     552:	0f 93       	push	r16
     554:	1f 93       	push	r17
     556:	cf 93       	push	r28
     558:	df 93       	push	r29
     55a:	cd b7       	in	r28, 0x3d	; 61
     55c:	de b7       	in	r29, 0x3e	; 62
     55e:	2a 97       	sbiw	r28, 0x0a	; 10
     560:	0f b6       	in	r0, 0x3f	; 63
     562:	f8 94       	cli
     564:	de bf       	out	0x3e, r29	; 62
     566:	0f be       	out	0x3f, r0	; 63
     568:	cd bf       	out	0x3d, r28	; 61
     56a:	4c 01       	movw	r8, r24
     56c:	db 01       	movw	r26, r22
     56e:	d4 2e       	mov	r13, r20
     570:	19 01       	movw	r2, r18
     572:	28 01       	movw	r4, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
     574:	8b e5       	ldi	r24, 0x5B	; 91
     576:	92 e0       	ldi	r25, 0x02	; 2
     578:	f4 01       	movw	r30, r8
     57a:	91 83       	std	Z+1, r25	; 0x01
     57c:	80 83       	st	Z, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
     57e:	2c 91       	ld	r18, X
     580:	22 23       	and	r18, r18
     582:	09 f4       	brne	.+2      	; 0x586 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
     584:	7b c0       	rjmp	.+246    	; 0x67c <_ZN8frt_taskC1EPKchjP8emstream+0x146>
     586:	3e 01       	movw	r6, r28
     588:	08 94       	sec
     58a:	61 1c       	adc	r6, r1
     58c:	71 1c       	adc	r7, r1
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
     58e:	11 96       	adiw	r26, 0x01	; 1
     590:	ce 01       	movw	r24, r28
     592:	0a 96       	adiw	r24, 0x0a	; 10
     594:	f3 01       	movw	r30, r6
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
     596:	21 93       	st	Z+, r18
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
     598:	3e 2f       	mov	r19, r30
     59a:	36 19       	sub	r19, r6
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
     59c:	2d 91       	ld	r18, X+
     59e:	22 23       	and	r18, r18
     5a0:	09 f0       	breq	.+2      	; 0x5a4 <_ZN8frt_taskC1EPKchjP8emstream+0x6e>
     5a2:	67 c0       	rjmp	.+206    	; 0x672 <_ZN8frt_taskC1EPKchjP8emstream+0x13c>
     5a4:	83 2f       	mov	r24, r19
     5a6:	90 e0       	ldi	r25, 0x00	; 0
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
     5a8:	86 0d       	add	r24, r6
     5aa:	97 1d       	adc	r25, r7
     5ac:	fc 01       	movw	r30, r24
     5ae:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
     5b0:	22 e0       	ldi	r18, 0x02	; 2
     5b2:	e2 2e       	mov	r14, r18
     5b4:	f1 2c       	mov	r15, r1
     5b6:	e8 0c       	add	r14, r8
     5b8:	f9 1c       	adc	r15, r9
     5ba:	85 e9       	ldi	r24, 0x95	; 149
     5bc:	92 e0       	ldi	r25, 0x02	; 2
     5be:	b3 01       	movw	r22, r6
     5c0:	a1 01       	movw	r20, r2
     5c2:	94 01       	movw	r18, r8
     5c4:	0d 2d       	mov	r16, r13
     5c6:	cc 24       	eor	r12, r12
     5c8:	dd 24       	eor	r13, r13
     5ca:	aa 24       	eor	r10, r10
     5cc:	bb 24       	eor	r11, r11
     5ce:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
     5d2:	f4 01       	movw	r30, r8
     5d4:	57 82       	std	Z+7, r5	; 0x07
     5d6:	46 82       	std	Z+6, r4	; 0x06
	total_stack = a_stack_size;
     5d8:	31 86       	std	Z+9, r3	; 0x09
     5da:	20 86       	std	Z+8, r2	; 0x08

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
     5dc:	20 91 aa 02 	lds	r18, 0x02AA
     5e0:	30 91 ab 02 	lds	r19, 0x02AB
     5e4:	35 83       	std	Z+5, r19	; 0x05
     5e6:	24 83       	std	Z+4, r18	; 0x04
	last_created_task_pointer = this;
     5e8:	90 92 ab 02 	sts	0x02AB, r9
     5ec:	80 92 aa 02 	sts	0x02AA, r8

	// Initialize the finite state machine and its transition logger
	state = 0;
     5f0:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
     5f2:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
     5f4:	20 91 54 1a 	lds	r18, 0x1A54
     5f8:	30 91 55 1a 	lds	r19, 0x1A55
     5fc:	2f 5f       	subi	r18, 0xFF	; 255
     5fe:	3f 4f       	sbci	r19, 0xFF	; 255
     600:	30 93 55 1a 	sts	0x1A55, r19
     604:	20 93 54 1a 	sts	0x1A54, r18
     608:	33 87       	std	Z+11, r19	; 0x0b
     60a:	22 87       	std	Z+10, r18	; 0x0a

	// Initialize the run counter
	runs = 0;
     60c:	16 86       	std	Z+14, r1	; 0x0e
     60e:	17 86       	std	Z+15, r1	; 0x0f
     610:	10 8a       	std	Z+16, r1	; 0x10
     612:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
     614:	41 14       	cp	r4, r1
     616:	51 04       	cpc	r5, r1
     618:	99 f0       	breq	.+38     	; 0x640 <_ZN8frt_taskC1EPKchjP8emstream+0x10a>
	{
		if (task_status == pdPASS)
     61a:	81 30       	cpi	r24, 0x01	; 1
     61c:	b1 f1       	breq	.+108    	; 0x68a <_ZN8frt_taskC1EPKchjP8emstream+0x154>
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
     61e:	c2 01       	movw	r24, r4
     620:	6a e0       	ldi	r22, 0x0A	; 10
     622:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     626:	7c 01       	movw	r14, r24
     628:	66 e0       	ldi	r22, 0x06	; 6
     62a:	71 e0       	ldi	r23, 0x01	; 1
     62c:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
     630:	c7 01       	movw	r24, r14
     632:	b3 01       	movw	r22, r6
     634:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
     638:	c7 01       	movw	r24, r14
     63a:	66 e0       	ldi	r22, 0x06	; 6
     63c:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
     640:	2a 96       	adiw	r28, 0x0a	; 10
     642:	0f b6       	in	r0, 0x3f	; 63
     644:	f8 94       	cli
     646:	de bf       	out	0x3e, r29	; 62
     648:	0f be       	out	0x3f, r0	; 63
     64a:	cd bf       	out	0x3d, r28	; 61
     64c:	df 91       	pop	r29
     64e:	cf 91       	pop	r28
     650:	1f 91       	pop	r17
     652:	0f 91       	pop	r16
     654:	ff 90       	pop	r15
     656:	ef 90       	pop	r14
     658:	df 90       	pop	r13
     65a:	cf 90       	pop	r12
     65c:	bf 90       	pop	r11
     65e:	af 90       	pop	r10
     660:	9f 90       	pop	r9
     662:	8f 90       	pop	r8
     664:	7f 90       	pop	r7
     666:	6f 90       	pop	r6
     668:	5f 90       	pop	r5
     66a:	4f 90       	pop	r4
     66c:	3f 90       	pop	r3
     66e:	2f 90       	pop	r2
     670:	08 95       	ret
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
     672:	e8 17       	cp	r30, r24
     674:	f9 07       	cpc	r31, r25
     676:	09 f0       	breq	.+2      	; 0x67a <_ZN8frt_taskC1EPKchjP8emstream+0x144>
     678:	8e cf       	rjmp	.-228    	; 0x596 <_ZN8frt_taskC1EPKchjP8emstream+0x60>
     67a:	94 cf       	rjmp	.-216    	; 0x5a4 <_ZN8frt_taskC1EPKchjP8emstream+0x6e>
     67c:	80 e0       	ldi	r24, 0x00	; 0
     67e:	90 e0       	ldi	r25, 0x00	; 0
     680:	3e 01       	movw	r6, r28
     682:	08 94       	sec
     684:	61 1c       	adc	r6, r1
     686:	71 1c       	adc	r7, r1
     688:	8f cf       	rjmp	.-226    	; 0x5a8 <_ZN8frt_taskC1EPKchjP8emstream+0x72>
	// successfully
	if (p_serial != NULL)
	{
		if (task_status == pdPASS)
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
     68a:	c2 01       	movw	r24, r4
     68c:	6a e0       	ldi	r22, 0x0A	; 10
     68e:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     692:	7c 01       	movw	r14, r24
     694:	69 ee       	ldi	r22, 0xE9	; 233
     696:	70 e0       	ldi	r23, 0x00	; 0
     698:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
     69c:	c7 01       	movw	r24, r14
     69e:	b3 01       	movw	r22, r6
     6a0:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
     6a4:	c7 01       	movw	r24, r14
     6a6:	6a e0       	ldi	r22, 0x0A	; 10
     6a8:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     6ac:	7c 01       	movw	r14, r24
     6ae:	6f ee       	ldi	r22, 0xEF	; 239
     6b0:	70 e0       	ldi	r23, 0x00	; 0
     6b2:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
     6b6:	c7 01       	movw	r24, r14
     6b8:	6a e0       	ldi	r22, 0x0A	; 10
     6ba:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     6be:	7c 01       	movw	r14, r24
     6c0:	68 ef       	ldi	r22, 0xF8	; 248
     6c2:	70 e0       	ldi	r23, 0x00	; 0
     6c4:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
     6c8:	c7 01       	movw	r24, r14
     6ca:	63 e0       	ldi	r22, 0x03	; 3
     6cc:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     6d0:	f4 01       	movw	r30, r8
     6d2:	62 85       	ldd	r22, Z+10	; 0x0a
     6d4:	73 85       	ldd	r23, Z+11	; 0x0b
     6d6:	0e 94 2a 06 	call	0xc54	; 0xc54 <_ZN8emstreamlsEj>
     6da:	62 e0       	ldi	r22, 0x02	; 2
     6dc:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     6e0:	66 e0       	ldi	r22, 0x06	; 6
     6e2:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     6e6:	ac cf       	rjmp	.-168    	; 0x640 <_ZN8frt_taskC1EPKchjP8emstream+0x10a>

000006e8 <_ZN8frt_task15emergency_resetEv>:
/** This method prints an error message and resets the processor. It should only be 
 *  used in cases of things going seriously to heck.
 */

void frt_task::emergency_reset (void)
{
     6e8:	ec 01       	movw	r28, r24
	*p_serial << PMS ("ERROR in task ") << get_name () << PMS ("Resetting") << endl;
     6ea:	8e 81       	ldd	r24, Y+6	; 0x06
     6ec:	9f 81       	ldd	r25, Y+7	; 0x07
     6ee:	6a e0       	ldi	r22, 0x0A	; 10
     6f0:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     6f4:	8c 01       	movw	r16, r24
     6f6:	6b e1       	ldi	r22, 0x1B	; 27
     6f8:	71 e0       	ldi	r23, 0x01	; 1
     6fa:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
		*  terminated character array belonging to the task. 
		*  @return A pointer to the task's name
		*/
		const char* get_name (void)
		{
			return ((const char*)(pcTaskGetTaskName (handle)));
     6fe:	8a 81       	ldd	r24, Y+2	; 0x02
     700:	9b 81       	ldd	r25, Y+3	; 0x03
     702:	0e 94 69 10 	call	0x20d2	; 0x20d2 <pcTaskGetTaskName>
     706:	bc 01       	movw	r22, r24
     708:	c8 01       	movw	r24, r16
     70a:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
     70e:	c8 01       	movw	r24, r16
     710:	6a e0       	ldi	r22, 0x0A	; 10
     712:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     716:	ec 01       	movw	r28, r24
     718:	6a e2       	ldi	r22, 0x2A	; 42
     71a:	71 e0       	ldi	r23, 0x01	; 1
     71c:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
     720:	ce 01       	movw	r24, r28
     722:	66 e0       	ldi	r22, 0x06	; 6
     724:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
	wdt_enable (WDTO_120MS);
     728:	2b e0       	ldi	r18, 0x0B	; 11
     72a:	88 e1       	ldi	r24, 0x18	; 24
     72c:	90 e0       	ldi	r25, 0x00	; 0
     72e:	0f b6       	in	r0, 0x3f	; 63
     730:	f8 94       	cli
     732:	a8 95       	wdr
     734:	80 93 60 00 	sts	0x0060, r24
     738:	0f be       	out	0x3f, r0	; 63
     73a:	20 93 60 00 	sts	0x0060, r18
     73e:	ff cf       	rjmp	.-2      	; 0x73e <_ZN8frt_task15emergency_resetEv+0x56>

00000740 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
     740:	0f 93       	push	r16
     742:	1f 93       	push	r17
     744:	cf 93       	push	r28
     746:	df 93       	push	r29
     748:	8c 01       	movw	r16, r24
     74a:	eb 01       	movw	r28, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
     74c:	fc 01       	movw	r30, r24
     74e:	82 81       	ldd	r24, Z+2	; 0x02
     750:	93 81       	ldd	r25, Z+3	; 0x03
     752:	0e 94 69 10 	call	0x20d2	; 0x20d2 <pcTaskGetTaskName>
     756:	bc 01       	movw	r22, r24
     758:	ce 01       	movw	r24, r28
     75a:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
     75e:	e8 81       	ld	r30, Y
     760:	f9 81       	ldd	r31, Y+1	; 0x01
     762:	02 80       	ldd	r0, Z+2	; 0x02
     764:	f3 81       	ldd	r31, Z+3	; 0x03
     766:	e0 2d       	mov	r30, r0
     768:	ce 01       	movw	r24, r28
     76a:	69 e0       	ldi	r22, 0x09	; 9
     76c:	09 95       	icall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
     76e:	f8 01       	movw	r30, r16
     770:	82 81       	ldd	r24, Z+2	; 0x02
     772:	93 81       	ldd	r25, Z+3	; 0x03
     774:	0e 94 69 10 	call	0x20d2	; 0x20d2 <pcTaskGetTaskName>
     778:	dc 01       	movw	r26, r24
     77a:	0d 90       	ld	r0, X+
     77c:	00 20       	and	r0, r0
     77e:	e9 f7       	brne	.-6      	; 0x77a <_ZN8frt_task12print_statusER8emstream+0x3a>
     780:	11 97       	sbiw	r26, 0x01	; 1
     782:	a8 1b       	sub	r26, r24
     784:	b9 0b       	sbc	r27, r25
     786:	a8 30       	cpi	r26, 0x08	; 8
     788:	b1 05       	cpc	r27, r1
     78a:	40 f4       	brcc	.+16     	; 0x79c <_ZN8frt_task12print_statusER8emstream+0x5c>
	{
		ser_dev.putchar ('\t');
     78c:	e8 81       	ld	r30, Y
     78e:	f9 81       	ldd	r31, Y+1	; 0x01
     790:	02 80       	ldd	r0, Z+2	; 0x02
     792:	f3 81       	ldd	r31, Z+3	; 0x03
     794:	e0 2d       	mov	r30, r0
     796:	ce 01       	movw	r24, r28
     798:	69 e0       	ldi	r22, 0x09	; 9
     79a:	09 95       	icall
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
     79c:	f8 01       	movw	r30, r16
     79e:	82 81       	ldd	r24, Z+2	; 0x02
     7a0:	93 81       	ldd	r25, Z+3	; 0x03
     7a2:	0e 94 65 0f 	call	0x1eca	; 0x1eca <uxTaskPriorityGet>
     7a6:	68 2f       	mov	r22, r24
     7a8:	ce 01       	movw	r24, r28
     7aa:	0e 94 aa 06 	call	0xd54	; 0xd54 <_ZN8emstreamlsEh>
     7ae:	6a e0       	ldi	r22, 0x0A	; 10
     7b0:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     7b4:	ec 01       	movw	r28, r24
     7b6:	64 e3       	ldi	r22, 0x34	; 52
     7b8:	71 e0       	ldi	r23, 0x01	; 1
     7ba:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
			<< get_state ()
     7be:	ce 01       	movw	r24, r28
     7c0:	f8 01       	movw	r30, r16
     7c2:	64 85       	ldd	r22, Z+12	; 0x0c
     7c4:	0e 94 aa 06 	call	0xd54	; 0xd54 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
     7c8:	6a e0       	ldi	r22, 0x0A	; 10
     7ca:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     7ce:	ec 01       	movw	r28, r24
     7d0:	66 e3       	ldi	r22, 0x36	; 54
     7d2:	71 e0       	ldi	r23, 0x01	; 1
     7d4:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
     7d8:	f8 01       	movw	r30, r16
     7da:	82 81       	ldd	r24, Z+2	; 0x02
     7dc:	93 81       	ldd	r25, Z+3	; 0x03
     7de:	0e 94 cc 13 	call	0x2798	; 0x2798 <uxTaskGetStackHighWaterMark>
     7e2:	68 2f       	mov	r22, r24
     7e4:	ce 01       	movw	r24, r28
     7e6:	0e 94 aa 06 	call	0xd54	; 0xd54 <_ZN8emstreamlsEh>
     7ea:	6a e0       	ldi	r22, 0x0A	; 10
     7ec:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     7f0:	ec 01       	movw	r28, r24
     7f2:	68 e3       	ldi	r22, 0x38	; 56
     7f4:	71 e0       	ldi	r23, 0x01	; 1
     7f6:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
     7fa:	f8 01       	movw	r30, r16
     7fc:	60 85       	ldd	r22, Z+8	; 0x08
     7fe:	71 85       	ldd	r23, Z+9	; 0x09
     800:	ce 01       	movw	r24, r28
     802:	0e 94 2a 06 	call	0xc54	; 0xc54 <_ZN8emstreamlsEj>
     806:	6a e0       	ldi	r22, 0x0A	; 10
     808:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     80c:	ec 01       	movw	r28, r24
     80e:	6a e3       	ldi	r22, 0x3A	; 58
     810:	71 e0       	ldi	r23, 0x01	; 1
     812:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
     816:	ce 01       	movw	r24, r28
     818:	6a e0       	ldi	r22, 0x0A	; 10
     81a:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     81e:	ec 01       	movw	r28, r24
     820:	6c e3       	ldi	r22, 0x3C	; 60
     822:	71 e0       	ldi	r23, 0x01	; 1
     824:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
     828:	f8 01       	movw	r30, r16
     82a:	46 85       	ldd	r20, Z+14	; 0x0e
     82c:	57 85       	ldd	r21, Z+15	; 0x0f
     82e:	60 89       	ldd	r22, Z+16	; 0x10
     830:	71 89       	ldd	r23, Z+17	; 0x11
     832:	ce 01       	movw	r24, r28
     834:	0e 94 64 06 	call	0xcc8	; 0xcc8 <_ZN8emstreamlsEm>
}
     838:	df 91       	pop	r29
     83a:	cf 91       	pop	r28
     83c:	1f 91       	pop	r17
     83e:	0f 91       	pop	r16
     840:	08 95       	ret

00000842 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
     842:	0f 93       	push	r16
     844:	1f 93       	push	r17
     846:	cf 93       	push	r28
     848:	df 93       	push	r29
     84a:	ec 01       	movw	r28, r24
     84c:	8b 01       	movw	r16, r22
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
	a_task.print_status (ser_dev);
     84e:	e8 81       	ld	r30, Y
     850:	f9 81       	ldd	r31, Y+1	; 0x01
     852:	02 80       	ldd	r0, Z+2	; 0x02
     854:	f3 81       	ldd	r31, Z+3	; 0x03
     856:	e0 2d       	mov	r30, r0
     858:	ce 01       	movw	r24, r28
     85a:	b8 01       	movw	r22, r16
     85c:	09 95       	icall
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
	*ser_device << *this << endl;
     85e:	c8 01       	movw	r24, r16
     860:	66 e0       	ldi	r22, 0x06	; 6
     862:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
     866:	0c 80       	ldd	r0, Y+4	; 0x04
     868:	dd 81       	ldd	r29, Y+5	; 0x05
     86a:	c0 2d       	mov	r28, r0
     86c:	20 97       	sbiw	r28, 0x00	; 0
     86e:	79 f7       	brne	.-34     	; 0x84e <_ZN8frt_task20print_status_in_listEP8emstream+0xc>
	{
		prev_task_pointer->print_status_in_list (ser_device);
	}
}
     870:	df 91       	pop	r29
     872:	cf 91       	pop	r28
     874:	1f 91       	pop	r17
     876:	0f 91       	pop	r16
     878:	08 95       	ret

0000087a <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
     87a:	cf 93       	push	r28
     87c:	df 93       	push	r29
     87e:	d8 2f       	mov	r29, r24
     880:	c9 2f       	mov	r28, r25
     882:	db 01       	movw	r26, r22
	a_task.print_status (ser_dev);
     884:	ed 91       	ld	r30, X+
     886:	fc 91       	ld	r31, X
     888:	02 80       	ldd	r0, Z+2	; 0x02
     88a:	f3 81       	ldd	r31, Z+3	; 0x03
     88c:	e0 2d       	mov	r30, r0
     88e:	cb 01       	movw	r24, r22
     890:	6d 2f       	mov	r22, r29
     892:	7c 2f       	mov	r23, r28
     894:	09 95       	icall
	return (ser_dev);
}
     896:	8d 2f       	mov	r24, r29
     898:	9c 2f       	mov	r25, r28
     89a:	df 91       	pop	r29
     89c:	cf 91       	pop	r28
     89e:	08 95       	ret

000008a0 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
     8a0:	0f 93       	push	r16
     8a2:	1f 93       	push	r17
     8a4:	cf 93       	push	r28
     8a6:	df 93       	push	r29
     8a8:	8c 01       	movw	r16, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
     8aa:	6a e0       	ldi	r22, 0x0A	; 10
     8ac:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     8b0:	ec 01       	movw	r28, r24
     8b2:	6e e3       	ldi	r22, 0x3E	; 62
     8b4:	71 e0       	ldi	r23, 0x01	; 1
     8b6:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
     8ba:	ce 01       	movw	r24, r28
     8bc:	6a e0       	ldi	r22, 0x0A	; 10
     8be:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     8c2:	ec 01       	movw	r28, r24
     8c4:	69 e4       	ldi	r22, 0x49	; 73
     8c6:	71 e0       	ldi	r23, 0x01	; 1
     8c8:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
     8cc:	ce 01       	movw	r24, r28
     8ce:	66 e0       	ldi	r22, 0x06	; 6
     8d0:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
     8d4:	c8 01       	movw	r24, r16
     8d6:	6a e0       	ldi	r22, 0x0A	; 10
     8d8:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     8dc:	ec 01       	movw	r28, r24
     8de:	60 e5       	ldi	r22, 0x50	; 80
     8e0:	71 e0       	ldi	r23, 0x01	; 1
     8e2:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
     8e6:	ce 01       	movw	r24, r28
     8e8:	6a e0       	ldi	r22, 0x0A	; 10
     8ea:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     8ee:	ec 01       	movw	r28, r24
     8f0:	61 e6       	ldi	r22, 0x61	; 97
     8f2:	71 e0       	ldi	r23, 0x01	; 1
     8f4:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
     8f8:	ce 01       	movw	r24, r28
     8fa:	6a e0       	ldi	r22, 0x0A	; 10
     8fc:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     900:	ec 01       	movw	r28, r24
     902:	6d e6       	ldi	r22, 0x6D	; 109
     904:	71 e0       	ldi	r23, 0x01	; 1
     906:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
     90a:	ce 01       	movw	r24, r28
     90c:	66 e0       	ldi	r22, 0x06	; 6
     90e:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
     912:	c8 01       	movw	r24, r16
     914:	6a e0       	ldi	r22, 0x0A	; 10
     916:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     91a:	ec 01       	movw	r28, r24
     91c:	63 e7       	ldi	r22, 0x73	; 115
     91e:	71 e0       	ldi	r23, 0x01	; 1
     920:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
     924:	ce 01       	movw	r24, r28
     926:	6a e0       	ldi	r22, 0x0A	; 10
     928:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     92c:	ec 01       	movw	r28, r24
     92e:	64 e8       	ldi	r22, 0x84	; 132
     930:	71 e0       	ldi	r23, 0x01	; 1
     932:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
     936:	ce 01       	movw	r24, r28
     938:	6a e0       	ldi	r22, 0x0A	; 10
     93a:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     93e:	ec 01       	movw	r28, r24
     940:	60 e9       	ldi	r22, 0x90	; 144
     942:	71 e0       	ldi	r23, 0x01	; 1
     944:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
     948:	ce 01       	movw	r24, r28
     94a:	66 e0       	ldi	r22, 0x06	; 6
     94c:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
     950:	80 91 aa 02 	lds	r24, 0x02AA
     954:	90 91 ab 02 	lds	r25, 0x02AB
     958:	00 97       	sbiw	r24, 0x00	; 0
     95a:	19 f0       	breq	.+6      	; 0x962 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
     95c:	b8 01       	movw	r22, r16
     95e:	0e 94 21 04 	call	0x842	; 0x842 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
     962:	c8 01       	movw	r24, r16
     964:	6a e0       	ldi	r22, 0x0A	; 10
     966:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     96a:	ec 01       	movw	r28, r24
     96c:	66 e9       	ldi	r22, 0x96	; 150
     96e:	71 e0       	ldi	r23, 0x01	; 1
     970:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
     974:	0e 94 73 10 	call	0x20e6	; 0x20e6 <xTaskGetIdleTaskHandle>
     978:	0e 94 cc 13 	call	0x2798	; 0x2798 <uxTaskGetStackHighWaterMark>
     97c:	68 2f       	mov	r22, r24
     97e:	ce 01       	movw	r24, r28
     980:	0e 94 aa 06 	call	0xd54	; 0xd54 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
     984:	6a e0       	ldi	r22, 0x0A	; 10
     986:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     98a:	ec 01       	movw	r28, r24
     98c:	61 ea       	ldi	r22, 0xA1	; 161
     98e:	71 e0       	ldi	r23, 0x01	; 1
     990:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
     994:	ce 01       	movw	r24, r28
     996:	64 e6       	ldi	r22, 0x64	; 100
     998:	70 e0       	ldi	r23, 0x00	; 0
     99a:	0e 94 2a 06 	call	0xc54	; 0xc54 <_ZN8emstreamlsEj>
     99e:	6a e0       	ldi	r22, 0x0A	; 10
     9a0:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
     9a4:	ec 01       	movw	r28, r24
     9a6:	63 ea       	ldi	r22, 0xA3	; 163
     9a8:	71 e0       	ldi	r23, 0x01	; 1
     9aa:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
     9ae:	ce 01       	movw	r24, r28
     9b0:	66 e0       	ldi	r22, 0x06	; 6
     9b2:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
}
     9b6:	df 91       	pop	r29
     9b8:	cf 91       	pop	r28
     9ba:	1f 91       	pop	r17
     9bc:	0f 91       	pop	r16
     9be:	08 95       	ret

000009c0 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
     9c0:	0f 93       	push	r16
     9c2:	cf 93       	push	r28
     9c4:	df 93       	push	r29
     9c6:	0f 92       	push	r0
     9c8:	cd b7       	in	r28, 0x3d	; 61
     9ca:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
     9cc:	fc 01       	movw	r30, r24
     9ce:	80 85       	ldd	r24, Z+8	; 0x08
     9d0:	91 85       	ldd	r25, Z+9	; 0x09
     9d2:	be 01       	movw	r22, r28
     9d4:	6f 5f       	subi	r22, 0xFF	; 255
     9d6:	7f 4f       	sbci	r23, 0xFF	; 255
     9d8:	2f ef       	ldi	r18, 0xFF	; 255
     9da:	3f ef       	ldi	r19, 0xFF	; 255
     9dc:	a9 01       	movw	r20, r18
     9de:	00 e0       	ldi	r16, 0x00	; 0
     9e0:	0e 94 b6 0c 	call	0x196c	; 0x196c <xQueueGenericReceive>
     9e4:	81 30       	cpi	r24, 0x01	; 1
     9e6:	49 f4       	brne	.+18     	; 0x9fa <_ZN14frt_text_queue7getcharEv+0x3a>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
     9e8:	89 81       	ldd	r24, Y+1	; 0x01
     9ea:	99 27       	eor	r25, r25
     9ec:	87 fd       	sbrc	r24, 7
     9ee:	90 95       	com	r25
}
     9f0:	0f 90       	pop	r0
     9f2:	df 91       	pop	r29
     9f4:	cf 91       	pop	r28
     9f6:	0f 91       	pop	r16
     9f8:	08 95       	ret
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
     9fa:	8f ef       	ldi	r24, 0xFF	; 255
     9fc:	9f ef       	ldi	r25, 0xFF	; 255
     9fe:	f8 cf       	rjmp	.-16     	; 0x9f0 <_ZN14frt_text_queue7getcharEv+0x30>

00000a00 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
     a00:	fc 01       	movw	r30, r24
     a02:	80 85       	ldd	r24, Z+8	; 0x08
     a04:	91 85       	ldd	r25, Z+9	; 0x09
     a06:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <uxQueueMessagesWaiting>
 *  function uxQueueMessagesWaiting(); if there's anything in the queue, the return 
 *  value from that function will be greater than zero. 
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
     a0a:	91 e0       	ldi	r25, 0x01	; 1
     a0c:	88 23       	and	r24, r24
     a0e:	09 f4       	brne	.+2      	; 0xa12 <_ZN14frt_text_queue14check_for_charEv+0x12>
     a10:	90 e0       	ldi	r25, 0x00	; 0
	if (uxQueueMessagesWaiting (the_queue) == 0)
	{
		return (false);
	}
	return (true);
}
     a12:	89 2f       	mov	r24, r25
     a14:	08 95       	ret

00000a16 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
     a16:	0f 93       	push	r16
     a18:	cf 93       	push	r28
     a1a:	df 93       	push	r29
     a1c:	0f 92       	push	r0
     a1e:	cd b7       	in	r28, 0x3d	; 61
     a20:	de b7       	in	r29, 0x3e	; 62
     a22:	fc 01       	movw	r30, r24
     a24:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
     a26:	22 85       	ldd	r18, Z+10	; 0x0a
     a28:	33 85       	ldd	r19, Z+11	; 0x0b
     a2a:	44 85       	ldd	r20, Z+12	; 0x0c
     a2c:	55 85       	ldd	r21, Z+13	; 0x0d
     a2e:	80 85       	ldd	r24, Z+8	; 0x08
     a30:	91 85       	ldd	r25, Z+9	; 0x09
     a32:	be 01       	movw	r22, r28
     a34:	6f 5f       	subi	r22, 0xFF	; 255
     a36:	7f 4f       	sbci	r23, 0xFF	; 255
     a38:	00 e0       	ldi	r16, 0x00	; 0
     a3a:	0e 94 ad 0b 	call	0x175a	; 0x175a <xQueueGenericSend>
 *  become empty, give up in frustration and return false. 
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
     a3e:	91 e0       	ldi	r25, 0x01	; 1
     a40:	88 23       	and	r24, r24
     a42:	09 f4       	brne	.+2      	; 0xa46 <_ZN14frt_text_queue7putcharEc+0x30>
     a44:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
     a46:	89 2f       	mov	r24, r25
     a48:	0f 90       	pop	r0
     a4a:	df 91       	pop	r29
     a4c:	cf 91       	pop	r28
     a4e:	0f 91       	pop	r16
     a50:	08 95       	ret

00000a52 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
     a52:	8f 92       	push	r8
     a54:	9f 92       	push	r9
     a56:	af 92       	push	r10
     a58:	bf 92       	push	r11
     a5a:	cf 92       	push	r12
     a5c:	df 92       	push	r13
     a5e:	ef 92       	push	r14
     a60:	ff 92       	push	r15
     a62:	0f 93       	push	r16
     a64:	1f 93       	push	r17
     a66:	cf 93       	push	r28
     a68:	df 93       	push	r29
     a6a:	0f 92       	push	r0
     a6c:	cd b7       	in	r28, 0x3d	; 61
     a6e:	de b7       	in	r29, 0x3e	; 62
     a70:	4c 01       	movw	r8, r24
     a72:	5a 01       	movw	r10, r20
     a74:	68 01       	movw	r12, r16
     a76:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
     a78:	69 83       	std	Y+1, r22	; 0x01
     a7a:	0e 94 8a 05 	call	0xb14	; 0xb14 <_ZN8emstreamC1Ev>
     a7e:	83 e6       	ldi	r24, 0x63	; 99
     a80:	92 e0       	ldi	r25, 0x02	; 2
     a82:	f4 01       	movw	r30, r8
     a84:	91 83       	std	Z+1, r25	; 0x01
     a86:	80 83       	st	Z, r24
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
     a88:	b7 86       	std	Z+15, r11	; 0x0f
     a8a:	a6 86       	std	Z+14, r10	; 0x0e

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
     a8c:	69 81       	ldd	r22, Y+1	; 0x01
     a8e:	86 2f       	mov	r24, r22
     a90:	61 e0       	ldi	r22, 0x01	; 1
     a92:	40 e0       	ldi	r20, 0x00	; 0
     a94:	0e 94 68 0b 	call	0x16d0	; 0x16d0 <xQueueGenericCreate>
     a98:	f4 01       	movw	r30, r8
     a9a:	91 87       	std	Z+9, r25	; 0x09
     a9c:	80 87       	std	Z+8, r24	; 0x08

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
     a9e:	c2 86       	std	Z+10, r12	; 0x0a
     aa0:	d3 86       	std	Z+11, r13	; 0x0b
     aa2:	e4 86       	std	Z+12, r14	; 0x0c
     aa4:	f5 86       	std	Z+13, r15	; 0x0d
}
     aa6:	0f 90       	pop	r0
     aa8:	df 91       	pop	r29
     aaa:	cf 91       	pop	r28
     aac:	1f 91       	pop	r17
     aae:	0f 91       	pop	r16
     ab0:	ff 90       	pop	r15
     ab2:	ef 90       	pop	r14
     ab4:	df 90       	pop	r13
     ab6:	cf 90       	pop	r12
     ab8:	bf 90       	pop	r11
     aba:	af 90       	pop	r10
     abc:	9f 90       	pop	r9
     abe:	8f 90       	pop	r8
     ac0:	08 95       	ret

00000ac2 <_Znwj>:
	*  @return A pointer to the memory area which has just been allocated
	*/

	void* operator new (size_t size)
	{
		return pvPortMalloc (size);
     ac2:	0e 94 a1 08 	call	0x1142	; 0x1142 <pvPortMalloc>
	}
     ac6:	08 95       	ret

00000ac8 <_ZdlPv>:
	 *  @param ptr A pointer to the memory area whose contents are to be deleted
	 */

	void operator delete (void *ptr)
	{
		if (ptr) vPortFree (ptr);
     ac8:	00 97       	sbiw	r24, 0x00	; 0
     aca:	11 f0       	breq	.+4      	; 0xad0 <_ZdlPv+0x8>
     acc:	0e 94 cd 08 	call	0x119a	; 0x119a <vPortFree>
     ad0:	08 95       	ret

00000ad2 <_Znaj>:
	 *  @return A pointer to the memory area which has just been allocated
	 */

	void* operator new[] (size_t size)
	{
		return pvPortMalloc (size);
     ad2:	0e 94 a1 08 	call	0x1142	; 0x1142 <pvPortMalloc>
	}
     ad6:	08 95       	ret

00000ad8 <_ZdaPv>:
	 *  @param ptr A pointer to the memory area whose contents are to be deleted
	 */

	void operator delete[] (void *ptr)
	{
		if (ptr) vPortFree (ptr);
     ad8:	00 97       	sbiw	r24, 0x00	; 0
     ada:	11 f0       	breq	.+4      	; 0xae0 <_ZdaPv+0x8>
     adc:	0e 94 cd 08 	call	0x119a	; 0x119a <vPortFree>
     ae0:	08 95       	ret

00000ae2 <__cxa_guard_acquire>:
 */
extern "C"
{
int __cxa_guard_acquire (__guard *g)
    {
    return !*(char *)(g);
     ae2:	21 e0       	ldi	r18, 0x01	; 1
     ae4:	30 e0       	ldi	r19, 0x00	; 0
     ae6:	fc 01       	movw	r30, r24
     ae8:	80 81       	ld	r24, Z
     aea:	88 23       	and	r24, r24
     aec:	11 f0       	breq	.+4      	; 0xaf2 <__cxa_guard_acquire+0x10>
     aee:	20 e0       	ldi	r18, 0x00	; 0
     af0:	30 e0       	ldi	r19, 0x00	; 0
    }
     af2:	c9 01       	movw	r24, r18
     af4:	08 95       	ret

00000af6 <__cxa_guard_release>:
 */
extern "C"
{
void __cxa_guard_release (__guard *g)
    {
    *(char *)g = 1;
     af6:	21 e0       	ldi	r18, 0x01	; 1
     af8:	fc 01       	movw	r30, r24
     afa:	20 83       	st	Z, r18
    }
     afc:	08 95       	ret

00000afe <__cxa_guard_abort>:
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
		(void)g;							// Shuts up a dumb compiler warning
    }
     afe:	08 95       	ret

00000b00 <__cxa_pure_virtual>:

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    }
     b00:	08 95       	ret

00000b02 <_ZN8emstream13ready_to_sendEv>:
 */

bool emstream::ready_to_send (void)
{
	return (true);                          // By default the port's always ready
}
     b02:	81 e0       	ldi	r24, 0x01	; 1
     b04:	08 95       	ret

00000b06 <_ZN8emstream7getcharEv>:
 */

int16_t emstream::getchar (void)
{
	return ('\0');                          // Nothing to return, really
}
     b06:	80 e0       	ldi	r24, 0x00	; 0
     b08:	90 e0       	ldi	r25, 0x00	; 0
     b0a:	08 95       	ret

00000b0c <_ZN8emstream14check_for_charEv>:
 */

bool emstream::check_for_char (void)
{
	return (false);
}
     b0c:	80 e0       	ldi	r24, 0x00	; 0
     b0e:	08 95       	ret

00000b10 <_ZN8emstream12transmit_nowEv>:
 *  need to respond to calls for immediate transmission. 
 */

void emstream::transmit_now (void)
{
}
     b10:	08 95       	ret

00000b12 <_ZN8emstream12clear_screenEv>:
 *  classes which send things to displays should respond by clearing themselves.
 */

void emstream::clear_screen (void)
{
}
     b12:	08 95       	ret

00000b14 <_ZN8emstreamC1Ev>:
//-------------------------------------------------------------------------------------
/** This constructor sets up the base serial port object. It sets the default base for
 *  the conversion of numbers to text and the default format for converting chars. 
 */

emstream::emstream (void)
     b14:	fc 01       	movw	r30, r24
     b16:	83 e7       	ldi	r24, 0x73	; 115
     b18:	92 e0       	ldi	r25, 0x02	; 2
     b1a:	91 83       	std	Z+1, r25	; 0x01
     b1c:	80 83       	st	Z, r24
{
	base = 10;                              // Numbers are shown as decimal by default
     b1e:	8a e0       	ldi	r24, 0x0A	; 10
     b20:	82 83       	std	Z+2, r24	; 0x02
	print_ascii = false;                    // Print 8-bit chars as numbers by default
     b22:	13 82       	std	Z+3, r1	; 0x03
	precision = 3;                          // Print 3 digits after a decimal point
     b24:	83 e0       	ldi	r24, 0x03	; 3
     b26:	85 83       	std	Z+5, r24	; 0x05
	pgm_string = false;                     // Print strings from SRAM by default
     b28:	14 82       	std	Z+4, r1	; 0x04
	p_hex_receiver = NULL;                  // No hex packet receiver has been set up
     b2a:	17 82       	std	Z+7, r1	; 0x07
     b2c:	16 82       	std	Z+6, r1	; 0x06
}
     b2e:	08 95       	ret

00000b30 <_ZN8emstream4putsEPKc>:
 *  reached.
 *  @param p_string A pointer to the string which is to be printed
 */

void emstream::puts (const char* p_string)
{
     b30:	0f 93       	push	r16
     b32:	1f 93       	push	r17
     b34:	cf 93       	push	r28
     b36:	df 93       	push	r29
     b38:	8c 01       	movw	r16, r24
     b3a:	eb 01       	movw	r28, r22
	char ch;                                // Temporary storage for a character

	// If the program-string variable is set, this string is to be found in program
	// memory rather than data memory
	if (pgm_string)
     b3c:	dc 01       	movw	r26, r24
     b3e:	14 96       	adiw	r26, 0x04	; 4
     b40:	8c 91       	ld	r24, X
     b42:	14 97       	sbiw	r26, 0x04	; 4
     b44:	88 23       	and	r24, r24
     b46:	a1 f4       	brne	.+40     	; 0xb70 <_ZN8emstream4putsEPKc+0x40>
	}
	// If the program-string variable is not set, the string is in RAM and printed
	// in the normal way
	else
	{
		while (*p_string)
     b48:	68 81       	ld	r22, Y
     b4a:	66 23       	and	r22, r22
     b4c:	61 f0       	breq	.+24     	; 0xb66 <_ZN8emstream4putsEPKc+0x36>
 *  character until and end of string character (the null character, \c '\0') is 
 *  reached.
 *  @param p_string A pointer to the string which is to be printed
 */

void emstream::puts (const char* p_string)
     b4e:	21 96       	adiw	r28, 0x01	; 1
	// in the normal way
	else
	{
		while (*p_string)
		{
			putchar (*p_string++);
     b50:	d8 01       	movw	r26, r16
     b52:	ed 91       	ld	r30, X+
     b54:	fc 91       	ld	r31, X
     b56:	02 80       	ldd	r0, Z+2	; 0x02
     b58:	f3 81       	ldd	r31, Z+3	; 0x03
     b5a:	e0 2d       	mov	r30, r0
     b5c:	c8 01       	movw	r24, r16
     b5e:	09 95       	icall
	}
	// If the program-string variable is not set, the string is in RAM and printed
	// in the normal way
	else
	{
		while (*p_string)
     b60:	69 91       	ld	r22, Y+
     b62:	66 23       	and	r22, r22
     b64:	a9 f7       	brne	.-22     	; 0xb50 <_ZN8emstream4putsEPKc+0x20>
		{
			putchar (*p_string++);
		}
	}
}
     b66:	df 91       	pop	r29
     b68:	cf 91       	pop	r28
     b6a:	1f 91       	pop	r17
     b6c:	0f 91       	pop	r16
     b6e:	08 95       	ret

	// If the program-string variable is set, this string is to be found in program
	// memory rather than data memory
	if (pgm_string)
	{
		pgm_string = false;
     b70:	f8 01       	movw	r30, r16
     b72:	14 82       	std	Z+4, r1	; 0x04
		while ((ch = pgm_read_byte_near (p_string++)))
     b74:	fb 01       	movw	r30, r22
     b76:	64 91       	lpm	r22, Z
     b78:	66 23       	and	r22, r22
     b7a:	a9 f3       	breq	.-22     	; 0xb66 <_ZN8emstream4putsEPKc+0x36>
     b7c:	21 96       	adiw	r28, 0x01	; 1
		{
			putchar (ch);
     b7e:	f8 01       	movw	r30, r16
     b80:	a0 81       	ld	r26, Z
     b82:	b1 81       	ldd	r27, Z+1	; 0x01
     b84:	12 96       	adiw	r26, 0x02	; 2
     b86:	ed 91       	ld	r30, X+
     b88:	fc 91       	ld	r31, X
     b8a:	13 97       	sbiw	r26, 0x03	; 3
     b8c:	c8 01       	movw	r24, r16
     b8e:	09 95       	icall
	// If the program-string variable is set, this string is to be found in program
	// memory rather than data memory
	if (pgm_string)
	{
		pgm_string = false;
		while ((ch = pgm_read_byte_near (p_string++)))
     b90:	fe 01       	movw	r30, r28
     b92:	21 96       	adiw	r28, 0x01	; 1
     b94:	64 91       	lpm	r22, Z
     b96:	66 23       	and	r22, r22
     b98:	91 f7       	brne	.-28     	; 0xb7e <_ZN8emstream4putsEPKc+0x4e>
		while (*p_string)
		{
			putchar (*p_string++);
		}
	}
}
     b9a:	df 91       	pop	r29
     b9c:	cf 91       	pop	r28
     b9e:	1f 91       	pop	r17
     ba0:	0f 91       	pop	r16
     ba2:	08 95       	ret

00000ba4 <_Z12setprecisionh>:
{
	if (digits > 7)
	{
		digits = 7;
	}
	bts_glob_prec = digits;
     ba4:	88 30       	cpi	r24, 0x08	; 8
     ba6:	08 f0       	brcs	.+2      	; 0xbaa <_Z12setprecisionh+0x6>
     ba8:	87 e0       	ldi	r24, 0x07	; 7
     baa:	80 93 7f 02 	sts	0x027F, r24

	return (manip_set_precision);
}
     bae:	89 e0       	ldi	r24, 0x09	; 9
     bb0:	08 95       	ret

00000bb2 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
     bb2:	cf 93       	push	r28
     bb4:	df 93       	push	r29
     bb6:	ec 01       	movw	r28, r24
	switch (new_manip)
     bb8:	64 30       	cpi	r22, 0x04	; 4
     bba:	09 f4       	brne	.+2      	; 0xbbe <_ZN8emstreamlsE15ser_manipulator+0xc>
     bbc:	48 c0       	rjmp	.+144    	; 0xc4e <_ZN8emstreamlsE15ser_manipulator+0x9c>
     bbe:	65 30       	cpi	r22, 0x05	; 5
     bc0:	d8 f0       	brcs	.+54     	; 0xbf8 <_ZN8emstreamlsE15ser_manipulator+0x46>
     bc2:	67 30       	cpi	r22, 0x07	; 7
     bc4:	81 f1       	breq	.+96     	; 0xc26 <_ZN8emstreamlsE15ser_manipulator+0x74>
     bc6:	68 30       	cpi	r22, 0x08	; 8
     bc8:	10 f5       	brcc	.+68     	; 0xc0e <_ZN8emstreamlsE15ser_manipulator+0x5c>
     bca:	65 30       	cpi	r22, 0x05	; 5
     bcc:	51 f1       	breq	.+84     	; 0xc22 <_ZN8emstreamlsE15ser_manipulator+0x70>
     bce:	66 30       	cpi	r22, 0x06	; 6
     bd0:	79 f4       	brne	.+30     	; 0xbf0 <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
			break;
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
     bd2:	e8 81       	ld	r30, Y
     bd4:	f9 81       	ldd	r31, Y+1	; 0x01
     bd6:	02 80       	ldd	r0, Z+2	; 0x02
     bd8:	f3 81       	ldd	r31, Z+3	; 0x03
     bda:	e0 2d       	mov	r30, r0
     bdc:	6d e0       	ldi	r22, 0x0D	; 13
     bde:	09 95       	icall
     be0:	e8 81       	ld	r30, Y
     be2:	f9 81       	ldd	r31, Y+1	; 0x01
     be4:	02 80       	ldd	r0, Z+2	; 0x02
     be6:	f3 81       	ldd	r31, Z+3	; 0x03
     be8:	e0 2d       	mov	r30, r0
     bea:	ce 01       	movw	r24, r28
     bec:	6a e0       	ldi	r22, 0x0A	; 10
     bee:	09 95       	icall
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
     bf0:	ce 01       	movw	r24, r28
     bf2:	df 91       	pop	r29
     bf4:	cf 91       	pop	r28
     bf6:	08 95       	ret
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
	switch (new_manip)
     bf8:	61 30       	cpi	r22, 0x01	; 1
     bfa:	31 f1       	breq	.+76     	; 0xc48 <_ZN8emstreamlsE15ser_manipulator+0x96>
     bfc:	61 30       	cpi	r22, 0x01	; 1
     bfe:	70 f0       	brcs	.+28     	; 0xc1c <_ZN8emstreamlsE15ser_manipulator+0x6a>
     c00:	62 30       	cpi	r22, 0x02	; 2
     c02:	c1 f0       	breq	.+48     	; 0xc34 <_ZN8emstreamlsE15ser_manipulator+0x82>
     c04:	63 30       	cpi	r22, 0x03	; 3
     c06:	a1 f7       	brne	.-24     	; 0xbf0 <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (dec):                         // Print integers in decimal
			base = 10;
			break;
		case (hex):                         // Print integers in hexadecimal
			base = 16;
     c08:	80 e1       	ldi	r24, 0x10	; 16
     c0a:	8a 83       	std	Y+2, r24	; 0x02
			break;
     c0c:	f1 cf       	rjmp	.-30     	; 0xbf0 <_ZN8emstreamlsE15ser_manipulator+0x3e>
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
	switch (new_manip)
     c0e:	68 30       	cpi	r22, 0x08	; 8
     c10:	a1 f0       	breq	.+40     	; 0xc3a <_ZN8emstreamlsE15ser_manipulator+0x88>
     c12:	6a 30       	cpi	r22, 0x0A	; 10
     c14:	69 f7       	brne	.-38     	; 0xbf0 <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
			break;
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
     c16:	81 e0       	ldi	r24, 0x01	; 1
     c18:	8c 83       	std	Y+4, r24	; 0x04
			break;
     c1a:	ea cf       	rjmp	.-44     	; 0xbf0 <_ZN8emstreamlsE15ser_manipulator+0x3e>
emstream& emstream::operator<< (ser_manipulator new_manip)
{
	switch (new_manip)
	{
		case (bin):                         // Print integers in binary
			base = 2;
     c1c:	82 e0       	ldi	r24, 0x02	; 2
     c1e:	8a 83       	std	Y+2, r24	; 0x02
			break;
     c20:	e7 cf       	rjmp	.-50     	; 0xbf0 <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
			break;
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
     c22:	1b 82       	std	Y+3, r1	; 0x03
			break;
     c24:	e5 cf       	rjmp	.-54     	; 0xbf0 <_ZN8emstreamlsE15ser_manipulator+0x3e>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
			break;
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
     c26:	e8 81       	ld	r30, Y
     c28:	f9 81       	ldd	r31, Y+1	; 0x01
     c2a:	02 84       	ldd	r0, Z+10	; 0x0a
     c2c:	f3 85       	ldd	r31, Z+11	; 0x0b
     c2e:	e0 2d       	mov	r30, r0
     c30:	09 95       	icall
			break;
     c32:	de cf       	rjmp	.-68     	; 0xbf0 <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (oct):                         // Print integers in octal
			base = 8;
			break;
		case (dec):                         // Print integers in decimal
			base = 10;
     c34:	8a e0       	ldi	r24, 0x0A	; 10
     c36:	8a 83       	std	Y+2, r24	; 0x02
			break;
     c38:	db cf       	rjmp	.-74     	; 0xbf0 <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
			break;
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
     c3a:	e8 81       	ld	r30, Y
     c3c:	f9 81       	ldd	r31, Y+1	; 0x01
     c3e:	00 84       	ldd	r0, Z+8	; 0x08
     c40:	f1 85       	ldd	r31, Z+9	; 0x09
     c42:	e0 2d       	mov	r30, r0
     c44:	09 95       	icall
			break;
     c46:	d4 cf       	rjmp	.-88     	; 0xbf0 <_ZN8emstreamlsE15ser_manipulator+0x3e>
	{
		case (bin):                         // Print integers in binary
			base = 2;
			break;
		case (oct):                         // Print integers in octal
			base = 8;
     c48:	88 e0       	ldi	r24, 0x08	; 8
     c4a:	8a 83       	std	Y+2, r24	; 0x02
			break;
     c4c:	d1 cf       	rjmp	.-94     	; 0xbf0 <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (hex):                         // Print integers in hexadecimal
			base = 16;
			break;
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
     c4e:	81 e0       	ldi	r24, 0x01	; 1
     c50:	8b 83       	std	Y+3, r24	; 0x03
			break;
     c52:	ce cf       	rjmp	.-100    	; 0xbf0 <_ZN8emstreamlsE15ser_manipulator+0x3e>

00000c54 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
     c54:	ff 92       	push	r15
     c56:	0f 93       	push	r16
     c58:	1f 93       	push	r17
     c5a:	cf 93       	push	r28
     c5c:	df 93       	push	r29
     c5e:	cd b7       	in	r28, 0x3d	; 61
     c60:	de b7       	in	r29, 0x3e	; 62
     c62:	61 97       	sbiw	r28, 0x11	; 17
     c64:	0f b6       	in	r0, 0x3f	; 63
     c66:	f8 94       	cli
     c68:	de bf       	out	0x3e, r29	; 62
     c6a:	0f be       	out	0x3f, r0	; 63
     c6c:	cd bf       	out	0x3d, r28	; 61
     c6e:	8c 01       	movw	r16, r24
     c70:	f6 2e       	mov	r15, r22
	if (base == 16 || base == 8 || base == 2)
     c72:	fc 01       	movw	r30, r24
     c74:	42 81       	ldd	r20, Z+2	; 0x02
     c76:	40 31       	cpi	r20, 0x10	; 16
     c78:	99 f0       	breq	.+38     	; 0xca0 <_ZN8emstreamlsEj+0x4c>
     c7a:	48 30       	cpi	r20, 0x08	; 8
     c7c:	89 f0       	breq	.+34     	; 0xca0 <_ZN8emstreamlsEj+0x4c>
     c7e:	42 30       	cpi	r20, 0x02	; 2
     c80:	79 f0       	breq	.+30     	; 0xca0 <_ZN8emstreamlsEj+0x4c>
		*this << parts.bits[1] << parts.bits[0];
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
     c82:	86 2f       	mov	r24, r22
     c84:	97 2f       	mov	r25, r23
     c86:	be 01       	movw	r22, r28
     c88:	6f 5f       	subi	r22, 0xFF	; 255
     c8a:	7f 4f       	sbci	r23, 0xFF	; 255
     c8c:	50 e0       	ldi	r21, 0x00	; 0
     c8e:	0e 94 bb 16 	call	0x2d76	; 0x2d76 <utoa>
		puts (out_str);
     c92:	c8 01       	movw	r24, r16
     c94:	be 01       	movw	r22, r28
     c96:	6f 5f       	subi	r22, 0xFF	; 255
     c98:	7f 4f       	sbci	r23, 0xFF	; 255
     c9a:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
     c9e:	07 c0       	rjmp	.+14     	; 0xcae <_ZN8emstreamlsEj+0x5a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
     ca0:	c8 01       	movw	r24, r16
     ca2:	67 2f       	mov	r22, r23
     ca4:	0e 94 aa 06 	call	0xd54	; 0xd54 <_ZN8emstreamlsEh>
     ca8:	6f 2d       	mov	r22, r15
     caa:	0e 94 aa 06 	call	0xd54	; 0xd54 <_ZN8emstreamlsEh>
		utoa (num, out_str, base);
		puts (out_str);
	}

	return (*this);
}
     cae:	c8 01       	movw	r24, r16
     cb0:	61 96       	adiw	r28, 0x11	; 17
     cb2:	0f b6       	in	r0, 0x3f	; 63
     cb4:	f8 94       	cli
     cb6:	de bf       	out	0x3e, r29	; 62
     cb8:	0f be       	out	0x3f, r0	; 63
     cba:	cd bf       	out	0x3d, r28	; 61
     cbc:	df 91       	pop	r29
     cbe:	cf 91       	pop	r28
     cc0:	1f 91       	pop	r17
     cc2:	0f 91       	pop	r16
     cc4:	ff 90       	pop	r15
     cc6:	08 95       	ret

00000cc8 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
     cc8:	ff 92       	push	r15
     cca:	0f 93       	push	r16
     ccc:	1f 93       	push	r17
     cce:	cf 93       	push	r28
     cd0:	df 93       	push	r29
     cd2:	cd b7       	in	r28, 0x3d	; 61
     cd4:	de b7       	in	r29, 0x3e	; 62
     cd6:	a3 97       	sbiw	r28, 0x23	; 35
     cd8:	0f b6       	in	r0, 0x3f	; 63
     cda:	f8 94       	cli
     cdc:	de bf       	out	0x3e, r29	; 62
     cde:	0f be       	out	0x3f, r0	; 63
     ce0:	cd bf       	out	0x3d, r28	; 61
     ce2:	8c 01       	movw	r16, r24
     ce4:	f6 2e       	mov	r15, r22
     ce6:	37 2f       	mov	r19, r23
	if (base == 16 || base == 8 || base == 2)
     ce8:	fc 01       	movw	r30, r24
     cea:	22 81       	ldd	r18, Z+2	; 0x02
     cec:	20 31       	cpi	r18, 0x10	; 16
     cee:	a1 f0       	breq	.+40     	; 0xd18 <_ZN8emstreamlsEm+0x50>
     cf0:	28 30       	cpi	r18, 0x08	; 8
     cf2:	91 f0       	breq	.+36     	; 0xd18 <_ZN8emstreamlsEm+0x50>
     cf4:	22 30       	cpi	r18, 0x02	; 2
     cf6:	81 f0       	breq	.+32     	; 0xd18 <_ZN8emstreamlsEm+0x50>
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
     cf8:	ba 01       	movw	r22, r20
     cfa:	8f 2d       	mov	r24, r15
     cfc:	93 2f       	mov	r25, r19
     cfe:	ae 01       	movw	r20, r28
     d00:	4f 5f       	subi	r20, 0xFF	; 255
     d02:	5f 4f       	sbci	r21, 0xFF	; 255
     d04:	30 e0       	ldi	r19, 0x00	; 0
     d06:	0e 94 96 16 	call	0x2d2c	; 0x2d2c <ultoa>
		puts (out_str);
     d0a:	c8 01       	movw	r24, r16
     d0c:	be 01       	movw	r22, r28
     d0e:	6f 5f       	subi	r22, 0xFF	; 255
     d10:	7f 4f       	sbci	r23, 0xFF	; 255
     d12:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
     d16:	11 c0       	rjmp	.+34     	; 0xd3a <_ZN8emstreamlsEm+0x72>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
     d18:	c8 01       	movw	r24, r16
     d1a:	63 2f       	mov	r22, r19
     d1c:	4b a3       	lds	r20, 0x5b
     d1e:	5a a3       	lds	r21, 0x5a
     d20:	0e 94 aa 06 	call	0xd54	; 0xd54 <_ZN8emstreamlsEh>
     d24:	6f 2d       	mov	r22, r15
     d26:	0e 94 aa 06 	call	0xd54	; 0xd54 <_ZN8emstreamlsEh>
     d2a:	5a a1       	lds	r21, 0x4a
     d2c:	65 2f       	mov	r22, r21
     d2e:	0e 94 aa 06 	call	0xd54	; 0xd54 <_ZN8emstreamlsEh>
     d32:	4b a1       	lds	r20, 0x4b
     d34:	64 2f       	mov	r22, r20
     d36:	0e 94 aa 06 	call	0xd54	; 0xd54 <_ZN8emstreamlsEh>
		ultoa ((long)num, out_str, base);
		puts (out_str);
	}

	return (*this);
}
     d3a:	c8 01       	movw	r24, r16
     d3c:	a3 96       	adiw	r28, 0x23	; 35
     d3e:	0f b6       	in	r0, 0x3f	; 63
     d40:	f8 94       	cli
     d42:	de bf       	out	0x3e, r29	; 62
     d44:	0f be       	out	0x3f, r0	; 63
     d46:	cd bf       	out	0x3d, r28	; 61
     d48:	df 91       	pop	r29
     d4a:	cf 91       	pop	r28
     d4c:	1f 91       	pop	r17
     d4e:	0f 91       	pop	r16
     d50:	ff 90       	pop	r15
     d52:	08 95       	ret

00000d54 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
     d54:	cf 92       	push	r12
     d56:	df 92       	push	r13
     d58:	ef 92       	push	r14
     d5a:	ff 92       	push	r15
     d5c:	0f 93       	push	r16
     d5e:	1f 93       	push	r17
     d60:	cf 93       	push	r28
     d62:	df 93       	push	r29
     d64:	cd b7       	in	r28, 0x3d	; 61
     d66:	de b7       	in	r29, 0x3e	; 62
     d68:	29 97       	sbiw	r28, 0x09	; 9
     d6a:	0f b6       	in	r0, 0x3f	; 63
     d6c:	f8 94       	cli
     d6e:	de bf       	out	0x3e, r29	; 62
     d70:	0f be       	out	0x3f, r0	; 63
     d72:	cd bf       	out	0x3d, r28	; 61
     d74:	6c 01       	movw	r12, r24
     d76:	06 2f       	mov	r16, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
     d78:	dc 01       	movw	r26, r24
     d7a:	13 96       	adiw	r26, 0x03	; 3
     d7c:	8c 91       	ld	r24, X
     d7e:	13 97       	sbiw	r26, 0x03	; 3
     d80:	88 23       	and	r24, r24
     d82:	09 f0       	breq	.+2      	; 0xd86 <_ZN8emstreamlsEh+0x32>
     d84:	5e c0       	rjmp	.+188    	; 0xe42 <_ZN8emstreamlsEh+0xee>
	{
		putchar (num);
	}
	else if (base == 2)
     d86:	f6 01       	movw	r30, r12
     d88:	42 81       	ldd	r20, Z+2	; 0x02
     d8a:	42 30       	cpi	r20, 0x02	; 2
     d8c:	e1 f1       	breq	.+120    	; 0xe06 <_ZN8emstreamlsEh+0xb2>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
     d8e:	40 31       	cpi	r20, 0x10	; 16
     d90:	f1 f0       	breq	.+60     	; 0xdce <_ZN8emstreamlsEh+0x7a>
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
     d92:	86 2f       	mov	r24, r22
     d94:	90 e0       	ldi	r25, 0x00	; 0
     d96:	be 01       	movw	r22, r28
     d98:	6f 5f       	subi	r22, 0xFF	; 255
     d9a:	7f 4f       	sbci	r23, 0xFF	; 255
     d9c:	50 e0       	ldi	r21, 0x00	; 0
     d9e:	0e 94 bb 16 	call	0x2d76	; 0x2d76 <utoa>
		puts (out_str);
     da2:	c6 01       	movw	r24, r12
     da4:	be 01       	movw	r22, r28
     da6:	6f 5f       	subi	r22, 0xFF	; 255
     da8:	7f 4f       	sbci	r23, 0xFF	; 255
     daa:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
     dae:	c6 01       	movw	r24, r12
     db0:	29 96       	adiw	r28, 0x09	; 9
     db2:	0f b6       	in	r0, 0x3f	; 63
     db4:	f8 94       	cli
     db6:	de bf       	out	0x3e, r29	; 62
     db8:	0f be       	out	0x3f, r0	; 63
     dba:	cd bf       	out	0x3d, r28	; 61
     dbc:	df 91       	pop	r29
     dbe:	cf 91       	pop	r28
     dc0:	1f 91       	pop	r17
     dc2:	0f 91       	pop	r16
     dc4:	ff 90       	pop	r15
     dc6:	ef 90       	pop	r14
     dc8:	df 90       	pop	r13
     dca:	cf 90       	pop	r12
     dcc:	08 95       	ret
			else             putchar ('0');
		}
	}
	else if (base == 16)
	{
		temp_char = (num >> 4) & 0x0F;
     dce:	62 95       	swap	r22
     dd0:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
     dd2:	01 90       	ld	r0, Z+
     dd4:	f0 81       	ld	r31, Z
     dd6:	e0 2d       	mov	r30, r0
     dd8:	02 80       	ldd	r0, Z+2	; 0x02
     dda:	f3 81       	ldd	r31, Z+3	; 0x03
     ddc:	e0 2d       	mov	r30, r0
     dde:	6a 30       	cpi	r22, 0x0A	; 10
     de0:	c0 f5       	brcc	.+112    	; 0xe52 <_ZN8emstreamlsEh+0xfe>
     de2:	60 5d       	subi	r22, 0xD0	; 208
     de4:	c6 01       	movw	r24, r12
     de6:	09 95       	icall
		temp_char = num & 0x0F;
     de8:	0f 70       	andi	r16, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
     dea:	d6 01       	movw	r26, r12
     dec:	ed 91       	ld	r30, X+
     dee:	fc 91       	ld	r31, X
     df0:	11 97       	sbiw	r26, 0x01	; 1
     df2:	02 80       	ldd	r0, Z+2	; 0x02
     df4:	f3 81       	ldd	r31, Z+3	; 0x03
     df6:	e0 2d       	mov	r30, r0
     df8:	60 2f       	mov	r22, r16
     dfa:	0a 30       	cpi	r16, 0x0A	; 10
     dfc:	60 f1       	brcs	.+88     	; 0xe56 <_ZN8emstreamlsEh+0x102>
     dfe:	69 5c       	subi	r22, 0xC9	; 201
     e00:	c6 01       	movw	r24, r12
     e02:	09 95       	icall
     e04:	d4 cf       	rjmp	.-88     	; 0xdae <_ZN8emstreamlsEh+0x5a>

	if (print_ascii)
	{
		putchar (num);
	}
	else if (base == 2)
     e06:	88 e0       	ldi	r24, 0x08	; 8
     e08:	e8 2e       	mov	r14, r24
     e0a:	f1 2c       	mov	r15, r1
     e0c:	10 e8       	ldi	r17, 0x80	; 128
     e0e:	0a c0       	rjmp	.+20     	; 0xe24 <_ZN8emstreamlsEh+0xd0>
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
     e10:	c6 01       	movw	r24, r12
     e12:	61 e3       	ldi	r22, 0x31	; 49
     e14:	09 95       	icall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
     e16:	16 95       	lsr	r17
     e18:	08 94       	sec
     e1a:	e1 08       	sbc	r14, r1
     e1c:	f1 08       	sbc	r15, r1
     e1e:	e1 14       	cp	r14, r1
     e20:	f1 04       	cpc	r15, r1
     e22:	29 f2       	breq	.-118    	; 0xdae <_ZN8emstreamlsEh+0x5a>
		{
			if (num & bmask) putchar ('1');
     e24:	81 2f       	mov	r24, r17
     e26:	80 23       	and	r24, r16
     e28:	d6 01       	movw	r26, r12
     e2a:	ed 91       	ld	r30, X+
     e2c:	fc 91       	ld	r31, X
     e2e:	11 97       	sbiw	r26, 0x01	; 1
     e30:	02 80       	ldd	r0, Z+2	; 0x02
     e32:	f3 81       	ldd	r31, Z+3	; 0x03
     e34:	e0 2d       	mov	r30, r0
     e36:	88 23       	and	r24, r24
     e38:	59 f7       	brne	.-42     	; 0xe10 <_ZN8emstreamlsEh+0xbc>
			else             putchar ('0');
     e3a:	c6 01       	movw	r24, r12
     e3c:	60 e3       	ldi	r22, 0x30	; 48
     e3e:	09 95       	icall
     e40:	ea cf       	rjmp	.-44     	; 0xe16 <_ZN8emstreamlsEh+0xc2>
{
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
	{
		putchar (num);
     e42:	ed 91       	ld	r30, X+
     e44:	fc 91       	ld	r31, X
     e46:	02 80       	ldd	r0, Z+2	; 0x02
     e48:	f3 81       	ldd	r31, Z+3	; 0x03
     e4a:	e0 2d       	mov	r30, r0
     e4c:	c6 01       	movw	r24, r12
     e4e:	09 95       	icall
     e50:	ae cf       	rjmp	.-164    	; 0xdae <_ZN8emstreamlsEh+0x5a>
		}
	}
	else if (base == 16)
	{
		temp_char = (num >> 4) & 0x0F;
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
     e52:	69 5c       	subi	r22, 0xC9	; 201
     e54:	c7 cf       	rjmp	.-114    	; 0xde4 <_ZN8emstreamlsEh+0x90>
		temp_char = num & 0x0F;
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
     e56:	60 5d       	subi	r22, 0xD0	; 208
     e58:	d3 cf       	rjmp	.-90     	; 0xe00 <_ZN8emstreamlsEh+0xac>

00000e5a <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
     e5a:	fc 01       	movw	r30, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
     e5c:	a2 85       	ldd	r26, Z+10	; 0x0a
     e5e:	b3 85       	ldd	r27, Z+11	; 0x0b
     e60:	8c 91       	ld	r24, X
     e62:	36 85       	ldd	r19, Z+14	; 0x0e
     e64:	83 23       	and	r24, r19
     e66:	41 f4       	brne	.+16     	; 0xe78 <_ZN5rs2327putcharEc+0x1e>
     e68:	81 e2       	ldi	r24, 0x21	; 33
     e6a:	9e e4       	ldi	r25, 0x4E	; 78
     e6c:	02 c0       	rjmp	.+4      	; 0xe72 <_ZN5rs2327putcharEc+0x18>
     e6e:	01 97       	sbiw	r24, 0x01	; 1
	{
		if (count > UART_TX_TOUT)
     e70:	69 f0       	breq	.+26     	; 0xe8c <_ZN5rs2327putcharEc+0x32>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
     e72:	2c 91       	ld	r18, X
     e74:	23 23       	and	r18, r19
     e76:	d9 f3       	breq	.-10     	; 0xe6e <_ZN5rs2327putcharEc+0x14>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
     e78:	8c 91       	ld	r24, X
     e7a:	90 89       	ldd	r25, Z+16	; 0x10
     e7c:	89 2b       	or	r24, r25
     e7e:	8c 93       	st	X, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
     e80:	00 84       	ldd	r0, Z+8	; 0x08
     e82:	f1 85       	ldd	r31, Z+9	; 0x09
     e84:	e0 2d       	mov	r30, r0
     e86:	60 83       	st	Z, r22
	return (true);
     e88:	81 e0       	ldi	r24, 0x01	; 1
     e8a:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
     e8c:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
     e8e:	08 95       	ret

00000e90 <_ZN5rs2327getcharEv>:
{
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	#ifdef UCSR0A  // If this is a dual-port chip
		if (port_num == 0)
     e90:	fc 01       	movw	r30, r24
     e92:	81 89       	ldd	r24, Z+17	; 0x11
     e94:	88 23       	and	r24, r24
     e96:	09 f5       	brne	.+66     	; 0xeda <_ZN5rs2327getcharEv+0x4a>
     e98:	20 91 b4 02 	lds	r18, 0x02B4
     e9c:	30 91 b5 02 	lds	r19, 0x02B5
		{
			while (rcv0_read_index == rcv0_write_index);
     ea0:	80 91 b2 02 	lds	r24, 0x02B2
     ea4:	90 91 b3 02 	lds	r25, 0x02B3
     ea8:	28 17       	cp	r18, r24
     eaa:	39 07       	cpc	r19, r25
     eac:	c1 f1       	breq	.+112    	; 0xf1e <_ZN5rs2327getcharEv+0x8e>
			recv_char = rcv0_buffer[rcv0_read_index];
     eae:	e0 91 b6 02 	lds	r30, 0x02B6
     eb2:	f0 91 b7 02 	lds	r31, 0x02B7
     eb6:	e2 0f       	add	r30, r18
     eb8:	f3 1f       	adc	r31, r19
     eba:	80 81       	ld	r24, Z
			if (++rcv0_read_index >= RSINT_BUF_SIZE)
     ebc:	2f 5f       	subi	r18, 0xFF	; 255
     ebe:	3f 4f       	sbci	r19, 0xFF	; 255
     ec0:	30 93 b5 02 	sts	0x02B5, r19
     ec4:	20 93 b4 02 	sts	0x02B4, r18
     ec8:	20 32       	cpi	r18, 0x20	; 32
     eca:	31 05       	cpc	r19, r1
     ecc:	20 f0       	brcs	.+8      	; 0xed6 <_ZN5rs2327getcharEv+0x46>
				rcv0_read_index = 0;
     ece:	10 92 b5 02 	sts	0x02B5, r1
     ed2:	10 92 b4 02 	sts	0x02B4, r1
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
	#endif

	return (recv_char);
}
     ed6:	90 e0       	ldi	r25, 0x00	; 0
     ed8:	08 95       	ret
		if (port_num == 0)
		{
			while (rcv0_read_index == rcv0_write_index);
			recv_char = rcv0_buffer[rcv0_read_index];
			if (++rcv0_read_index >= RSINT_BUF_SIZE)
				rcv0_read_index = 0;
     eda:	20 91 ae 02 	lds	r18, 0x02AE
     ede:	30 91 af 02 	lds	r19, 0x02AF
		}
		else  // This is port 1 of a dual-port chip
		{
		#if defined UCSR1A
			while (rcv1_read_index == rcv1_write_index);
     ee2:	80 91 ac 02 	lds	r24, 0x02AC
     ee6:	90 91 ad 02 	lds	r25, 0x02AD
     eea:	82 17       	cp	r24, r18
     eec:	93 07       	cpc	r25, r19
     eee:	b1 f0       	breq	.+44     	; 0xf1c <_ZN5rs2327getcharEv+0x8c>
			recv_char = rcv1_buffer[rcv1_read_index];
     ef0:	e0 91 b0 02 	lds	r30, 0x02B0
     ef4:	f0 91 b1 02 	lds	r31, 0x02B1
     ef8:	e2 0f       	add	r30, r18
     efa:	f3 1f       	adc	r31, r19
     efc:	80 81       	ld	r24, Z
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
     efe:	2f 5f       	subi	r18, 0xFF	; 255
     f00:	3f 4f       	sbci	r19, 0xFF	; 255
     f02:	30 93 af 02 	sts	0x02AF, r19
     f06:	20 93 ae 02 	sts	0x02AE, r18
     f0a:	20 32       	cpi	r18, 0x20	; 32
     f0c:	31 05       	cpc	r19, r1
     f0e:	18 f3       	brcs	.-58     	; 0xed6 <_ZN5rs2327getcharEv+0x46>
				rcv1_read_index = 0;
     f10:	10 92 af 02 	sts	0x02AF, r1
     f14:	10 92 ae 02 	sts	0x02AE, r1
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
	#endif

	return (recv_char);
}
     f18:	90 e0       	ldi	r25, 0x00	; 0
     f1a:	08 95       	ret
     f1c:	ff cf       	rjmp	.-2      	; 0xf1c <_ZN5rs2327getcharEv+0x8c>
     f1e:	ff cf       	rjmp	.-2      	; 0xf1e <_ZN5rs2327getcharEv+0x8e>

00000f20 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
     f20:	dc 01       	movw	r26, r24
     f22:	ed 91       	ld	r30, X+
     f24:	fc 91       	ld	r31, X
     f26:	02 80       	ldd	r0, Z+2	; 0x02
     f28:	f3 81       	ldd	r31, Z+3	; 0x03
     f2a:	e0 2d       	mov	r30, r0
     f2c:	6c e0       	ldi	r22, 0x0C	; 12
     f2e:	09 95       	icall
}
     f30:	08 95       	ret

00000f32 <_ZN5rs23214check_for_charEv>:
 */

bool rs232::check_for_char (void)
{
	#ifdef UCSR1A							// If this is a dual-port chip
		if (port_num == 0)
     f32:	fc 01       	movw	r30, r24
     f34:	81 89       	ldd	r24, Z+17	; 0x11
     f36:	88 23       	and	r24, r24
     f38:	69 f0       	breq	.+26     	; 0xf54 <_ZN5rs23214check_for_charEv+0x22>
			return (rcv0_read_index != rcv0_write_index);
		else
			return (rcv1_read_index != rcv1_write_index);
     f3a:	81 e0       	ldi	r24, 0x01	; 1
     f3c:	40 91 ae 02 	lds	r20, 0x02AE
     f40:	50 91 af 02 	lds	r21, 0x02AF
     f44:	20 91 ac 02 	lds	r18, 0x02AC
     f48:	30 91 ad 02 	lds	r19, 0x02AD
     f4c:	42 17       	cp	r20, r18
     f4e:	53 07       	cpc	r21, r19
     f50:	79 f0       	breq	.+30     	; 0xf70 <_ZN5rs23214check_for_charEv+0x3e>
	#else									// This chip has only one serial port
		return (rcv0_read_index != rcv0_write_index);
	#endif
}
     f52:	08 95       	ret

bool rs232::check_for_char (void)
{
	#ifdef UCSR1A							// If this is a dual-port chip
		if (port_num == 0)
			return (rcv0_read_index != rcv0_write_index);
     f54:	81 e0       	ldi	r24, 0x01	; 1
     f56:	40 91 b4 02 	lds	r20, 0x02B4
     f5a:	50 91 b5 02 	lds	r21, 0x02B5
     f5e:	20 91 b2 02 	lds	r18, 0x02B2
     f62:	30 91 b3 02 	lds	r19, 0x02B3
     f66:	42 17       	cp	r20, r18
     f68:	53 07       	cpc	r21, r19
     f6a:	99 f7       	brne	.-26     	; 0xf52 <_ZN5rs23214check_for_charEv+0x20>
     f6c:	80 e0       	ldi	r24, 0x00	; 0
     f6e:	08 95       	ret
		else
			return (rcv1_read_index != rcv1_write_index);
     f70:	80 e0       	ldi	r24, 0x00	; 0
	#else									// This chip has only one serial port
		return (rcv0_read_index != rcv0_write_index);
	#endif
}
     f72:	08 95       	ret

00000f74 <_ZN5rs232C1Ejh>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

rs232::rs232 (uint16_t baud_rate, uint8_t port_number)
     f74:	ff 92       	push	r15
     f76:	0f 93       	push	r16
     f78:	1f 93       	push	r17
     f7a:	cf 93       	push	r28
     f7c:	df 93       	push	r29
     f7e:	ec 01       	movw	r28, r24
     f80:	8b 01       	movw	r16, r22
     f82:	f4 2e       	mov	r15, r20
	: emstream (), base232 (baud_rate, port_number)
     f84:	0e 94 8a 05 	call	0xb14	; 0xb14 <_ZN8emstreamC1Ev>
     f88:	ce 01       	movw	r24, r28
     f8a:	08 96       	adiw	r24, 0x08	; 8
     f8c:	b8 01       	movw	r22, r16
     f8e:	4f 2d       	mov	r20, r15
     f90:	0e 94 8e 14 	call	0x291c	; 0x291c <_ZN7base232C1Ejh>
     f94:	84 e8       	ldi	r24, 0x84	; 132
     f96:	92 e0       	ldi	r25, 0x02	; 2
     f98:	99 83       	std	Y+1, r25	; 0x01
     f9a:	88 83       	st	Y, r24
{
	// Save the number of the serial port, 0 or 1
	port_num = port_number;
     f9c:	f9 8a       	std	Y+17, r15	; 0x11

	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A // Serial port number 0
		if (port_number == 0)
     f9e:	ff 20       	and	r15, r15
     fa0:	d9 f0       	breq	.+54     	; 0xfd8 <_ZN5rs232C1Ejh+0x64>
			rcv0_write_index = 0;
		}
		else  // Serial port number 1
		{
		#if defined UCSR1A
			UCSR1B |= (1 << RXCIE1);		// Receive complete interrupt enable
     fa2:	80 91 c9 00 	lds	r24, 0x00C9
     fa6:	80 68       	ori	r24, 0x80	; 128
     fa8:	80 93 c9 00 	sts	0x00C9, r24

			// Allocate some memory for the receiver buffer and reset the indices
			rcv1_buffer = new uint8_t[RSINT_BUF_SIZE];
     fac:	80 e2       	ldi	r24, 0x20	; 32
     fae:	90 e0       	ldi	r25, 0x00	; 0
     fb0:	0e 94 69 05 	call	0xad2	; 0xad2 <_Znaj>
     fb4:	90 93 b1 02 	sts	0x02B1, r25
     fb8:	80 93 b0 02 	sts	0x02B0, r24
			rcv1_read_index = 0;
     fbc:	10 92 af 02 	sts	0x02AF, r1
     fc0:	10 92 ae 02 	sts	0x02AE, r1
			rcv1_write_index = 0;
     fc4:	10 92 ad 02 	sts	0x02AD, r1
     fc8:	10 92 ac 02 	sts	0x02AC, r1
	// use the XBee radio module
	#ifdef XIPHOS_HACKS
		if (port_number == 1)
			PORTD |= 0x04;
	#endif
}
     fcc:	df 91       	pop	r29
     fce:	cf 91       	pop	r28
     fd0:	1f 91       	pop	r17
     fd2:	0f 91       	pop	r16
     fd4:	ff 90       	pop	r15
     fd6:	08 95       	ret
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A // Serial port number 0
		if (port_number == 0)
		{
			UCSR0B |= (1 << RXCIE0);		// Receive complete interrupt enable
     fd8:	80 91 c1 00 	lds	r24, 0x00C1
     fdc:	80 68       	ori	r24, 0x80	; 128
     fde:	80 93 c1 00 	sts	0x00C1, r24

			// Allocate some memory for the receiver buffer and reset the indices
			rcv0_buffer = new uint8_t[RSINT_BUF_SIZE];
     fe2:	80 e2       	ldi	r24, 0x20	; 32
     fe4:	90 e0       	ldi	r25, 0x00	; 0
     fe6:	0e 94 69 05 	call	0xad2	; 0xad2 <_Znaj>
     fea:	90 93 b7 02 	sts	0x02B7, r25
     fee:	80 93 b6 02 	sts	0x02B6, r24
			rcv0_read_index = 0;
     ff2:	10 92 b5 02 	sts	0x02B5, r1
     ff6:	10 92 b4 02 	sts	0x02B4, r1
			rcv0_write_index = 0;
     ffa:	10 92 b3 02 	sts	0x02B3, r1
     ffe:	10 92 b2 02 	sts	0x02B2, r1
	// use the XBee radio module
	#ifdef XIPHOS_HACKS
		if (port_number == 1)
			PORTD |= 0x04;
	#endif
}
    1002:	df 91       	pop	r29
    1004:	cf 91       	pop	r28
    1006:	1f 91       	pop	r17
    1008:	0f 91       	pop	r16
    100a:	ff 90       	pop	r15
    100c:	08 95       	ret

0000100e <__vector_25>:
 *  This interrupt service routine runs whenever a character has been received by the
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

ISR (RSI_CHAR_RECV_INT_0)
{
    100e:	1f 92       	push	r1
    1010:	0f 92       	push	r0
    1012:	0f b6       	in	r0, 0x3f	; 63
    1014:	0f 92       	push	r0
    1016:	0b b6       	in	r0, 0x3b	; 59
    1018:	0f 92       	push	r0
    101a:	11 24       	eor	r1, r1
    101c:	2f 93       	push	r18
    101e:	3f 93       	push	r19
    1020:	8f 93       	push	r24
    1022:	9f 93       	push	r25
    1024:	ef 93       	push	r30
    1026:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	#if defined UCSR0A  // If this is a dual-serial-port chip (ATmega324P, 128, etc.)
		rcv0_buffer[rcv0_write_index] = UDR0;
    1028:	20 91 c6 00 	lds	r18, 0x00C6
    102c:	e0 91 b6 02 	lds	r30, 0x02B6
    1030:	f0 91 b7 02 	lds	r31, 0x02B7
    1034:	80 91 b2 02 	lds	r24, 0x02B2
    1038:	90 91 b3 02 	lds	r25, 0x02B3
    103c:	e8 0f       	add	r30, r24
    103e:	f9 1f       	adc	r31, r25
    1040:	20 83       	st	Z, r18
	#else  // If this chip has only a single serial port (ATmega8, 32, etc.)
		rcv0_buffer[rcv0_write_index] = UDR;
	#endif

	// Increment the write pointer
	if (++rcv0_write_index >= RSINT_BUF_SIZE)
    1042:	80 91 b2 02 	lds	r24, 0x02B2
    1046:	90 91 b3 02 	lds	r25, 0x02B3
    104a:	01 96       	adiw	r24, 0x01	; 1
    104c:	90 93 b3 02 	sts	0x02B3, r25
    1050:	80 93 b2 02 	sts	0x02B2, r24
    1054:	80 32       	cpi	r24, 0x20	; 32
    1056:	91 05       	cpc	r25, r1
    1058:	30 f0       	brcs	.+12     	; 0x1066 <__vector_25+0x58>
		rcv0_write_index = 0;
    105a:	10 92 b3 02 	sts	0x02B3, r1
    105e:	10 92 b2 02 	sts	0x02B2, r1
    1062:	80 e0       	ldi	r24, 0x00	; 0
    1064:	90 e0       	ldi	r25, 0x00	; 0

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
    1066:	20 91 b4 02 	lds	r18, 0x02B4
    106a:	30 91 b5 02 	lds	r19, 0x02B5
    106e:	28 17       	cp	r18, r24
    1070:	39 07       	cpc	r19, r25
    1072:	69 f0       	breq	.+26     	; 0x108e <__vector_25+0x80>
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
}
    1074:	ff 91       	pop	r31
    1076:	ef 91       	pop	r30
    1078:	9f 91       	pop	r25
    107a:	8f 91       	pop	r24
    107c:	3f 91       	pop	r19
    107e:	2f 91       	pop	r18
    1080:	0f 90       	pop	r0
    1082:	0b be       	out	0x3b, r0	; 59
    1084:	0f 90       	pop	r0
    1086:	0f be       	out	0x3f, r0	; 63
    1088:	0f 90       	pop	r0
    108a:	1f 90       	pop	r1
    108c:	18 95       	reti

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
    108e:	01 96       	adiw	r24, 0x01	; 1
    1090:	90 93 b5 02 	sts	0x02B5, r25
    1094:	80 93 b4 02 	sts	0x02B4, r24
    1098:	80 32       	cpi	r24, 0x20	; 32
    109a:	91 05       	cpc	r25, r1
    109c:	58 f3       	brcs	.-42     	; 0x1074 <__vector_25+0x66>
			rcv0_read_index = 0;
    109e:	10 92 b5 02 	sts	0x02B5, r1
    10a2:	10 92 b4 02 	sts	0x02B4, r1
    10a6:	e6 cf       	rjmp	.-52     	; 0x1074 <__vector_25+0x66>

000010a8 <__vector_36>:
	/** This interrupt service routine runs whenever a character has been received by the
	*  first serial port (number 0).  It saves that character into the receiver buffer.
	*/

	ISR (RSI_CHAR_RECV_INT_1)
	{
    10a8:	1f 92       	push	r1
    10aa:	0f 92       	push	r0
    10ac:	0f b6       	in	r0, 0x3f	; 63
    10ae:	0f 92       	push	r0
    10b0:	0b b6       	in	r0, 0x3b	; 59
    10b2:	0f 92       	push	r0
    10b4:	11 24       	eor	r1, r1
    10b6:	2f 93       	push	r18
    10b8:	3f 93       	push	r19
    10ba:	8f 93       	push	r24
    10bc:	9f 93       	push	r25
    10be:	ef 93       	push	r30
    10c0:	ff 93       	push	r31
		// Read the character from the serial port receiver buffer
		rcv1_buffer[rcv1_write_index] = UDR1;
    10c2:	20 91 ce 00 	lds	r18, 0x00CE
    10c6:	e0 91 b0 02 	lds	r30, 0x02B0
    10ca:	f0 91 b1 02 	lds	r31, 0x02B1
    10ce:	80 91 ac 02 	lds	r24, 0x02AC
    10d2:	90 91 ad 02 	lds	r25, 0x02AD
    10d6:	e8 0f       	add	r30, r24
    10d8:	f9 1f       	adc	r31, r25
    10da:	20 83       	st	Z, r18

		// Increment the write pointer
		if (++rcv1_write_index >= RSINT_BUF_SIZE)
    10dc:	80 91 ac 02 	lds	r24, 0x02AC
    10e0:	90 91 ad 02 	lds	r25, 0x02AD
    10e4:	01 96       	adiw	r24, 0x01	; 1
    10e6:	90 93 ad 02 	sts	0x02AD, r25
    10ea:	80 93 ac 02 	sts	0x02AC, r24
    10ee:	80 32       	cpi	r24, 0x20	; 32
    10f0:	91 05       	cpc	r25, r1
    10f2:	30 f0       	brcs	.+12     	; 0x1100 <__vector_36+0x58>
			rcv1_write_index = 0;
    10f4:	10 92 ad 02 	sts	0x02AD, r1
    10f8:	10 92 ac 02 	sts	0x02AC, r1
    10fc:	80 e0       	ldi	r24, 0x00	; 0
    10fe:	90 e0       	ldi	r25, 0x00	; 0

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
    1100:	20 91 ae 02 	lds	r18, 0x02AE
    1104:	30 91 af 02 	lds	r19, 0x02AF
    1108:	28 17       	cp	r18, r24
    110a:	39 07       	cpc	r19, r25
    110c:	69 f0       	breq	.+26     	; 0x1128 <__vector_36+0x80>
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
				rcv1_read_index = 0;
	}
    110e:	ff 91       	pop	r31
    1110:	ef 91       	pop	r30
    1112:	9f 91       	pop	r25
    1114:	8f 91       	pop	r24
    1116:	3f 91       	pop	r19
    1118:	2f 91       	pop	r18
    111a:	0f 90       	pop	r0
    111c:	0b be       	out	0x3b, r0	; 59
    111e:	0f 90       	pop	r0
    1120:	0f be       	out	0x3f, r0	; 63
    1122:	0f 90       	pop	r0
    1124:	1f 90       	pop	r1
    1126:	18 95       	reti

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
    1128:	01 96       	adiw	r24, 0x01	; 1
    112a:	90 93 af 02 	sts	0x02AF, r25
    112e:	80 93 ae 02 	sts	0x02AE, r24
    1132:	80 32       	cpi	r24, 0x20	; 32
    1134:	91 05       	cpc	r25, r1
    1136:	58 f3       	brcs	.-42     	; 0x110e <__vector_36+0x66>
				rcv1_read_index = 0;
    1138:	10 92 af 02 	sts	0x02AF, r1
    113c:	10 92 ae 02 	sts	0x02AE, r1
    1140:	e6 cf       	rjmp	.-52     	; 0x110e <__vector_36+0x66>

00001142 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1142:	0f 93       	push	r16
    1144:	1f 93       	push	r17
    1146:	cf 93       	push	r28
    1148:	df 93       	push	r29
    114a:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    114c:	0e 94 3d 10 	call	0x207a	; 0x207a <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    1150:	c0 91 b8 02 	lds	r28, 0x02B8
    1154:	d0 91 b9 02 	lds	r29, 0x02B9
    1158:	0c 0f       	add	r16, r28
    115a:	1d 1f       	adc	r17, r29
    115c:	87 e1       	ldi	r24, 0x17	; 23
    115e:	08 33       	cpi	r16, 0x38	; 56
    1160:	18 07       	cpc	r17, r24
    1162:	88 f4       	brcc	.+34     	; 0x1186 <pvPortMalloc+0x44>
    1164:	c0 17       	cp	r28, r16
    1166:	d1 07       	cpc	r29, r17
    1168:	70 f4       	brcc	.+28     	; 0x1186 <pvPortMalloc+0x44>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    116a:	c6 54       	subi	r28, 0x46	; 70
    116c:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
    116e:	10 93 b9 02 	sts	0x02B9, r17
    1172:	00 93 b8 02 	sts	0x02B8, r16
		}	
	}
	xTaskResumeAll();
    1176:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    117a:	ce 01       	movw	r24, r28
    117c:	df 91       	pop	r29
    117e:	cf 91       	pop	r28
    1180:	1f 91       	pop	r17
    1182:	0f 91       	pop	r16
    1184:	08 95       	ret
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    1186:	c0 e0       	ldi	r28, 0x00	; 0
    1188:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    118a:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    118e:	ce 01       	movw	r24, r28
    1190:	df 91       	pop	r29
    1192:	cf 91       	pop	r28
    1194:	1f 91       	pop	r17
    1196:	0f 91       	pop	r16
    1198:	08 95       	ret

0000119a <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    119a:	08 95       	ret

0000119c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    119c:	10 92 b9 02 	sts	0x02B9, r1
    11a0:	10 92 b8 02 	sts	0x02B8, r1
}
    11a4:	08 95       	ret

000011a6 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    11a6:	88 e3       	ldi	r24, 0x38	; 56
    11a8:	97 e1       	ldi	r25, 0x17	; 23
    11aa:	20 91 b8 02 	lds	r18, 0x02B8
    11ae:	30 91 b9 02 	lds	r19, 0x02B9
    11b2:	82 1b       	sub	r24, r18
    11b4:	93 0b       	sbc	r25, r19
}
    11b6:	08 95       	ret

000011b8 <pxPortInitialiseStack>:
	// variable here which holds the address of the top of the stack. It will be
	// grabbed by the task's wrapper object just after xTaskCreate() is called so that
	// the task object knows where its stack is. The stack can then be dumped to a
	// serial port (as a hex printout) for debugging purposes. 
	#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
		portStackTopForTask = (size_t)pxTopOfStack;
    11b8:	90 93 55 1a 	sts	0x1A55, r25
    11bc:	80 93 54 1a 	sts	0x1A54, r24
	#endif

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    11c0:	21 e1       	ldi	r18, 0x11	; 17
    11c2:	fc 01       	movw	r30, r24
    11c4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    11c6:	31 97       	sbiw	r30, 0x01	; 1
    11c8:	32 e2       	ldi	r19, 0x22	; 34
    11ca:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    11cc:	fc 01       	movw	r30, r24
    11ce:	32 97       	sbiw	r30, 0x02	; 2
    11d0:	a3 e3       	ldi	r26, 0x33	; 51
    11d2:	a0 83       	st	Z, r26
	pxTopOfStack--;
#else
	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    11d4:	fc 01       	movw	r30, r24
    11d6:	33 97       	sbiw	r30, 0x03	; 3
    11d8:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    11da:	fc 01       	movw	r30, r24
    11dc:	34 97       	sbiw	r30, 0x04	; 4
    11de:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    11e0:	fc 01       	movw	r30, r24
    11e2:	35 97       	sbiw	r30, 0x05	; 5
    11e4:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    11e6:	fc 01       	movw	r30, r24
    11e8:	36 97       	sbiw	r30, 0x06	; 6
    11ea:	60 e8       	ldi	r22, 0x80	; 128
    11ec:	60 83       	st	Z, r22
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
	pxTopOfStack--;
#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    11ee:	fc 01       	movw	r30, r24
    11f0:	37 97       	sbiw	r30, 0x07	; 7
    11f2:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    11f4:	fc 01       	movw	r30, r24
    11f6:	38 97       	sbiw	r30, 0x08	; 8
    11f8:	62 e0       	ldi	r22, 0x02	; 2
    11fa:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    11fc:	fc 01       	movw	r30, r24
    11fe:	39 97       	sbiw	r30, 0x09	; 9
    1200:	63 e0       	ldi	r22, 0x03	; 3
    1202:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1204:	fc 01       	movw	r30, r24
    1206:	3a 97       	sbiw	r30, 0x0a	; 10
    1208:	64 e0       	ldi	r22, 0x04	; 4
    120a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    120c:	fc 01       	movw	r30, r24
    120e:	3b 97       	sbiw	r30, 0x0b	; 11
    1210:	65 e0       	ldi	r22, 0x05	; 5
    1212:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    1214:	fc 01       	movw	r30, r24
    1216:	3c 97       	sbiw	r30, 0x0c	; 12
    1218:	66 e0       	ldi	r22, 0x06	; 6
    121a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    121c:	fc 01       	movw	r30, r24
    121e:	3d 97       	sbiw	r30, 0x0d	; 13
    1220:	67 e0       	ldi	r22, 0x07	; 7
    1222:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1224:	fc 01       	movw	r30, r24
    1226:	3e 97       	sbiw	r30, 0x0e	; 14
    1228:	68 e0       	ldi	r22, 0x08	; 8
    122a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    122c:	fc 01       	movw	r30, r24
    122e:	3f 97       	sbiw	r30, 0x0f	; 15
    1230:	69 e0       	ldi	r22, 0x09	; 9
    1232:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1234:	fc 01       	movw	r30, r24
    1236:	70 97       	sbiw	r30, 0x10	; 16
    1238:	60 e1       	ldi	r22, 0x10	; 16
    123a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    123c:	fc 01       	movw	r30, r24
    123e:	71 97       	sbiw	r30, 0x11	; 17
    1240:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1242:	fc 01       	movw	r30, r24
    1244:	72 97       	sbiw	r30, 0x12	; 18
    1246:	22 e1       	ldi	r18, 0x12	; 18
    1248:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    124a:	fc 01       	movw	r30, r24
    124c:	73 97       	sbiw	r30, 0x13	; 19
    124e:	23 e1       	ldi	r18, 0x13	; 19
    1250:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1252:	fc 01       	movw	r30, r24
    1254:	74 97       	sbiw	r30, 0x14	; 20
    1256:	24 e1       	ldi	r18, 0x14	; 20
    1258:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    125a:	fc 01       	movw	r30, r24
    125c:	75 97       	sbiw	r30, 0x15	; 21
    125e:	25 e1       	ldi	r18, 0x15	; 21
    1260:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1262:	fc 01       	movw	r30, r24
    1264:	76 97       	sbiw	r30, 0x16	; 22
    1266:	26 e1       	ldi	r18, 0x16	; 22
    1268:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    126a:	fc 01       	movw	r30, r24
    126c:	77 97       	sbiw	r30, 0x17	; 23
    126e:	27 e1       	ldi	r18, 0x17	; 23
    1270:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1272:	fc 01       	movw	r30, r24
    1274:	78 97       	sbiw	r30, 0x18	; 24
    1276:	28 e1       	ldi	r18, 0x18	; 24
    1278:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    127a:	fc 01       	movw	r30, r24
    127c:	79 97       	sbiw	r30, 0x19	; 25
    127e:	29 e1       	ldi	r18, 0x19	; 25
    1280:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1282:	fc 01       	movw	r30, r24
    1284:	7a 97       	sbiw	r30, 0x1a	; 26
    1286:	20 e2       	ldi	r18, 0x20	; 32
    1288:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    128a:	fc 01       	movw	r30, r24
    128c:	7b 97       	sbiw	r30, 0x1b	; 27
    128e:	21 e2       	ldi	r18, 0x21	; 33
    1290:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    1292:	fc 01       	movw	r30, r24
    1294:	7c 97       	sbiw	r30, 0x1c	; 28
    1296:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1298:	fc 01       	movw	r30, r24
    129a:	7d 97       	sbiw	r30, 0x1d	; 29
    129c:	23 e2       	ldi	r18, 0x23	; 35
    129e:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    12a0:	fc 01       	movw	r30, r24
    12a2:	7e 97       	sbiw	r30, 0x1e	; 30
    12a4:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    12a6:	fc 01       	movw	r30, r24
    12a8:	7f 97       	sbiw	r30, 0x1f	; 31
    12aa:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    12ac:	fc 01       	movw	r30, r24
    12ae:	b0 97       	sbiw	r30, 0x20	; 32
    12b0:	26 e2       	ldi	r18, 0x26	; 38
    12b2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    12b4:	fc 01       	movw	r30, r24
    12b6:	b1 97       	sbiw	r30, 0x21	; 33
    12b8:	27 e2       	ldi	r18, 0x27	; 39
    12ba:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    12bc:	fc 01       	movw	r30, r24
    12be:	b2 97       	sbiw	r30, 0x22	; 34
    12c0:	28 e2       	ldi	r18, 0x28	; 40
    12c2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    12c4:	fc 01       	movw	r30, r24
    12c6:	b3 97       	sbiw	r30, 0x23	; 35
    12c8:	29 e2       	ldi	r18, 0x29	; 41
    12ca:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    12cc:	fc 01       	movw	r30, r24
    12ce:	b4 97       	sbiw	r30, 0x24	; 36
    12d0:	20 e3       	ldi	r18, 0x30	; 48
    12d2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    12d4:	fc 01       	movw	r30, r24
    12d6:	b5 97       	sbiw	r30, 0x25	; 37
    12d8:	21 e3       	ldi	r18, 0x31	; 49
    12da:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    12dc:	86 97       	sbiw	r24, 0x26	; 38
}
    12de:	08 95       	ret

000012e0 <xPortStartScheduler>:

	// Use the highest numbered timer available on a given AVR processor, because the
	// lower numbered timers are hooked up to useful things such as PWM's
	#if (defined TIMER5_COMPA_vect)             // Use Timer 5 on ATmega1280/1281
		#define RT_VECT TIMER5_COMPA_vect
		OCR5AH = compare_match.byte[1];         // Set high byte of compare match
    12e0:	87 e0       	ldi	r24, 0x07	; 7
    12e2:	80 93 29 01 	sts	0x0129, r24
		OCR5AL = compare_match.byte[0];         // register, then low byte
    12e6:	8f ec       	ldi	r24, 0xCF	; 207
    12e8:	80 93 28 01 	sts	0x0128, r24
		TCCR5B = (1 << CS51) | (1 << WGM52);    // Prescale F_CPU / 8, clear on match
    12ec:	8a e0       	ldi	r24, 0x0A	; 10
    12ee:	80 93 21 01 	sts	0x0121, r24
		TIMSK5 |= (1 << OCIE5A);                // Enable the timer interrupt
    12f2:	e3 e7       	ldi	r30, 0x73	; 115
    12f4:	f0 e0       	ldi	r31, 0x00	; 0
    12f6:	80 81       	ld	r24, Z
    12f8:	82 60       	ori	r24, 0x02	; 2
    12fa:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    12fc:	a0 91 f2 19 	lds	r26, 0x19F2
    1300:	b0 91 f3 19 	lds	r27, 0x19F3
    1304:	cd 91       	ld	r28, X+
    1306:	cd bf       	out	0x3d, r28	; 61
    1308:	dd 91       	ld	r29, X+
    130a:	de bf       	out	0x3e, r29	; 62
    130c:	ff 91       	pop	r31
    130e:	ef 91       	pop	r30
    1310:	df 91       	pop	r29
    1312:	cf 91       	pop	r28
    1314:	bf 91       	pop	r27
    1316:	af 91       	pop	r26
    1318:	9f 91       	pop	r25
    131a:	8f 91       	pop	r24
    131c:	7f 91       	pop	r23
    131e:	6f 91       	pop	r22
    1320:	5f 91       	pop	r21
    1322:	4f 91       	pop	r20
    1324:	3f 91       	pop	r19
    1326:	2f 91       	pop	r18
    1328:	1f 91       	pop	r17
    132a:	0f 91       	pop	r16
    132c:	ff 90       	pop	r15
    132e:	ef 90       	pop	r14
    1330:	df 90       	pop	r13
    1332:	cf 90       	pop	r12
    1334:	bf 90       	pop	r11
    1336:	af 90       	pop	r10
    1338:	9f 90       	pop	r9
    133a:	8f 90       	pop	r8
    133c:	7f 90       	pop	r7
    133e:	6f 90       	pop	r6
    1340:	5f 90       	pop	r5
    1342:	4f 90       	pop	r4
    1344:	3f 90       	pop	r3
    1346:	2f 90       	pop	r2
    1348:	1f 90       	pop	r1
    134a:	0f 90       	pop	r0
    134c:	0f be       	out	0x3f, r0	; 63
    134e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1350:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1352:	81 e0       	ldi	r24, 0x01	; 1
    1354:	08 95       	ret

00001356 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1356:	08 95       	ret

00001358 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1358:	0f 92       	push	r0
    135a:	0f b6       	in	r0, 0x3f	; 63
    135c:	f8 94       	cli
    135e:	0f 92       	push	r0
    1360:	1f 92       	push	r1
    1362:	11 24       	eor	r1, r1
    1364:	2f 92       	push	r2
    1366:	3f 92       	push	r3
    1368:	4f 92       	push	r4
    136a:	5f 92       	push	r5
    136c:	6f 92       	push	r6
    136e:	7f 92       	push	r7
    1370:	8f 92       	push	r8
    1372:	9f 92       	push	r9
    1374:	af 92       	push	r10
    1376:	bf 92       	push	r11
    1378:	cf 92       	push	r12
    137a:	df 92       	push	r13
    137c:	ef 92       	push	r14
    137e:	ff 92       	push	r15
    1380:	0f 93       	push	r16
    1382:	1f 93       	push	r17
    1384:	2f 93       	push	r18
    1386:	3f 93       	push	r19
    1388:	4f 93       	push	r20
    138a:	5f 93       	push	r21
    138c:	6f 93       	push	r22
    138e:	7f 93       	push	r23
    1390:	8f 93       	push	r24
    1392:	9f 93       	push	r25
    1394:	af 93       	push	r26
    1396:	bf 93       	push	r27
    1398:	cf 93       	push	r28
    139a:	df 93       	push	r29
    139c:	ef 93       	push	r30
    139e:	ff 93       	push	r31
    13a0:	a0 91 f2 19 	lds	r26, 0x19F2
    13a4:	b0 91 f3 19 	lds	r27, 0x19F3
    13a8:	0d b6       	in	r0, 0x3d	; 61
    13aa:	0d 92       	st	X+, r0
    13ac:	0e b6       	in	r0, 0x3e	; 62
    13ae:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    13b0:	0e 94 84 12 	call	0x2508	; 0x2508 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    13b4:	a0 91 f2 19 	lds	r26, 0x19F2
    13b8:	b0 91 f3 19 	lds	r27, 0x19F3
    13bc:	cd 91       	ld	r28, X+
    13be:	cd bf       	out	0x3d, r28	; 61
    13c0:	dd 91       	ld	r29, X+
    13c2:	de bf       	out	0x3e, r29	; 62
    13c4:	ff 91       	pop	r31
    13c6:	ef 91       	pop	r30
    13c8:	df 91       	pop	r29
    13ca:	cf 91       	pop	r28
    13cc:	bf 91       	pop	r27
    13ce:	af 91       	pop	r26
    13d0:	9f 91       	pop	r25
    13d2:	8f 91       	pop	r24
    13d4:	7f 91       	pop	r23
    13d6:	6f 91       	pop	r22
    13d8:	5f 91       	pop	r21
    13da:	4f 91       	pop	r20
    13dc:	3f 91       	pop	r19
    13de:	2f 91       	pop	r18
    13e0:	1f 91       	pop	r17
    13e2:	0f 91       	pop	r16
    13e4:	ff 90       	pop	r15
    13e6:	ef 90       	pop	r14
    13e8:	df 90       	pop	r13
    13ea:	cf 90       	pop	r12
    13ec:	bf 90       	pop	r11
    13ee:	af 90       	pop	r10
    13f0:	9f 90       	pop	r9
    13f2:	8f 90       	pop	r8
    13f4:	7f 90       	pop	r7
    13f6:	6f 90       	pop	r6
    13f8:	5f 90       	pop	r5
    13fa:	4f 90       	pop	r4
    13fc:	3f 90       	pop	r3
    13fe:	2f 90       	pop	r2
    1400:	1f 90       	pop	r1
    1402:	0f 90       	pop	r0
    1404:	0f be       	out	0x3f, r0	; 63
    1406:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1408:	08 95       	ret

0000140a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    140a:	0f 92       	push	r0
    140c:	0f b6       	in	r0, 0x3f	; 63
    140e:	f8 94       	cli
    1410:	0f 92       	push	r0
    1412:	1f 92       	push	r1
    1414:	11 24       	eor	r1, r1
    1416:	2f 92       	push	r2
    1418:	3f 92       	push	r3
    141a:	4f 92       	push	r4
    141c:	5f 92       	push	r5
    141e:	6f 92       	push	r6
    1420:	7f 92       	push	r7
    1422:	8f 92       	push	r8
    1424:	9f 92       	push	r9
    1426:	af 92       	push	r10
    1428:	bf 92       	push	r11
    142a:	cf 92       	push	r12
    142c:	df 92       	push	r13
    142e:	ef 92       	push	r14
    1430:	ff 92       	push	r15
    1432:	0f 93       	push	r16
    1434:	1f 93       	push	r17
    1436:	2f 93       	push	r18
    1438:	3f 93       	push	r19
    143a:	4f 93       	push	r20
    143c:	5f 93       	push	r21
    143e:	6f 93       	push	r22
    1440:	7f 93       	push	r23
    1442:	8f 93       	push	r24
    1444:	9f 93       	push	r25
    1446:	af 93       	push	r26
    1448:	bf 93       	push	r27
    144a:	cf 93       	push	r28
    144c:	df 93       	push	r29
    144e:	ef 93       	push	r30
    1450:	ff 93       	push	r31
    1452:	a0 91 f2 19 	lds	r26, 0x19F2
    1456:	b0 91 f3 19 	lds	r27, 0x19F3
    145a:	0d b6       	in	r0, 0x3d	; 61
    145c:	0d 92       	st	X+, r0
    145e:	0e b6       	in	r0, 0x3e	; 62
    1460:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1462:	0e 94 78 10 	call	0x20f0	; 0x20f0 <vTaskIncrementTick>
	vTaskSwitchContext();
    1466:	0e 94 84 12 	call	0x2508	; 0x2508 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    146a:	a0 91 f2 19 	lds	r26, 0x19F2
    146e:	b0 91 f3 19 	lds	r27, 0x19F3
    1472:	cd 91       	ld	r28, X+
    1474:	cd bf       	out	0x3d, r28	; 61
    1476:	dd 91       	ld	r29, X+
    1478:	de bf       	out	0x3e, r29	; 62
    147a:	ff 91       	pop	r31
    147c:	ef 91       	pop	r30
    147e:	df 91       	pop	r29
    1480:	cf 91       	pop	r28
    1482:	bf 91       	pop	r27
    1484:	af 91       	pop	r26
    1486:	9f 91       	pop	r25
    1488:	8f 91       	pop	r24
    148a:	7f 91       	pop	r23
    148c:	6f 91       	pop	r22
    148e:	5f 91       	pop	r21
    1490:	4f 91       	pop	r20
    1492:	3f 91       	pop	r19
    1494:	2f 91       	pop	r18
    1496:	1f 91       	pop	r17
    1498:	0f 91       	pop	r16
    149a:	ff 90       	pop	r15
    149c:	ef 90       	pop	r14
    149e:	df 90       	pop	r13
    14a0:	cf 90       	pop	r12
    14a2:	bf 90       	pop	r11
    14a4:	af 90       	pop	r10
    14a6:	9f 90       	pop	r9
    14a8:	8f 90       	pop	r8
    14aa:	7f 90       	pop	r7
    14ac:	6f 90       	pop	r6
    14ae:	5f 90       	pop	r5
    14b0:	4f 90       	pop	r4
    14b2:	3f 90       	pop	r3
    14b4:	2f 90       	pop	r2
    14b6:	1f 90       	pop	r1
    14b8:	0f 90       	pop	r0
    14ba:	0f be       	out	0x3f, r0	; 63
    14bc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    14be:	08 95       	ret

000014c0 <__vector_47>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    14c0:	0e 94 05 0a 	call	0x140a	; 0x140a <vPortYieldFromTick>
		asm volatile ( "reti" );
    14c4:	18 95       	reti

000014c6 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    14c6:	cf 93       	push	r28
    14c8:	df 93       	push	r29
    14ca:	fc 01       	movw	r30, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    14cc:	a0 81       	ld	r26, Z
    14ce:	b1 81       	ldd	r27, Z+1	; 0x01
    14d0:	10 97       	sbiw	r26, 0x00	; 0
    14d2:	89 f0       	breq	.+34     	; 0x14f6 <prvCopyDataFromQueue+0x30>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    14d4:	40 a1       	lds	r20, 0x40
    14d6:	26 81       	ldd	r18, Z+6	; 0x06
    14d8:	37 81       	ldd	r19, Z+7	; 0x07
    14da:	24 0f       	add	r18, r20
    14dc:	31 1d       	adc	r19, r1
    14de:	37 83       	std	Z+7, r19	; 0x07
    14e0:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    14e2:	c2 81       	ldd	r28, Z+2	; 0x02
    14e4:	d3 81       	ldd	r29, Z+3	; 0x03
    14e6:	2c 17       	cp	r18, r28
    14e8:	3d 07       	cpc	r19, r29
    14ea:	40 f4       	brcc	.+16     	; 0x14fc <prvCopyDataFromQueue+0x36>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    14ec:	cb 01       	movw	r24, r22
    14ee:	b9 01       	movw	r22, r18
    14f0:	50 e0       	ldi	r21, 0x00	; 0
    14f2:	0e 94 77 16 	call	0x2cee	; 0x2cee <memcpy>
	}
}
    14f6:	df 91       	pop	r29
    14f8:	cf 91       	pop	r28
    14fa:	08 95       	ret
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    14fc:	b7 83       	std	Z+7, r27	; 0x07
    14fe:	a6 83       	std	Z+6, r26	; 0x06
    1500:	9d 01       	movw	r18, r26
    1502:	f4 cf       	rjmp	.-24     	; 0x14ec <prvCopyDataFromQueue+0x26>

00001504 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1504:	0f 93       	push	r16
    1506:	1f 93       	push	r17
    1508:	cf 93       	push	r28
    150a:	df 93       	push	r29
    150c:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    150e:	0f b6       	in	r0, 0x3f	; 63
    1510:	f8 94       	cli
    1512:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1514:	8a a1       	lds	r24, 0x4a
    1516:	18 16       	cp	r1, r24
    1518:	dc f4       	brge	.+54     	; 0x1550 <prvUnlockQueue+0x4c>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    151a:	8b 89       	ldd	r24, Y+19	; 0x13
    151c:	88 23       	and	r24, r24
    151e:	c1 f0       	breq	.+48     	; 0x1550 <prvUnlockQueue+0x4c>
    1520:	8e 01       	movw	r16, r28
    1522:	0d 5e       	subi	r16, 0xED	; 237
    1524:	1f 4f       	sbci	r17, 0xFF	; 255
    1526:	08 c0       	rjmp	.+16     	; 0x1538 <prvUnlockQueue+0x34>
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
				}

				--( pxQueue->xTxLock );
    1528:	8a a1       	lds	r24, 0x4a
    152a:	81 50       	subi	r24, 0x01	; 1
    152c:	8a a3       	lds	r24, 0x5a
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    152e:	18 16       	cp	r1, r24
    1530:	7c f4       	brge	.+30     	; 0x1550 <prvUnlockQueue+0x4c>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1532:	8b 89       	ldd	r24, Y+19	; 0x13
    1534:	88 23       	and	r24, r24
    1536:	61 f0       	breq	.+24     	; 0x1550 <prvUnlockQueue+0x4c>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1538:	c8 01       	movw	r24, r16
    153a:	0e 94 02 13 	call	0x2604	; 0x2604 <xTaskRemoveFromEventList>
    153e:	88 23       	and	r24, r24
    1540:	99 f3       	breq	.-26     	; 0x1528 <prvUnlockQueue+0x24>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1542:	0e 94 c8 13 	call	0x2790	; 0x2790 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1546:	8a a1       	lds	r24, 0x4a
    1548:	81 50       	subi	r24, 0x01	; 1
    154a:	8a a3       	lds	r24, 0x5a
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    154c:	18 16       	cp	r1, r24
    154e:	8c f3       	brlt	.-30     	; 0x1532 <prvUnlockQueue+0x2e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1550:	8f ef       	ldi	r24, 0xFF	; 255
    1552:	8a a3       	lds	r24, 0x5a
	}
	taskEXIT_CRITICAL();
    1554:	0f 90       	pop	r0
    1556:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1558:	0f b6       	in	r0, 0x3f	; 63
    155a:	f8 94       	cli
    155c:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    155e:	89 a1       	lds	r24, 0x49
    1560:	18 16       	cp	r1, r24
    1562:	dc f4       	brge	.+54     	; 0x159a <prvUnlockQueue+0x96>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1564:	88 85       	ldd	r24, Y+8	; 0x08
    1566:	88 23       	and	r24, r24
    1568:	c1 f0       	breq	.+48     	; 0x159a <prvUnlockQueue+0x96>
    156a:	8e 01       	movw	r16, r28
    156c:	08 5f       	subi	r16, 0xF8	; 248
    156e:	1f 4f       	sbci	r17, 0xFF	; 255
    1570:	08 c0       	rjmp	.+16     	; 0x1582 <prvUnlockQueue+0x7e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					vTaskMissedYield();
				}

				--( pxQueue->xRxLock );
    1572:	89 a1       	lds	r24, 0x49
    1574:	81 50       	subi	r24, 0x01	; 1
    1576:	89 a3       	lds	r24, 0x59
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1578:	18 16       	cp	r1, r24
    157a:	7c f4       	brge	.+30     	; 0x159a <prvUnlockQueue+0x96>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    157c:	88 85       	ldd	r24, Y+8	; 0x08
    157e:	88 23       	and	r24, r24
    1580:	61 f0       	breq	.+24     	; 0x159a <prvUnlockQueue+0x96>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1582:	c8 01       	movw	r24, r16
    1584:	0e 94 02 13 	call	0x2604	; 0x2604 <xTaskRemoveFromEventList>
    1588:	88 23       	and	r24, r24
    158a:	99 f3       	breq	.-26     	; 0x1572 <prvUnlockQueue+0x6e>
				{
					vTaskMissedYield();
    158c:	0e 94 c8 13 	call	0x2790	; 0x2790 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1590:	89 a1       	lds	r24, 0x49
    1592:	81 50       	subi	r24, 0x01	; 1
    1594:	89 a3       	lds	r24, 0x59
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1596:	18 16       	cp	r1, r24
    1598:	8c f3       	brlt	.-30     	; 0x157c <prvUnlockQueue+0x78>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    159a:	8f ef       	ldi	r24, 0xFF	; 255
    159c:	89 a3       	lds	r24, 0x59
	}
	taskEXIT_CRITICAL();
    159e:	0f 90       	pop	r0
    15a0:	0f be       	out	0x3f, r0	; 63
}
    15a2:	df 91       	pop	r29
    15a4:	cf 91       	pop	r28
    15a6:	1f 91       	pop	r17
    15a8:	0f 91       	pop	r16
    15aa:	08 95       	ret

000015ac <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    15ac:	cf 93       	push	r28
    15ae:	df 93       	push	r29
    15b0:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    15b2:	28 a1       	lds	r18, 0x48
    15b4:	22 23       	and	r18, r18
    15b6:	59 f4       	brne	.+22     	; 0x15ce <prvCopyDataToQueue+0x22>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    15b8:	88 81       	ld	r24, Y
    15ba:	99 81       	ldd	r25, Y+1	; 0x01
    15bc:	00 97       	sbiw	r24, 0x00	; 0
    15be:	09 f4       	brne	.+2      	; 0x15c2 <prvCopyDataToQueue+0x16>
    15c0:	46 c0       	rjmp	.+140    	; 0x164e <prvCopyDataToQueue+0xa2>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
    15c2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    15c4:	8f 5f       	subi	r24, 0xFF	; 255
    15c6:	8e 8f       	std	Y+30, r24	; 0x1e
}
    15c8:	df 91       	pop	r29
    15ca:	cf 91       	pop	r28
    15cc:	08 95       	ret
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    15ce:	44 23       	and	r20, r20
    15d0:	e1 f4       	brne	.+56     	; 0x160a <prvCopyDataToQueue+0x5e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    15d2:	8c 81       	ldd	r24, Y+4	; 0x04
    15d4:	9d 81       	ldd	r25, Y+5	; 0x05
    15d6:	42 2f       	mov	r20, r18
    15d8:	50 e0       	ldi	r21, 0x00	; 0
    15da:	0e 94 77 16 	call	0x2cee	; 0x2cee <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    15de:	28 a1       	lds	r18, 0x48
    15e0:	8c 81       	ldd	r24, Y+4	; 0x04
    15e2:	9d 81       	ldd	r25, Y+5	; 0x05
    15e4:	82 0f       	add	r24, r18
    15e6:	91 1d       	adc	r25, r1
    15e8:	9d 83       	std	Y+5, r25	; 0x05
    15ea:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    15ec:	2a 81       	ldd	r18, Y+2	; 0x02
    15ee:	3b 81       	ldd	r19, Y+3	; 0x03
    15f0:	82 17       	cp	r24, r18
    15f2:	93 07       	cpc	r25, r19
    15f4:	30 f3       	brcs	.-52     	; 0x15c2 <prvCopyDataToQueue+0x16>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    15f6:	88 81       	ld	r24, Y
    15f8:	99 81       	ldd	r25, Y+1	; 0x01
    15fa:	9d 83       	std	Y+5, r25	; 0x05
    15fc:	8c 83       	std	Y+4, r24	; 0x04
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
    15fe:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1600:	8f 5f       	subi	r24, 0xFF	; 255
    1602:	8e 8f       	std	Y+30, r24	; 0x1e
}
    1604:	df 91       	pop	r29
    1606:	cf 91       	pop	r28
    1608:	08 95       	ret
			pxQueue->pcWriteTo = pxQueue->pcHead;
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    160a:	8e 81       	ldd	r24, Y+6	; 0x06
    160c:	9f 81       	ldd	r25, Y+7	; 0x07
    160e:	42 2f       	mov	r20, r18
    1610:	50 e0       	ldi	r21, 0x00	; 0
    1612:	0e 94 77 16 	call	0x2cee	; 0x2cee <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1616:	48 a1       	lds	r20, 0x48
    1618:	50 e0       	ldi	r21, 0x00	; 0
    161a:	50 95       	com	r21
    161c:	41 95       	neg	r20
    161e:	5f 4f       	sbci	r21, 0xFF	; 255
    1620:	8e 81       	ldd	r24, Y+6	; 0x06
    1622:	9f 81       	ldd	r25, Y+7	; 0x07
    1624:	84 0f       	add	r24, r20
    1626:	95 1f       	adc	r25, r21
    1628:	9f 83       	std	Y+7, r25	; 0x07
    162a:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    162c:	28 81       	ld	r18, Y
    162e:	39 81       	ldd	r19, Y+1	; 0x01
    1630:	82 17       	cp	r24, r18
    1632:	93 07       	cpc	r25, r19
    1634:	30 f6       	brcc	.-116    	; 0x15c2 <prvCopyDataToQueue+0x16>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1636:	8a 81       	ldd	r24, Y+2	; 0x02
    1638:	9b 81       	ldd	r25, Y+3	; 0x03
    163a:	84 0f       	add	r24, r20
    163c:	95 1f       	adc	r25, r21
    163e:	9f 83       	std	Y+7, r25	; 0x07
    1640:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1642:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1644:	8f 5f       	subi	r24, 0xFF	; 255
    1646:	8e 8f       	std	Y+30, r24	; 0x1e
}
    1648:	df 91       	pop	r29
    164a:	cf 91       	pop	r28
    164c:	08 95       	ret
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    164e:	8a 81       	ldd	r24, Y+2	; 0x02
    1650:	9b 81       	ldd	r25, Y+3	; 0x03
    1652:	0e 94 4f 14 	call	0x289e	; 0x289e <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    1656:	1b 82       	std	Y+3, r1	; 0x03
    1658:	1a 82       	std	Y+2, r1	; 0x02
    165a:	b3 cf       	rjmp	.-154    	; 0x15c2 <prvCopyDataToQueue+0x16>

0000165c <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    165c:	cf 93       	push	r28
    165e:	df 93       	push	r29
    1660:	ec 01       	movw	r28, r24

	configASSERT( pxQueue );

	/* If the queue being reset has already been used (has not just been
	created), then only reset the queue if its event lists are empty. */
	if( xNewQueue != pdTRUE )
    1662:	61 30       	cpi	r22, 0x01	; 1
    1664:	51 f0       	breq	.+20     	; 0x167a <xQueueGenericReset+0x1e>
	{
		if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1666:	9b 89       	ldd	r25, Y+19	; 0x13
		{
			xReturn = pdFAIL;
		}

		if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1668:	88 85       	ldd	r24, Y+8	; 0x08
    166a:	88 23       	and	r24, r24
    166c:	21 f0       	breq	.+8      	; 0x1676 <xQueueGenericReset+0x1a>
		{
			xReturn = pdFAIL;
		}
	}

	if( xReturn == pdPASS )
    166e:	80 e0       	ldi	r24, 0x00	; 0
		vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
		vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
	}

	return xReturn;
}
    1670:	df 91       	pop	r29
    1672:	cf 91       	pop	r28
    1674:	08 95       	ret
		{
			xReturn = pdFAIL;
		}
	}

	if( xReturn == pdPASS )
    1676:	99 23       	and	r25, r25
    1678:	d1 f7       	brne	.-12     	; 0x166e <xQueueGenericReset+0x12>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    167a:	48 81       	ld	r20, Y
    167c:	59 81       	ldd	r21, Y+1	; 0x01
    167e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1680:	68 a1       	lds	r22, 0x48
    1682:	86 9f       	mul	r24, r22
    1684:	90 01       	movw	r18, r0
    1686:	11 24       	eor	r1, r1
    1688:	24 0f       	add	r18, r20
    168a:	35 1f       	adc	r19, r21
    168c:	3b 83       	std	Y+3, r19	; 0x03
    168e:	2a 83       	std	Y+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1690:	1e 8e       	std	Y+30, r1	; 0x1e
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1692:	5d 83       	std	Y+5, r21	; 0x05
    1694:	4c 83       	std	Y+4, r20	; 0x04
		}
	}

	if( xReturn == pdPASS )
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1696:	70 e0       	ldi	r23, 0x00	; 0
    1698:	90 e0       	ldi	r25, 0x00	; 0
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    169a:	01 97       	sbiw	r24, 0x01	; 1
    169c:	68 9f       	mul	r22, r24
    169e:	90 01       	movw	r18, r0
    16a0:	69 9f       	mul	r22, r25
    16a2:	30 0d       	add	r19, r0
    16a4:	78 9f       	mul	r23, r24
    16a6:	30 0d       	add	r19, r0
    16a8:	11 24       	eor	r1, r1
    16aa:	24 0f       	add	r18, r20
    16ac:	35 1f       	adc	r19, r21
    16ae:	3f 83       	std	Y+7, r19	; 0x07
    16b0:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    16b2:	8f ef       	ldi	r24, 0xFF	; 255
    16b4:	89 a3       	lds	r24, 0x59
		pxQueue->xTxLock = queueUNLOCKED;
    16b6:	8a a3       	lds	r24, 0x5a

		/* Ensure the event queues start with the correct state. */
		vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    16b8:	ce 01       	movw	r24, r28
    16ba:	08 96       	adiw	r24, 0x08	; 8
    16bc:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <vListInitialise>
		vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    16c0:	ce 01       	movw	r24, r28
    16c2:	43 96       	adiw	r24, 0x13	; 19
    16c4:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <vListInitialise>
    16c8:	81 e0       	ldi	r24, 0x01	; 1
	}

	return xReturn;
}
    16ca:	df 91       	pop	r29
    16cc:	cf 91       	pop	r28
    16ce:	08 95       	ret

000016d0 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    16d0:	0f 93       	push	r16
    16d2:	1f 93       	push	r17
    16d4:	cf 93       	push	r28
    16d6:	df 93       	push	r29
    16d8:	18 2f       	mov	r17, r24
    16da:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    16dc:	88 23       	and	r24, r24
    16de:	f1 f0       	breq	.+60     	; 0x171c <xQueueGenericCreate+0x4c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    16e0:	83 e2       	ldi	r24, 0x23	; 35
    16e2:	90 e0       	ldi	r25, 0x00	; 0
    16e4:	0e 94 a1 08 	call	0x1142	; 0x1142 <pvPortMalloc>
    16e8:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    16ea:	00 97       	sbiw	r24, 0x00	; 0
    16ec:	b9 f0       	breq	.+46     	; 0x171c <xQueueGenericCreate+0x4c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    16ee:	10 9f       	mul	r17, r16
    16f0:	90 01       	movw	r18, r0
    16f2:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    16f4:	c9 01       	movw	r24, r18
    16f6:	01 96       	adiw	r24, 0x01	; 1
    16f8:	0e 94 a1 08 	call	0x1142	; 0x1142 <pvPortMalloc>
    16fc:	99 83       	std	Y+1, r25	; 0x01
    16fe:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1700:	00 97       	sbiw	r24, 0x00	; 0
    1702:	99 f0       	breq	.+38     	; 0x172a <xQueueGenericCreate+0x5a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1704:	1f 8f       	std	Y+31, r17	; 0x1f
				pxNewQueue->uxItemSize = uxItemSize;
    1706:	08 a3       	lds	r16, 0x58
				xQueueGenericReset( pxNewQueue, pdTRUE );
    1708:	ce 01       	movw	r24, r28
    170a:	61 e0       	ldi	r22, 0x01	; 1
    170c:	0e 94 2e 0b 	call	0x165c	; 0x165c <xQueueGenericReset>
    1710:	ce 01       	movw	r24, r28
	}

	configASSERT( xReturn );

	return xReturn;
}
    1712:	df 91       	pop	r29
    1714:	cf 91       	pop	r28
    1716:	1f 91       	pop	r17
    1718:	0f 91       	pop	r16
    171a:	08 95       	ret

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    171c:	80 e0       	ldi	r24, 0x00	; 0
    171e:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    1720:	df 91       	pop	r29
    1722:	cf 91       	pop	r28
    1724:	1f 91       	pop	r17
    1726:	0f 91       	pop	r16
    1728:	08 95       	ret
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    172a:	ce 01       	movw	r24, r28
    172c:	0e 94 cd 08 	call	0x119a	; 0x119a <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1730:	80 e0       	ldi	r24, 0x00	; 0
    1732:	90 e0       	ldi	r25, 0x00	; 0
    1734:	ee cf       	rjmp	.-36     	; 0x1712 <xQueueGenericCreate+0x42>

00001736 <xQueueGetMutexHolder>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void* xQueueGetMutexHolder( xQueueHandle xSemaphore )
	{
    1736:	fc 01       	movw	r30, r24
		/* This function is called by xSemaphoreGetMutexHolder(), and should not
		be called directly.  Note:  This is is a good way of determining if the
		calling task is the mutex holder, but not a good way of determining the
		identity of the mutex holder, as the holder may change between the 
		following critical section exiting and the function returning. */
		taskENTER_CRITICAL();
    1738:	0f b6       	in	r0, 0x3f	; 63
    173a:	f8 94       	cli
    173c:	0f 92       	push	r0
		{
			if( xSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
    173e:	80 81       	ld	r24, Z
    1740:	91 81       	ldd	r25, Z+1	; 0x01
    1742:	00 97       	sbiw	r24, 0x00	; 0
    1744:	29 f4       	brne	.+10     	; 0x1750 <xQueueGetMutexHolder+0x1a>
			{
				pxReturn = ( void * ) xSemaphore->pxMutexHolder;
    1746:	82 81       	ldd	r24, Z+2	; 0x02
    1748:	93 81       	ldd	r25, Z+3	; 0x03
			else
			{
				pxReturn = NULL;
			}
		}
		taskEXIT_CRITICAL();
    174a:	0f 90       	pop	r0
    174c:	0f be       	out	0x3f, r0	; 63
		
		return pxReturn;
	}
    174e:	08 95       	ret
			{
				pxReturn = ( void * ) xSemaphore->pxMutexHolder;
			}
			else
			{
				pxReturn = NULL;
    1750:	80 e0       	ldi	r24, 0x00	; 0
    1752:	90 e0       	ldi	r25, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    1754:	0f 90       	pop	r0
    1756:	0f be       	out	0x3f, r0	; 63
		
		return pxReturn;
	}
    1758:	08 95       	ret

0000175a <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    175a:	af 92       	push	r10
    175c:	bf 92       	push	r11
    175e:	cf 92       	push	r12
    1760:	df 92       	push	r13
    1762:	ef 92       	push	r14
    1764:	ff 92       	push	r15
    1766:	0f 93       	push	r16
    1768:	cf 93       	push	r28
    176a:	df 93       	push	r29
    176c:	cd b7       	in	r28, 0x3d	; 61
    176e:	de b7       	in	r29, 0x3e	; 62
    1770:	29 97       	sbiw	r28, 0x09	; 9
    1772:	0f b6       	in	r0, 0x3f	; 63
    1774:	f8 94       	cli
    1776:	de bf       	out	0x3e, r29	; 62
    1778:	0f be       	out	0x3f, r0	; 63
    177a:	cd bf       	out	0x3d, r28	; 61
    177c:	7c 01       	movw	r14, r24
    177e:	5b 01       	movw	r10, r22
    1780:	2e 83       	std	Y+6, r18	; 0x06
    1782:	3f 83       	std	Y+7, r19	; 0x07
    1784:	48 87       	std	Y+8, r20	; 0x08
    1786:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1788:	20 e0       	ldi	r18, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    178a:	e8 e0       	ldi	r30, 0x08	; 8
    178c:	ce 2e       	mov	r12, r30
    178e:	d1 2c       	mov	r13, r1
    1790:	c8 0e       	add	r12, r24
    1792:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1794:	0f b6       	in	r0, 0x3f	; 63
    1796:	f8 94       	cli
    1798:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    179a:	f7 01       	movw	r30, r14
    179c:	96 8d       	ldd	r25, Z+30	; 0x1e
    179e:	87 8d       	ldd	r24, Z+31	; 0x1f
    17a0:	98 17       	cp	r25, r24
    17a2:	08 f4       	brcc	.+2      	; 0x17a6 <xQueueGenericSend+0x4c>
    17a4:	56 c0       	rjmp	.+172    	; 0x1852 <xQueueGenericSend+0xf8>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    17a6:	8e 81       	ldd	r24, Y+6	; 0x06
    17a8:	9f 81       	ldd	r25, Y+7	; 0x07
    17aa:	a8 85       	ldd	r26, Y+8	; 0x08
    17ac:	b9 85       	ldd	r27, Y+9	; 0x09
    17ae:	00 97       	sbiw	r24, 0x00	; 0
    17b0:	a1 05       	cpc	r26, r1
    17b2:	b1 05       	cpc	r27, r1
    17b4:	09 f4       	brne	.+2      	; 0x17b8 <xQueueGenericSend+0x5e>
    17b6:	69 c0       	rjmp	.+210    	; 0x188a <xQueueGenericSend+0x130>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    17b8:	22 23       	and	r18, r18
    17ba:	69 f1       	breq	.+90     	; 0x1816 <xQueueGenericSend+0xbc>
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    17bc:	0f 90       	pop	r0
    17be:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    17c0:	0e 94 3d 10 	call	0x207a	; 0x207a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    17c4:	0f b6       	in	r0, 0x3f	; 63
    17c6:	f8 94       	cli
    17c8:	0f 92       	push	r0
    17ca:	f7 01       	movw	r30, r14
    17cc:	81 a1       	lds	r24, 0x41
    17ce:	8f 3f       	cpi	r24, 0xFF	; 255
    17d0:	39 f1       	breq	.+78     	; 0x1820 <xQueueGenericSend+0xc6>
    17d2:	f7 01       	movw	r30, r14
    17d4:	82 a1       	lds	r24, 0x42
    17d6:	8f 3f       	cpi	r24, 0xFF	; 255
    17d8:	41 f1       	breq	.+80     	; 0x182a <xQueueGenericSend+0xd0>
    17da:	0f 90       	pop	r0
    17dc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    17de:	ce 01       	movw	r24, r28
    17e0:	01 96       	adiw	r24, 0x01	; 1
    17e2:	be 01       	movw	r22, r28
    17e4:	6a 5f       	subi	r22, 0xFA	; 250
    17e6:	7f 4f       	sbci	r23, 0xFF	; 255
    17e8:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskCheckForTimeOut>
    17ec:	88 23       	and	r24, r24
    17ee:	09 f0       	breq	.+2      	; 0x17f2 <xQueueGenericSend+0x98>
    17f0:	50 c0       	rjmp	.+160    	; 0x1892 <xQueueGenericSend+0x138>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    17f2:	0f b6       	in	r0, 0x3f	; 63
    17f4:	f8 94       	cli
    17f6:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    17f8:	f7 01       	movw	r30, r14
    17fa:	96 8d       	ldd	r25, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    17fc:	0f 90       	pop	r0
    17fe:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1800:	f7 01       	movw	r30, r14
    1802:	87 8d       	ldd	r24, Z+31	; 0x1f
    1804:	98 17       	cp	r25, r24
    1806:	99 f0       	breq	.+38     	; 0x182e <xQueueGenericSend+0xd4>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1808:	c7 01       	movw	r24, r14
    180a:	0e 94 82 0a 	call	0x1504	; 0x1504 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    180e:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xTaskResumeAll>
			( void ) xTaskResumeAll();

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1812:	21 e0       	ldi	r18, 0x01	; 1
    1814:	bf cf       	rjmp	.-130    	; 0x1794 <xQueueGenericSend+0x3a>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1816:	ce 01       	movw	r24, r28
    1818:	01 96       	adiw	r24, 0x01	; 1
    181a:	0e 94 50 13 	call	0x26a0	; 0x26a0 <vTaskSetTimeOutState>
    181e:	ce cf       	rjmp	.-100    	; 0x17bc <xQueueGenericSend+0x62>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    1820:	11 a2       	lds	r17, 0x91
    1822:	f7 01       	movw	r30, r14
    1824:	82 a1       	lds	r24, 0x42
    1826:	8f 3f       	cpi	r24, 0xFF	; 255
    1828:	c1 f6       	brne	.-80     	; 0x17da <xQueueGenericSend+0x80>
    182a:	12 a2       	lds	r17, 0x92
    182c:	d6 cf       	rjmp	.-84     	; 0x17da <xQueueGenericSend+0x80>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    182e:	4e 81       	ldd	r20, Y+6	; 0x06
    1830:	5f 81       	ldd	r21, Y+7	; 0x07
    1832:	68 85       	ldd	r22, Y+8	; 0x08
    1834:	79 85       	ldd	r23, Y+9	; 0x09
    1836:	c6 01       	movw	r24, r12
    1838:	0e 94 d8 12 	call	0x25b0	; 0x25b0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    183c:	c7 01       	movw	r24, r14
    183e:	0e 94 82 0a 	call	0x1504	; 0x1504 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1842:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xTaskResumeAll>
    1846:	88 23       	and	r24, r24
    1848:	21 f7       	brne	.-56     	; 0x1812 <xQueueGenericSend+0xb8>
				{
					portYIELD_WITHIN_API();
    184a:	0e 94 ac 09 	call	0x1358	; 0x1358 <vPortYield>
			( void ) xTaskResumeAll();

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    184e:	21 e0       	ldi	r18, 0x01	; 1
    1850:	a1 cf       	rjmp	.-190    	; 0x1794 <xQueueGenericSend+0x3a>
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1852:	c7 01       	movw	r24, r14
    1854:	b5 01       	movw	r22, r10
    1856:	40 2f       	mov	r20, r16
    1858:	0e 94 d6 0a 	call	0x15ac	; 0x15ac <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    185c:	f7 01       	movw	r30, r14
    185e:	83 89       	ldd	r24, Z+19	; 0x13
    1860:	88 23       	and	r24, r24
    1862:	f1 f4       	brne	.+60     	; 0x18a0 <xQueueGenericSend+0x146>
						takes care of that. */
						portYIELD_WITHIN_API();
					}
				}

				taskEXIT_CRITICAL();
    1864:	0f 90       	pop	r0
    1866:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1868:	81 e0       	ldi	r24, 0x01	; 1
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    186a:	29 96       	adiw	r28, 0x09	; 9
    186c:	0f b6       	in	r0, 0x3f	; 63
    186e:	f8 94       	cli
    1870:	de bf       	out	0x3e, r29	; 62
    1872:	0f be       	out	0x3f, r0	; 63
    1874:	cd bf       	out	0x3d, r28	; 61
    1876:	df 91       	pop	r29
    1878:	cf 91       	pop	r28
    187a:	0f 91       	pop	r16
    187c:	ff 90       	pop	r15
    187e:	ef 90       	pop	r14
    1880:	df 90       	pop	r13
    1882:	cf 90       	pop	r12
    1884:	bf 90       	pop	r11
    1886:	af 90       	pop	r10
    1888:	08 95       	ret
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    188a:	0f 90       	pop	r0
    188c:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    188e:	80 e0       	ldi	r24, 0x00	; 0
    1890:	ec cf       	rjmp	.-40     	; 0x186a <xQueueGenericSend+0x110>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1892:	c7 01       	movw	r24, r14
    1894:	0e 94 82 0a 	call	0x1504	; 0x1504 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1898:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    189c:	80 e0       	ldi	r24, 0x00	; 0
    189e:	e5 cf       	rjmp	.-54     	; 0x186a <xQueueGenericSend+0x110>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    18a0:	c7 01       	movw	r24, r14
    18a2:	43 96       	adiw	r24, 0x13	; 19
    18a4:	0e 94 02 13 	call	0x2604	; 0x2604 <xTaskRemoveFromEventList>
    18a8:	81 30       	cpi	r24, 0x01	; 1
    18aa:	e1 f6       	brne	.-72     	; 0x1864 <xQueueGenericSend+0x10a>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    18ac:	0e 94 ac 09 	call	0x1358	; 0x1358 <vPortYield>
    18b0:	d9 cf       	rjmp	.-78     	; 0x1864 <xQueueGenericSend+0x10a>

000018b2 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    18b2:	0f 93       	push	r16
    18b4:	cf 93       	push	r28
    18b6:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    18b8:	83 e2       	ldi	r24, 0x23	; 35
    18ba:	90 e0       	ldi	r25, 0x00	; 0
    18bc:	0e 94 a1 08 	call	0x1142	; 0x1142 <pvPortMalloc>
    18c0:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    18c2:	00 97       	sbiw	r24, 0x00	; 0
    18c4:	01 f1       	breq	.+64     	; 0x1906 <xQueueCreateMutex+0x54>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    18c6:	1b 82       	std	Y+3, r1	; 0x03
    18c8:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    18ca:	19 82       	std	Y+1, r1	; 0x01
    18cc:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    18ce:	1d 82       	std	Y+5, r1	; 0x05
    18d0:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    18d2:	1f 82       	std	Y+7, r1	; 0x07
    18d4:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    18d6:	1e 8e       	std	Y+30, r1	; 0x1e
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    18d8:	81 e0       	ldi	r24, 0x01	; 1
    18da:	8f 8f       	std	Y+31, r24	; 0x1f
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    18dc:	18 a2       	lds	r17, 0x98
			pxNewQueue->xRxLock = queueUNLOCKED;
    18de:	8f ef       	ldi	r24, 0xFF	; 255
    18e0:	89 a3       	lds	r24, 0x59
			pxNewQueue->xTxLock = queueUNLOCKED;
    18e2:	8a a3       	lds	r24, 0x5a
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    18e4:	ce 01       	movw	r24, r28
    18e6:	08 96       	adiw	r24, 0x08	; 8
    18e8:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    18ec:	ce 01       	movw	r24, r28
    18ee:	43 96       	adiw	r24, 0x13	; 19
    18f0:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    18f4:	ce 01       	movw	r24, r28
    18f6:	60 e0       	ldi	r22, 0x00	; 0
    18f8:	70 e0       	ldi	r23, 0x00	; 0
    18fa:	20 e0       	ldi	r18, 0x00	; 0
    18fc:	30 e0       	ldi	r19, 0x00	; 0
    18fe:	a9 01       	movw	r20, r18
    1900:	00 e0       	ldi	r16, 0x00	; 0
    1902:	0e 94 ad 0b 	call	0x175a	; 0x175a <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1906:	ce 01       	movw	r24, r28
    1908:	df 91       	pop	r29
    190a:	cf 91       	pop	r28
    190c:	0f 91       	pop	r16
    190e:	08 95       	ret

00001910 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1910:	0f 93       	push	r16
    1912:	1f 93       	push	r17
    1914:	cf 93       	push	r28
    1916:	df 93       	push	r29
    1918:	ec 01       	movw	r28, r24
    191a:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    191c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    191e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1920:	98 17       	cp	r25, r24
    1922:	30 f0       	brcs	.+12     	; 0x1930 <xQueueGenericSendFromISR+0x20>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1924:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1926:	df 91       	pop	r29
    1928:	cf 91       	pop	r28
    192a:	1f 91       	pop	r17
    192c:	0f 91       	pop	r16
    192e:	08 95       	ret
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1930:	ce 01       	movw	r24, r28
    1932:	42 2f       	mov	r20, r18
    1934:	0e 94 d6 0a 	call	0x15ac	; 0x15ac <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1938:	8a a1       	lds	r24, 0x4a
    193a:	8f 3f       	cpi	r24, 0xFF	; 255
    193c:	41 f0       	breq	.+16     	; 0x194e <xQueueGenericSendFromISR+0x3e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    193e:	8f 5f       	subi	r24, 0xFF	; 255
    1940:	8a a3       	lds	r24, 0x5a
			}

			xReturn = pdPASS;
    1942:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1944:	df 91       	pop	r29
    1946:	cf 91       	pop	r28
    1948:	1f 91       	pop	r17
    194a:	0f 91       	pop	r16
    194c:	08 95       	ret

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    194e:	8b 89       	ldd	r24, Y+19	; 0x13
    1950:	88 23       	and	r24, r24
    1952:	11 f4       	brne	.+4      	; 0x1958 <xQueueGenericSendFromISR+0x48>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1954:	81 e0       	ldi	r24, 0x01	; 1
    1956:	e7 cf       	rjmp	.-50     	; 0x1926 <xQueueGenericSendFromISR+0x16>
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1958:	ce 01       	movw	r24, r28
    195a:	43 96       	adiw	r24, 0x13	; 19
    195c:	0e 94 02 13 	call	0x2604	; 0x2604 <xTaskRemoveFromEventList>
    1960:	88 23       	and	r24, r24
    1962:	c1 f3       	breq	.-16     	; 0x1954 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1964:	81 e0       	ldi	r24, 0x01	; 1
    1966:	f8 01       	movw	r30, r16
    1968:	80 83       	st	Z, r24
    196a:	dd cf       	rjmp	.-70     	; 0x1926 <xQueueGenericSendFromISR+0x16>

0000196c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    196c:	af 92       	push	r10
    196e:	bf 92       	push	r11
    1970:	df 92       	push	r13
    1972:	ef 92       	push	r14
    1974:	ff 92       	push	r15
    1976:	0f 93       	push	r16
    1978:	1f 93       	push	r17
    197a:	cf 93       	push	r28
    197c:	df 93       	push	r29
    197e:	cd b7       	in	r28, 0x3d	; 61
    1980:	de b7       	in	r29, 0x3e	; 62
    1982:	29 97       	sbiw	r28, 0x09	; 9
    1984:	0f b6       	in	r0, 0x3f	; 63
    1986:	f8 94       	cli
    1988:	de bf       	out	0x3e, r29	; 62
    198a:	0f be       	out	0x3f, r0	; 63
    198c:	cd bf       	out	0x3d, r28	; 61
    198e:	7c 01       	movw	r14, r24
    1990:	5b 01       	movw	r10, r22
    1992:	2e 83       	std	Y+6, r18	; 0x06
    1994:	3f 83       	std	Y+7, r19	; 0x07
    1996:	48 87       	std	Y+8, r20	; 0x08
    1998:	59 87       	std	Y+9, r21	; 0x09
    199a:	d0 2e       	mov	r13, r16
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    199c:	20 e0       	ldi	r18, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    199e:	8c 01       	movw	r16, r24
    19a0:	0d 5e       	subi	r16, 0xED	; 237
    19a2:	1f 4f       	sbci	r17, 0xFF	; 255
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    19a4:	0f b6       	in	r0, 0x3f	; 63
    19a6:	f8 94       	cli
    19a8:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    19aa:	f7 01       	movw	r30, r14
    19ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    19ae:	88 23       	and	r24, r24
    19b0:	09 f0       	breq	.+2      	; 0x19b4 <xQueueGenericReceive+0x48>
    19b2:	6a c0       	rjmp	.+212    	; 0x1a88 <xQueueGenericReceive+0x11c>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    19b4:	8e 81       	ldd	r24, Y+6	; 0x06
    19b6:	9f 81       	ldd	r25, Y+7	; 0x07
    19b8:	a8 85       	ldd	r26, Y+8	; 0x08
    19ba:	b9 85       	ldd	r27, Y+9	; 0x09
    19bc:	00 97       	sbiw	r24, 0x00	; 0
    19be:	a1 05       	cpc	r26, r1
    19c0:	b1 05       	cpc	r27, r1
    19c2:	09 f4       	brne	.+2      	; 0x19c6 <xQueueGenericReceive+0x5a>
    19c4:	7e c0       	rjmp	.+252    	; 0x1ac2 <xQueueGenericReceive+0x156>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    19c6:	22 23       	and	r18, r18
    19c8:	09 f4       	brne	.+2      	; 0x19cc <xQueueGenericReceive+0x60>
    19ca:	3f c0       	rjmp	.+126    	; 0x1a4a <xQueueGenericReceive+0xde>
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    19cc:	0f 90       	pop	r0
    19ce:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    19d0:	0e 94 3d 10 	call	0x207a	; 0x207a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    19d4:	0f b6       	in	r0, 0x3f	; 63
    19d6:	f8 94       	cli
    19d8:	0f 92       	push	r0
    19da:	f7 01       	movw	r30, r14
    19dc:	81 a1       	lds	r24, 0x41
    19de:	8f 3f       	cpi	r24, 0xFF	; 255
    19e0:	09 f4       	brne	.+2      	; 0x19e4 <xQueueGenericReceive+0x78>
    19e2:	3f c0       	rjmp	.+126    	; 0x1a62 <xQueueGenericReceive+0xf6>
    19e4:	f7 01       	movw	r30, r14
    19e6:	82 a1       	lds	r24, 0x42
    19e8:	8f 3f       	cpi	r24, 0xFF	; 255
    19ea:	09 f4       	brne	.+2      	; 0x19ee <xQueueGenericReceive+0x82>
    19ec:	40 c0       	rjmp	.+128    	; 0x1a6e <xQueueGenericReceive+0x102>
    19ee:	0f 90       	pop	r0
    19f0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    19f2:	ce 01       	movw	r24, r28
    19f4:	01 96       	adiw	r24, 0x01	; 1
    19f6:	be 01       	movw	r22, r28
    19f8:	6a 5f       	subi	r22, 0xFA	; 250
    19fa:	7f 4f       	sbci	r23, 0xFF	; 255
    19fc:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskCheckForTimeOut>
    1a00:	88 23       	and	r24, r24
    1a02:	09 f0       	breq	.+2      	; 0x1a06 <xQueueGenericReceive+0x9a>
    1a04:	71 c0       	rjmp	.+226    	; 0x1ae8 <xQueueGenericReceive+0x17c>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1a06:	0f b6       	in	r0, 0x3f	; 63
    1a08:	f8 94       	cli
    1a0a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1a0c:	f7 01       	movw	r30, r14
    1a0e:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1a10:	0f 90       	pop	r0
    1a12:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1a14:	88 23       	and	r24, r24
    1a16:	f1 f4       	brne	.+60     	; 0x1a54 <xQueueGenericReceive+0xe8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1a18:	f7 01       	movw	r30, r14
    1a1a:	80 81       	ld	r24, Z
    1a1c:	91 81       	ldd	r25, Z+1	; 0x01
    1a1e:	00 97       	sbiw	r24, 0x00	; 0
    1a20:	41 f1       	breq	.+80     	; 0x1a72 <xQueueGenericReceive+0x106>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1a22:	4e 81       	ldd	r20, Y+6	; 0x06
    1a24:	5f 81       	ldd	r21, Y+7	; 0x07
    1a26:	68 85       	ldd	r22, Y+8	; 0x08
    1a28:	79 85       	ldd	r23, Y+9	; 0x09
    1a2a:	c8 01       	movw	r24, r16
    1a2c:	0e 94 d8 12 	call	0x25b0	; 0x25b0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1a30:	c7 01       	movw	r24, r14
    1a32:	0e 94 82 0a 	call	0x1504	; 0x1504 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1a36:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xTaskResumeAll>
    1a3a:	88 23       	and	r24, r24
    1a3c:	11 f0       	breq	.+4      	; 0x1a42 <xQueueGenericReceive+0xd6>
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1a3e:	21 e0       	ldi	r18, 0x01	; 1
    1a40:	b1 cf       	rjmp	.-158    	; 0x19a4 <xQueueGenericReceive+0x38>

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
				{
					portYIELD_WITHIN_API();
    1a42:	0e 94 ac 09 	call	0x1358	; 0x1358 <vPortYield>
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1a46:	21 e0       	ldi	r18, 0x01	; 1
    1a48:	ad cf       	rjmp	.-166    	; 0x19a4 <xQueueGenericReceive+0x38>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1a4a:	ce 01       	movw	r24, r28
    1a4c:	01 96       	adiw	r24, 0x01	; 1
    1a4e:	0e 94 50 13 	call	0x26a0	; 0x26a0 <vTaskSetTimeOutState>
    1a52:	bc cf       	rjmp	.-136    	; 0x19cc <xQueueGenericReceive+0x60>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1a54:	c7 01       	movw	r24, r14
    1a56:	0e 94 82 0a 	call	0x1504	; 0x1504 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1a5a:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xTaskResumeAll>
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1a5e:	21 e0       	ldi	r18, 0x01	; 1
    1a60:	a1 cf       	rjmp	.-190    	; 0x19a4 <xQueueGenericReceive+0x38>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    1a62:	11 a2       	lds	r17, 0x91
    1a64:	f7 01       	movw	r30, r14
    1a66:	82 a1       	lds	r24, 0x42
    1a68:	8f 3f       	cpi	r24, 0xFF	; 255
    1a6a:	09 f0       	breq	.+2      	; 0x1a6e <xQueueGenericReceive+0x102>
    1a6c:	c0 cf       	rjmp	.-128    	; 0x19ee <xQueueGenericReceive+0x82>
    1a6e:	12 a2       	lds	r17, 0x92
    1a70:	be cf       	rjmp	.-132    	; 0x19ee <xQueueGenericReceive+0x82>

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
					{
						portENTER_CRITICAL();
    1a72:	0f b6       	in	r0, 0x3f	; 63
    1a74:	f8 94       	cli
    1a76:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1a78:	f7 01       	movw	r30, r14
    1a7a:	82 81       	ldd	r24, Z+2	; 0x02
    1a7c:	93 81       	ldd	r25, Z+3	; 0x03
    1a7e:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1a82:	0f 90       	pop	r0
    1a84:	0f be       	out	0x3f, r0	; 63
    1a86:	cd cf       	rjmp	.-102    	; 0x1a22 <xQueueGenericReceive+0xb6>
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1a88:	06 81       	ldd	r16, Z+6	; 0x06
    1a8a:	17 81       	ldd	r17, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a8c:	c7 01       	movw	r24, r14
    1a8e:	b5 01       	movw	r22, r10
    1a90:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1a94:	f7 01       	movw	r30, r14
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    1a96:	dd 20       	and	r13, r13
    1a98:	71 f5       	brne	.+92     	; 0x1af6 <xQueueGenericReceive+0x18a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1a9a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a9c:	81 50       	subi	r24, 0x01	; 1
    1a9e:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1aa0:	80 81       	ld	r24, Z
    1aa2:	91 81       	ldd	r25, Z+1	; 0x01
    1aa4:	00 97       	sbiw	r24, 0x00	; 0
    1aa6:	b9 f1       	breq	.+110    	; 0x1b16 <xQueueGenericReceive+0x1aa>
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1aa8:	f7 01       	movw	r30, r14
    1aaa:	80 85       	ldd	r24, Z+8	; 0x08
    1aac:	88 23       	and	r24, r24
    1aae:	41 f1       	breq	.+80     	; 0x1b00 <xQueueGenericReceive+0x194>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1ab0:	c7 01       	movw	r24, r14
    1ab2:	08 96       	adiw	r24, 0x08	; 8
    1ab4:	0e 94 02 13 	call	0x2604	; 0x2604 <xTaskRemoveFromEventList>
    1ab8:	81 30       	cpi	r24, 0x01	; 1
    1aba:	11 f5       	brne	.+68     	; 0x1b00 <xQueueGenericReceive+0x194>
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1abc:	0e 94 ac 09 	call	0x1358	; 0x1358 <vPortYield>
    1ac0:	1f c0       	rjmp	.+62     	; 0x1b00 <xQueueGenericReceive+0x194>
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1ac2:	0f 90       	pop	r0
    1ac4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1ac6:	80 e0       	ldi	r24, 0x00	; 0
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    1ac8:	29 96       	adiw	r28, 0x09	; 9
    1aca:	0f b6       	in	r0, 0x3f	; 63
    1acc:	f8 94       	cli
    1ace:	de bf       	out	0x3e, r29	; 62
    1ad0:	0f be       	out	0x3f, r0	; 63
    1ad2:	cd bf       	out	0x3d, r28	; 61
    1ad4:	df 91       	pop	r29
    1ad6:	cf 91       	pop	r28
    1ad8:	1f 91       	pop	r17
    1ada:	0f 91       	pop	r16
    1adc:	ff 90       	pop	r15
    1ade:	ef 90       	pop	r14
    1ae0:	df 90       	pop	r13
    1ae2:	bf 90       	pop	r11
    1ae4:	af 90       	pop	r10
    1ae6:	08 95       	ret
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1ae8:	c7 01       	movw	r24, r14
    1aea:	0e 94 82 0a 	call	0x1504	; 0x1504 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1aee:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1af2:	80 e0       	ldi	r24, 0x00	; 0
    1af4:	e9 cf       	rjmp	.-46     	; 0x1ac8 <xQueueGenericReceive+0x15c>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1af6:	17 83       	std	Z+7, r17	; 0x07
    1af8:	06 83       	std	Z+6, r16	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1afa:	83 89       	ldd	r24, Z+19	; 0x13
    1afc:	88 23       	and	r24, r24
    1afe:	21 f4       	brne	.+8      	; 0x1b08 <xQueueGenericReceive+0x19c>
						}
					}

				}

				taskEXIT_CRITICAL();
    1b00:	0f 90       	pop	r0
    1b02:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1b04:	81 e0       	ldi	r24, 0x01	; 1
    1b06:	e0 cf       	rjmp	.-64     	; 0x1ac8 <xQueueGenericReceive+0x15c>
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b08:	c7 01       	movw	r24, r14
    1b0a:	43 96       	adiw	r24, 0x13	; 19
    1b0c:	0e 94 02 13 	call	0x2604	; 0x2604 <xTaskRemoveFromEventList>
    1b10:	88 23       	and	r24, r24
    1b12:	b1 f3       	breq	.-20     	; 0x1b00 <xQueueGenericReceive+0x194>
    1b14:	d3 cf       	rjmp	.-90     	; 0x1abc <xQueueGenericReceive+0x150>
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1b16:	0e 94 e4 13 	call	0x27c8	; 0x27c8 <xTaskGetCurrentTaskHandle>
    1b1a:	f7 01       	movw	r30, r14
    1b1c:	93 83       	std	Z+3, r25	; 0x03
    1b1e:	82 83       	std	Z+2, r24	; 0x02
    1b20:	c3 cf       	rjmp	.-122    	; 0x1aa8 <xQueueGenericReceive+0x13c>

00001b22 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1b22:	0f 93       	push	r16
    1b24:	1f 93       	push	r17
    1b26:	cf 93       	push	r28
    1b28:	df 93       	push	r29
    1b2a:	ec 01       	movw	r28, r24
    1b2c:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1b2e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1b30:	88 23       	and	r24, r24
    1b32:	31 f4       	brne	.+12     	; 0x1b40 <xQueueReceiveFromISR+0x1e>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1b34:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1b36:	df 91       	pop	r29
    1b38:	cf 91       	pop	r28
    1b3a:	1f 91       	pop	r17
    1b3c:	0f 91       	pop	r16
    1b3e:	08 95       	ret
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b40:	ce 01       	movw	r24, r28
    1b42:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1b46:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1b48:	81 50       	subi	r24, 0x01	; 1
    1b4a:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1b4c:	89 a1       	lds	r24, 0x49
    1b4e:	8f 3f       	cpi	r24, 0xFF	; 255
    1b50:	41 f0       	breq	.+16     	; 0x1b62 <xQueueReceiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1b52:	8f 5f       	subi	r24, 0xFF	; 255
    1b54:	89 a3       	lds	r24, 0x59
			}

			xReturn = pdPASS;
    1b56:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1b58:	df 91       	pop	r29
    1b5a:	cf 91       	pop	r28
    1b5c:	1f 91       	pop	r17
    1b5e:	0f 91       	pop	r16
    1b60:	08 95       	ret
			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b62:	88 85       	ldd	r24, Y+8	; 0x08
    1b64:	88 23       	and	r24, r24
    1b66:	11 f4       	brne	.+4      	; 0x1b6c <xQueueReceiveFromISR+0x4a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1b68:	81 e0       	ldi	r24, 0x01	; 1
    1b6a:	e5 cf       	rjmp	.-54     	; 0x1b36 <xQueueReceiveFromISR+0x14>
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b6c:	ce 01       	movw	r24, r28
    1b6e:	08 96       	adiw	r24, 0x08	; 8
    1b70:	0e 94 02 13 	call	0x2604	; 0x2604 <xTaskRemoveFromEventList>
    1b74:	88 23       	and	r24, r24
    1b76:	c1 f3       	breq	.-16     	; 0x1b68 <xQueueReceiveFromISR+0x46>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1b78:	81 e0       	ldi	r24, 0x01	; 1
    1b7a:	f8 01       	movw	r30, r16
    1b7c:	80 83       	st	Z, r24
    1b7e:	db cf       	rjmp	.-74     	; 0x1b36 <xQueueReceiveFromISR+0x14>

00001b80 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1b80:	0f b6       	in	r0, 0x3f	; 63
    1b82:	f8 94       	cli
    1b84:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1b86:	fc 01       	movw	r30, r24
    1b88:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1b8a:	0f 90       	pop	r0
    1b8c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1b8e:	08 95       	ret

00001b90 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1b90:	fc 01       	movw	r30, r24
    1b92:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    1b94:	08 95       	ret

00001b96 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1b96:	cf 93       	push	r28
    1b98:	df 93       	push	r29
    1b9a:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1b9c:	88 81       	ld	r24, Y
    1b9e:	99 81       	ldd	r25, Y+1	; 0x01
    1ba0:	0e 94 cd 08 	call	0x119a	; 0x119a <vPortFree>
	vPortFree( pxQueue );
    1ba4:	ce 01       	movw	r24, r28
    1ba6:	0e 94 cd 08 	call	0x119a	; 0x119a <vPortFree>
}
    1baa:	df 91       	pop	r29
    1bac:	cf 91       	pop	r28
    1bae:	08 95       	ret

00001bb0 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1bb0:	fc 01       	movw	r30, r24
    1bb2:	96 8d       	ldd	r25, Z+30	; 0x1e
    1bb4:	81 e0       	ldi	r24, 0x01	; 1
    1bb6:	91 11       	cpse	r25, r1
    1bb8:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1bba:	08 95       	ret

00001bbc <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1bbc:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1bbe:	26 8d       	ldd	r18, Z+30	; 0x1e
    1bc0:	81 e0       	ldi	r24, 0x01	; 1
    1bc2:	97 8d       	ldd	r25, Z+31	; 0x1f
    1bc4:	29 13       	cpse	r18, r25
    1bc6:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1bc8:	08 95       	ret

00001bca <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1bca:	80 91 03 1a 	lds	r24, 0x1A03
    1bce:	82 30       	cpi	r24, 0x02	; 2
    1bd0:	e0 f3       	brcs	.-8      	; 0x1bca <prvIdleTask>
			{
				taskYIELD();
    1bd2:	0e 94 ac 09 	call	0x1358	; 0x1358 <vPortYield>
    1bd6:	f9 cf       	rjmp	.-14     	; 0x1bca <prvIdleTask>

00001bd8 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1bd8:	cf 92       	push	r12
    1bda:	df 92       	push	r13
    1bdc:	ef 92       	push	r14
    1bde:	ff 92       	push	r15
    1be0:	6b 01       	movw	r12, r22
    1be2:	7c 01       	movw	r14, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1be4:	e0 91 f2 19 	lds	r30, 0x19F2
    1be8:	f0 91 f3 19 	lds	r31, 0x19F3
    1bec:	62 83       	std	Z+2, r22	; 0x02
    1bee:	73 83       	std	Z+3, r23	; 0x03
    1bf0:	84 83       	std	Z+4, r24	; 0x04
    1bf2:	95 83       	std	Z+5, r25	; 0x05

	if( xTimeToWake < xTickCount )
    1bf4:	80 91 fa 19 	lds	r24, 0x19FA
    1bf8:	90 91 fb 19 	lds	r25, 0x19FB
    1bfc:	a0 91 fc 19 	lds	r26, 0x19FC
    1c00:	b0 91 fd 19 	lds	r27, 0x19FD
    1c04:	c8 16       	cp	r12, r24
    1c06:	d9 06       	cpc	r13, r25
    1c08:	ea 06       	cpc	r14, r26
    1c0a:	fb 06       	cpc	r15, r27
    1c0c:	30 f1       	brcs	.+76     	; 0x1c5a <prvAddCurrentTaskToDelayedList+0x82>
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1c0e:	80 91 01 1a 	lds	r24, 0x1A01
    1c12:	90 91 02 1a 	lds	r25, 0x1A02
    1c16:	60 91 f2 19 	lds	r22, 0x19F2
    1c1a:	70 91 f3 19 	lds	r23, 0x19F3
    1c1e:	6e 5f       	subi	r22, 0xFE	; 254
    1c20:	7f 4f       	sbci	r23, 0xFF	; 255
    1c22:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1c26:	80 91 95 02 	lds	r24, 0x0295
    1c2a:	90 91 96 02 	lds	r25, 0x0296
    1c2e:	a0 91 97 02 	lds	r26, 0x0297
    1c32:	b0 91 98 02 	lds	r27, 0x0298
    1c36:	c8 16       	cp	r12, r24
    1c38:	d9 06       	cpc	r13, r25
    1c3a:	ea 06       	cpc	r14, r26
    1c3c:	fb 06       	cpc	r15, r27
    1c3e:	40 f4       	brcc	.+16     	; 0x1c50 <prvAddCurrentTaskToDelayedList+0x78>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1c40:	c0 92 95 02 	sts	0x0295, r12
    1c44:	d0 92 96 02 	sts	0x0296, r13
    1c48:	e0 92 97 02 	sts	0x0297, r14
    1c4c:	f0 92 98 02 	sts	0x0298, r15
		}
	}
}
    1c50:	ff 90       	pop	r15
    1c52:	ef 90       	pop	r14
    1c54:	df 90       	pop	r13
    1c56:	cf 90       	pop	r12
    1c58:	08 95       	ret
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1c5a:	80 91 ff 19 	lds	r24, 0x19FF
    1c5e:	90 91 00 1a 	lds	r25, 0x1A00
    1c62:	60 91 f2 19 	lds	r22, 0x19F2
    1c66:	70 91 f3 19 	lds	r23, 0x19F3
    1c6a:	6e 5f       	subi	r22, 0xFE	; 254
    1c6c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c6e:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <vListInsert>
		if( xTimeToWake < xNextTaskUnblockTime )
		{
			xNextTaskUnblockTime = xTimeToWake;
		}
	}
}
    1c72:	ff 90       	pop	r15
    1c74:	ef 90       	pop	r14
    1c76:	df 90       	pop	r13
    1c78:	cf 90       	pop	r12
    1c7a:	08 95       	ret

00001c7c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1c7c:	4f 92       	push	r4
    1c7e:	5f 92       	push	r5
    1c80:	6f 92       	push	r6
    1c82:	7f 92       	push	r7
    1c84:	8f 92       	push	r8
    1c86:	9f 92       	push	r9
    1c88:	af 92       	push	r10
    1c8a:	bf 92       	push	r11
    1c8c:	cf 92       	push	r12
    1c8e:	df 92       	push	r13
    1c90:	ef 92       	push	r14
    1c92:	ff 92       	push	r15
    1c94:	0f 93       	push	r16
    1c96:	1f 93       	push	r17
    1c98:	cf 93       	push	r28
    1c9a:	df 93       	push	r29
    1c9c:	2c 01       	movw	r4, r24
    1c9e:	4b 01       	movw	r8, r22
    1ca0:	5a 01       	movw	r10, r20
    1ca2:	39 01       	movw	r6, r18
    1ca4:	d0 2f       	mov	r29, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1ca6:	88 e2       	ldi	r24, 0x28	; 40
    1ca8:	90 e0       	ldi	r25, 0x00	; 0
    1caa:	0e 94 a1 08 	call	0x1142	; 0x1142 <pvPortMalloc>
    1cae:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    1cb0:	00 97       	sbiw	r24, 0x00	; 0
    1cb2:	09 f4       	brne	.+2      	; 0x1cb6 <xTaskGenericCreate+0x3a>
    1cb4:	ba c0       	rjmp	.+372    	; 0x1e2a <xTaskGenericCreate+0x1ae>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1cb6:	c1 14       	cp	r12, r1
    1cb8:	d1 04       	cpc	r13, r1
    1cba:	09 f4       	brne	.+2      	; 0x1cbe <xTaskGenericCreate+0x42>
    1cbc:	f7 c0       	rjmp	.+494    	; 0x1eac <xTaskGenericCreate+0x230>
    1cbe:	fc 01       	movw	r30, r24
    1cc0:	d4 8e       	std	Z+28, r13	; 0x1c
    1cc2:	c3 8e       	std	Z+27, r12	; 0x1b
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    1cc4:	c6 01       	movw	r24, r12
    1cc6:	61 e1       	ldi	r22, 0x11	; 17
    1cc8:	70 e0       	ldi	r23, 0x00	; 0
    1cca:	a5 01       	movw	r20, r10
    1ccc:	0e 94 80 16 	call	0x2d00	; 0x2d00 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1cd0:	c5 01       	movw	r24, r10
    1cd2:	01 97       	sbiw	r24, 0x01	; 1
    1cd4:	f8 01       	movw	r30, r16
    1cd6:	c3 8c       	ldd	r12, Z+27	; 0x1b
    1cd8:	d4 8c       	ldd	r13, Z+28	; 0x1c
    1cda:	c8 0e       	add	r12, r24
    1cdc:	d9 1e       	adc	r13, r25
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1cde:	c8 01       	movw	r24, r16
    1ce0:	4d 96       	adiw	r24, 0x1d	; 29
    1ce2:	b4 01       	movw	r22, r8
    1ce4:	4a e0       	ldi	r20, 0x0A	; 10
    1ce6:	50 e0       	ldi	r21, 0x00	; 0
    1ce8:	0e 94 87 16 	call	0x2d0e	; 0x2d0e <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1cec:	f8 01       	movw	r30, r16
    1cee:	16 a2       	lds	r17, 0x96
    1cf0:	cd 2f       	mov	r28, r29
    1cf2:	d4 30       	cpi	r29, 0x04	; 4
    1cf4:	08 f0       	brcs	.+2      	; 0x1cf8 <xTaskGenericCreate+0x7c>
    1cf6:	93 c0       	rjmp	.+294    	; 0x1e1e <xTaskGenericCreate+0x1a2>
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    1cf8:	f8 01       	movw	r30, r16
    1cfa:	c2 8f       	std	Z+26, r28	; 0x1a
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    1cfc:	c7 a3       	lds	r28, 0x57
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1cfe:	b2 e0       	ldi	r27, 0x02	; 2
    1d00:	ab 2e       	mov	r10, r27
    1d02:	b1 2c       	mov	r11, r1
    1d04:	a0 0e       	add	r10, r16
    1d06:	b1 1e       	adc	r11, r17
    1d08:	c5 01       	movw	r24, r10
    1d0a:	0e 94 37 15 	call	0x2a6e	; 0x2a6e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1d0e:	c8 01       	movw	r24, r16
    1d10:	0e 96       	adiw	r24, 0x0e	; 14
    1d12:	0e 94 37 15 	call	0x2a6e	; 0x2a6e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1d16:	f8 01       	movw	r30, r16
    1d18:	13 87       	std	Z+11, r17	; 0x0b
    1d1a:	02 87       	std	Z+10, r16	; 0x0a

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1d1c:	84 e0       	ldi	r24, 0x04	; 4
    1d1e:	90 e0       	ldi	r25, 0x00	; 0
    1d20:	a0 e0       	ldi	r26, 0x00	; 0
    1d22:	b0 e0       	ldi	r27, 0x00	; 0
    1d24:	8c 1b       	sub	r24, r28
    1d26:	91 09       	sbc	r25, r1
    1d28:	a1 09       	sbc	r26, r1
    1d2a:	b1 09       	sbc	r27, r1
    1d2c:	86 87       	std	Z+14, r24	; 0x0e
    1d2e:	97 87       	std	Z+15, r25	; 0x0f
    1d30:	a0 8b       	std	Z+16, r26	; 0x10
    1d32:	b1 8b       	std	Z+17, r27	; 0x11
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1d34:	17 8b       	std	Z+23, r17	; 0x17
    1d36:	06 8b       	std	Z+22, r16	; 0x16
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1d38:	c6 01       	movw	r24, r12
    1d3a:	b2 01       	movw	r22, r4
    1d3c:	a3 01       	movw	r20, r6
    1d3e:	0e 94 dc 08 	call	0x11b8	; 0x11b8 <pxPortInitialiseStack>
    1d42:	f8 01       	movw	r30, r16
    1d44:	91 83       	std	Z+1, r25	; 0x01
    1d46:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    1d48:	e1 14       	cp	r14, r1
    1d4a:	f1 04       	cpc	r15, r1
    1d4c:	19 f0       	breq	.+6      	; 0x1d54 <xTaskGenericCreate+0xd8>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1d4e:	f7 01       	movw	r30, r14
    1d50:	11 83       	std	Z+1, r17	; 0x01
    1d52:	00 83       	st	Z, r16
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1d54:	0f b6       	in	r0, 0x3f	; 63
    1d56:	f8 94       	cli
    1d58:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1d5a:	80 91 fe 19 	lds	r24, 0x19FE
    1d5e:	8f 5f       	subi	r24, 0xFF	; 255
    1d60:	80 93 fe 19 	sts	0x19FE, r24
			if( pxCurrentTCB == NULL )
    1d64:	80 91 f2 19 	lds	r24, 0x19F2
    1d68:	90 91 f3 19 	lds	r25, 0x19F3
    1d6c:	00 97       	sbiw	r24, 0x00	; 0
    1d6e:	09 f4       	brne	.+2      	; 0x1d72 <xTaskGenericCreate+0xf6>
    1d70:	5e c0       	rjmp	.+188    	; 0x1e2e <xTaskGenericCreate+0x1b2>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1d72:	80 91 f8 19 	lds	r24, 0x19F8
    1d76:	88 23       	and	r24, r24
    1d78:	59 f4       	brne	.+22     	; 0x1d90 <xTaskGenericCreate+0x114>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1d7a:	e0 91 f2 19 	lds	r30, 0x19F2
    1d7e:	f0 91 f3 19 	lds	r31, 0x19F3
    1d82:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d84:	d8 17       	cp	r29, r24
    1d86:	20 f0       	brcs	.+8      	; 0x1d90 <xTaskGenericCreate+0x114>
					{
						pxCurrentTCB = pxNewTCB;
    1d88:	10 93 f3 19 	sts	0x19F3, r17
    1d8c:	00 93 f2 19 	sts	0x19F2, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1d90:	f8 01       	movw	r30, r16
    1d92:	22 8d       	ldd	r18, Z+26	; 0x1a
    1d94:	80 91 50 1a 	lds	r24, 0x1A50
    1d98:	82 17       	cp	r24, r18
    1d9a:	10 f4       	brcc	.+4      	; 0x1da0 <xTaskGenericCreate+0x124>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1d9c:	20 93 50 1a 	sts	0x1A50, r18
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1da0:	80 91 51 1a 	lds	r24, 0x1A51
    1da4:	8f 5f       	subi	r24, 0xFF	; 255
    1da6:	80 93 51 1a 	sts	0x1A51, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1daa:	80 91 f9 19 	lds	r24, 0x19F9
    1dae:	82 17       	cp	r24, r18
    1db0:	98 f1       	brcs	.+102    	; 0x1e18 <xTaskGenericCreate+0x19c>
    1db2:	30 e0       	ldi	r19, 0x00	; 0
    1db4:	c9 01       	movw	r24, r18
    1db6:	88 0f       	add	r24, r24
    1db8:	99 1f       	adc	r25, r25
    1dba:	a9 01       	movw	r20, r18
    1dbc:	44 0f       	add	r20, r20
    1dbe:	55 1f       	adc	r21, r21
    1dc0:	44 0f       	add	r20, r20
    1dc2:	55 1f       	adc	r21, r21
    1dc4:	44 0f       	add	r20, r20
    1dc6:	55 1f       	adc	r21, r21
    1dc8:	84 0f       	add	r24, r20
    1dca:	95 1f       	adc	r25, r21
    1dcc:	82 0f       	add	r24, r18
    1dce:	93 1f       	adc	r25, r19
    1dd0:	8d 5f       	subi	r24, 0xFD	; 253
    1dd2:	95 4e       	sbci	r25, 0xE5	; 229
    1dd4:	b5 01       	movw	r22, r10
    1dd6:	0e 94 3b 15 	call	0x2a76	; 0x2a76 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1dda:	0f 90       	pop	r0
    1ddc:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1dde:	80 91 f8 19 	lds	r24, 0x19F8
    1de2:	88 23       	and	r24, r24
    1de4:	39 f0       	breq	.+14     	; 0x1df4 <xTaskGenericCreate+0x178>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1de6:	e0 91 f2 19 	lds	r30, 0x19F2
    1dea:	f0 91 f3 19 	lds	r31, 0x19F3
    1dee:	82 8d       	ldd	r24, Z+26	; 0x1a
    1df0:	8d 17       	cp	r24, r29
    1df2:	b8 f0       	brcs	.+46     	; 0x1e22 <xTaskGenericCreate+0x1a6>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1df4:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    1df6:	df 91       	pop	r29
    1df8:	cf 91       	pop	r28
    1dfa:	1f 91       	pop	r17
    1dfc:	0f 91       	pop	r16
    1dfe:	ff 90       	pop	r15
    1e00:	ef 90       	pop	r14
    1e02:	df 90       	pop	r13
    1e04:	cf 90       	pop	r12
    1e06:	bf 90       	pop	r11
    1e08:	af 90       	pop	r10
    1e0a:	9f 90       	pop	r9
    1e0c:	8f 90       	pop	r8
    1e0e:	7f 90       	pop	r7
    1e10:	6f 90       	pop	r6
    1e12:	5f 90       	pop	r5
    1e14:	4f 90       	pop	r4
    1e16:	08 95       	ret
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );
    1e18:	20 93 f9 19 	sts	0x19F9, r18
    1e1c:	ca cf       	rjmp	.-108    	; 0x1db2 <xTaskGenericCreate+0x136>
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1e1e:	c3 e0       	ldi	r28, 0x03	; 3
    1e20:	6b cf       	rjmp	.-298    	; 0x1cf8 <xTaskGenericCreate+0x7c>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
			{
				portYIELD_WITHIN_API();
    1e22:	0e 94 ac 09 	call	0x1358	; 0x1358 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1e26:	81 e0       	ldi	r24, 0x01	; 1
    1e28:	e6 cf       	rjmp	.-52     	; 0x1df6 <xTaskGenericCreate+0x17a>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1e2a:	8f ef       	ldi	r24, 0xFF	; 255
    1e2c:	e4 cf       	rjmp	.-56     	; 0x1df6 <xTaskGenericCreate+0x17a>
			uxCurrentNumberOfTasks++;
			if( pxCurrentTCB == NULL )
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1e2e:	10 93 f3 19 	sts	0x19F3, r17
    1e32:	00 93 f2 19 	sts	0x19F2, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1e36:	80 91 fe 19 	lds	r24, 0x19FE
    1e3a:	81 30       	cpi	r24, 0x01	; 1
    1e3c:	09 f0       	breq	.+2      	; 0x1e40 <xTaskGenericCreate+0x1c4>
    1e3e:	a8 cf       	rjmp	.-176    	; 0x1d90 <xTaskGenericCreate+0x114>
    1e40:	cc 24       	eor	r12, r12
    1e42:	dd 24       	eor	r13, r13
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    1e44:	c6 01       	movw	r24, r12
    1e46:	88 0f       	add	r24, r24
    1e48:	99 1f       	adc	r25, r25
    1e4a:	96 01       	movw	r18, r12
    1e4c:	22 0f       	add	r18, r18
    1e4e:	33 1f       	adc	r19, r19
    1e50:	22 0f       	add	r18, r18
    1e52:	33 1f       	adc	r19, r19
    1e54:	22 0f       	add	r18, r18
    1e56:	33 1f       	adc	r19, r19
    1e58:	82 0f       	add	r24, r18
    1e5a:	93 1f       	adc	r25, r19
    1e5c:	8c 0d       	add	r24, r12
    1e5e:	9d 1d       	adc	r25, r13
    1e60:	8d 5f       	subi	r24, 0xFD	; 253
    1e62:	95 4e       	sbci	r25, 0xE5	; 229
    1e64:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <vListInitialise>
    1e68:	08 94       	sec
    1e6a:	c1 1c       	adc	r12, r1
    1e6c:	d1 1c       	adc	r13, r1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    1e6e:	f4 e0       	ldi	r31, 0x04	; 4
    1e70:	cf 16       	cp	r12, r31
    1e72:	d1 04       	cpc	r13, r1
    1e74:	39 f7       	brne	.-50     	; 0x1e44 <xTaskGenericCreate+0x1c8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    1e76:	7f e2       	ldi	r23, 0x2F	; 47
    1e78:	e7 2e       	mov	r14, r23
    1e7a:	7a e1       	ldi	r23, 0x1A	; 26
    1e7c:	f7 2e       	mov	r15, r23
    1e7e:	c7 01       	movw	r24, r14
    1e80:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1e84:	ea e3       	ldi	r30, 0x3A	; 58
    1e86:	ce 2e       	mov	r12, r30
    1e88:	ea e1       	ldi	r30, 0x1A	; 26
    1e8a:	de 2e       	mov	r13, r30
    1e8c:	c6 01       	movw	r24, r12
    1e8e:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    1e92:	85 e4       	ldi	r24, 0x45	; 69
    1e94:	9a e1       	ldi	r25, 0x1A	; 26
    1e96:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1e9a:	f0 92 02 1a 	sts	0x1A02, r15
    1e9e:	e0 92 01 1a 	sts	0x1A01, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1ea2:	d0 92 00 1a 	sts	0x1A00, r13
    1ea6:	c0 92 ff 19 	sts	0x19FF, r12
    1eaa:	72 cf       	rjmp	.-284    	; 0x1d90 <xTaskGenericCreate+0x114>
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1eac:	c5 01       	movw	r24, r10
    1eae:	0e 94 a1 08 	call	0x1142	; 0x1142 <pvPortMalloc>
    1eb2:	6c 01       	movw	r12, r24
    1eb4:	f8 01       	movw	r30, r16
    1eb6:	94 8f       	std	Z+28, r25	; 0x1c
    1eb8:	83 8f       	std	Z+27, r24	; 0x1b

		if( pxNewTCB->pxStack == NULL )
    1eba:	00 97       	sbiw	r24, 0x00	; 0
    1ebc:	09 f0       	breq	.+2      	; 0x1ec0 <xTaskGenericCreate+0x244>
    1ebe:	02 cf       	rjmp	.-508    	; 0x1cc4 <xTaskGenericCreate+0x48>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1ec0:	c8 01       	movw	r24, r16
    1ec2:	0e 94 cd 08 	call	0x119a	; 0x119a <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1ec6:	8f ef       	ldi	r24, 0xFF	; 255
    1ec8:	96 cf       	rjmp	.-212    	; 0x1df6 <xTaskGenericCreate+0x17a>

00001eca <uxTaskPriorityGet>:
	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
    1eca:	0f b6       	in	r0, 0x3f	; 63
    1ecc:	f8 94       	cli
    1ece:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1ed0:	00 97       	sbiw	r24, 0x00	; 0
    1ed2:	29 f0       	breq	.+10     	; 0x1ede <uxTaskPriorityGet+0x14>
    1ed4:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    1ed6:	0f 90       	pop	r0
    1ed8:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    1eda:	82 8d       	ldd	r24, Z+26	; 0x1a
    1edc:	08 95       	ret

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1ede:	e0 91 f2 19 	lds	r30, 0x19F2
    1ee2:	f0 91 f3 19 	lds	r31, 0x19F3
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    1ee6:	0f 90       	pop	r0
    1ee8:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    1eea:	82 8d       	ldd	r24, Z+26	; 0x1a
    1eec:	08 95       	ret

00001eee <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    1eee:	ef 92       	push	r14
    1ef0:	ff 92       	push	r15
    1ef2:	1f 93       	push	r17
    1ef4:	cf 93       	push	r28
    1ef6:	df 93       	push	r29
    1ef8:	e6 2f       	mov	r30, r22
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1efa:	64 30       	cpi	r22, 0x04	; 4
    1efc:	08 f0       	brcs	.+2      	; 0x1f00 <vTaskPrioritySet+0x12>
    1efe:	e3 e0       	ldi	r30, 0x03	; 3
		if( uxNewPriority >= configMAX_PRIORITIES )
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
		}

		taskENTER_CRITICAL();
    1f00:	0f b6       	in	r0, 0x3f	; 63
    1f02:	f8 94       	cli
    1f04:	0f 92       	push	r0
		{
			if( pxTask == pxCurrentTCB )
    1f06:	20 91 f2 19 	lds	r18, 0x19F2
    1f0a:	30 91 f3 19 	lds	r19, 0x19F3
    1f0e:	82 17       	cp	r24, r18
    1f10:	93 07       	cpc	r25, r19
    1f12:	09 f4       	brne	.+2      	; 0x1f16 <vTaskPrioritySet+0x28>
    1f14:	48 c0       	rjmp	.+144    	; 0x1fa6 <vTaskPrioritySet+0xb8>
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1f16:	00 97       	sbiw	r24, 0x00	; 0
    1f18:	09 f4       	brne	.+2      	; 0x1f1c <vTaskPrioritySet+0x2e>
    1f1a:	45 c0       	rjmp	.+138    	; 0x1fa6 <vTaskPrioritySet+0xb8>
    1f1c:	ec 01       	movw	r28, r24

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
    1f1e:	2f a1       	lds	r18, 0x4f
			{
				uxCurrentPriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    1f20:	2e 17       	cp	r18, r30
    1f22:	71 f1       	breq	.+92     	; 0x1f80 <vTaskPrioritySet+0x92>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    1f24:	11 e0       	ldi	r17, 0x01	; 1

			if( uxCurrentPriority != uxNewPriority )
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    1f26:	2e 17       	cp	r18, r30
    1f28:	98 f5       	brcc	.+102    	; 0x1f90 <vTaskPrioritySet+0xa2>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    1f2a:	00 97       	sbiw	r24, 0x00	; 0
    1f2c:	99 f1       	breq	.+102    	; 0x1f94 <vTaskPrioritySet+0xa6>

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    1f2e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f30:	28 17       	cp	r18, r24
    1f32:	a1 f1       	breq	.+104    	; 0x1f9c <vTaskPrioritySet+0xae>
					{
						pxTCB->uxPriority = uxNewPriority;
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    1f34:	ef a3       	lds	r30, 0x5f
				{
					pxTCB->uxPriority = uxNewPriority;
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    1f36:	44 e0       	ldi	r20, 0x04	; 4
    1f38:	50 e0       	ldi	r21, 0x00	; 0
    1f3a:	60 e0       	ldi	r22, 0x00	; 0
    1f3c:	70 e0       	ldi	r23, 0x00	; 0
    1f3e:	4e 1b       	sub	r20, r30
    1f40:	51 09       	sbc	r21, r1
    1f42:	61 09       	sbc	r22, r1
    1f44:	71 09       	sbc	r23, r1
    1f46:	4e 87       	std	Y+14, r20	; 0x0e
    1f48:	5f 87       	std	Y+15, r21	; 0x0f
    1f4a:	68 8b       	std	Y+16, r22	; 0x10
    1f4c:	79 8b       	std	Y+17, r23	; 0x11

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    1f4e:	82 2f       	mov	r24, r18
    1f50:	90 e0       	ldi	r25, 0x00	; 0
    1f52:	ac 01       	movw	r20, r24
    1f54:	44 0f       	add	r20, r20
    1f56:	55 1f       	adc	r21, r21
    1f58:	9c 01       	movw	r18, r24
    1f5a:	22 0f       	add	r18, r18
    1f5c:	33 1f       	adc	r19, r19
    1f5e:	22 0f       	add	r18, r18
    1f60:	33 1f       	adc	r19, r19
    1f62:	22 0f       	add	r18, r18
    1f64:	33 1f       	adc	r19, r19
    1f66:	42 0f       	add	r20, r18
    1f68:	53 1f       	adc	r21, r19
    1f6a:	48 0f       	add	r20, r24
    1f6c:	59 1f       	adc	r21, r25
    1f6e:	4d 5f       	subi	r20, 0xFD	; 253
    1f70:	55 4e       	sbci	r21, 0xE5	; 229
    1f72:	8c 85       	ldd	r24, Y+12	; 0x0c
    1f74:	9d 85       	ldd	r25, Y+13	; 0x0d
    1f76:	84 17       	cp	r24, r20
    1f78:	95 07       	cpc	r25, r21
    1f7a:	e1 f0       	breq	.+56     	; 0x1fb4 <vTaskPrioritySet+0xc6>
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
				}

				if( xYieldRequired == pdTRUE )
    1f7c:	11 30       	cpi	r17, 0x01	; 1
    1f7e:	81 f0       	breq	.+32     	; 0x1fa0 <vTaskPrioritySet+0xb2>
				{
					portYIELD_WITHIN_API();
				}
			}
		}
		taskEXIT_CRITICAL();
    1f80:	0f 90       	pop	r0
    1f82:	0f be       	out	0x3f, r0	; 63
	}
    1f84:	df 91       	pop	r29
    1f86:	cf 91       	pop	r28
    1f88:	1f 91       	pop	r17
    1f8a:	ff 90       	pop	r15
    1f8c:	ef 90       	pop	r14
    1f8e:	08 95       	ret
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    1f90:	00 97       	sbiw	r24, 0x00	; 0
    1f92:	69 f2       	breq	.-102    	; 0x1f2e <vTaskPrioritySet+0x40>
    1f94:	10 e0       	ldi	r17, 0x00	; 0

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    1f96:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f98:	28 17       	cp	r18, r24
    1f9a:	61 f6       	brne	.-104    	; 0x1f34 <vTaskPrioritySet+0x46>
					{
						pxTCB->uxPriority = uxNewPriority;
    1f9c:	ea 8f       	std	Y+26, r30	; 0x1a
    1f9e:	ca cf       	rjmp	.-108    	; 0x1f34 <vTaskPrioritySet+0x46>
					prvAddTaskToReadyQueue( pxTCB );
				}

				if( xYieldRequired == pdTRUE )
				{
					portYIELD_WITHIN_API();
    1fa0:	0e 94 ac 09 	call	0x1358	; 0x1358 <vPortYield>
    1fa4:	ed cf       	rjmp	.-38     	; 0x1f80 <vTaskPrioritySet+0x92>
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1fa6:	c0 91 f2 19 	lds	r28, 0x19F2
    1faa:	d0 91 f3 19 	lds	r29, 0x19F3
    1fae:	80 e0       	ldi	r24, 0x00	; 0
    1fb0:	90 e0       	ldi	r25, 0x00	; 0
    1fb2:	b5 cf       	rjmp	.-150    	; 0x1f1e <vTaskPrioritySet+0x30>
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    1fb4:	82 e0       	ldi	r24, 0x02	; 2
    1fb6:	e8 2e       	mov	r14, r24
    1fb8:	f1 2c       	mov	r15, r1
    1fba:	ec 0e       	add	r14, r28
    1fbc:	fd 1e       	adc	r15, r29
    1fbe:	c7 01       	movw	r24, r14
    1fc0:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1fc4:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1fc6:	80 91 f9 19 	lds	r24, 0x19F9
    1fca:	82 17       	cp	r24, r18
    1fcc:	10 f4       	brcc	.+4      	; 0x1fd2 <vTaskPrioritySet+0xe4>
    1fce:	20 93 f9 19 	sts	0x19F9, r18
    1fd2:	30 e0       	ldi	r19, 0x00	; 0
    1fd4:	c9 01       	movw	r24, r18
    1fd6:	88 0f       	add	r24, r24
    1fd8:	99 1f       	adc	r25, r25
    1fda:	a9 01       	movw	r20, r18
    1fdc:	44 0f       	add	r20, r20
    1fde:	55 1f       	adc	r21, r21
    1fe0:	44 0f       	add	r20, r20
    1fe2:	55 1f       	adc	r21, r21
    1fe4:	44 0f       	add	r20, r20
    1fe6:	55 1f       	adc	r21, r21
    1fe8:	84 0f       	add	r24, r20
    1fea:	95 1f       	adc	r25, r21
    1fec:	82 0f       	add	r24, r18
    1fee:	93 1f       	adc	r25, r19
    1ff0:	8d 5f       	subi	r24, 0xFD	; 253
    1ff2:	95 4e       	sbci	r25, 0xE5	; 229
    1ff4:	b7 01       	movw	r22, r14
    1ff6:	0e 94 3b 15 	call	0x2a76	; 0x2a76 <vListInsertEnd>
    1ffa:	c0 cf       	rjmp	.-128    	; 0x1f7c <vTaskPrioritySet+0x8e>

00001ffc <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1ffc:	af 92       	push	r10
    1ffe:	bf 92       	push	r11
    2000:	cf 92       	push	r12
    2002:	df 92       	push	r13
    2004:	ef 92       	push	r14
    2006:	ff 92       	push	r15
    2008:	0f 93       	push	r16
	/* Add the idle task at the lowest priority. */
	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
	{
		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
		be returned by the xTaskGetIdleTaskHandle() function. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
    200a:	85 ee       	ldi	r24, 0xE5	; 229
    200c:	9d e0       	ldi	r25, 0x0D	; 13
    200e:	60 e9       	ldi	r22, 0x90	; 144
    2010:	72 e0       	ldi	r23, 0x02	; 2
    2012:	44 e6       	ldi	r20, 0x64	; 100
    2014:	50 e0       	ldi	r21, 0x00	; 0
    2016:	20 e0       	ldi	r18, 0x00	; 0
    2018:	30 e0       	ldi	r19, 0x00	; 0
    201a:	00 e0       	ldi	r16, 0x00	; 0
    201c:	f2 e5       	ldi	r31, 0x52	; 82
    201e:	ef 2e       	mov	r14, r31
    2020:	fa e1       	ldi	r31, 0x1A	; 26
    2022:	ff 2e       	mov	r15, r31
    2024:	cc 24       	eor	r12, r12
    2026:	dd 24       	eor	r13, r13
    2028:	aa 24       	eor	r10, r10
    202a:	bb 24       	eor	r11, r11
    202c:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    2030:	81 30       	cpi	r24, 0x01	; 1
    2032:	41 f0       	breq	.+16     	; 0x2044 <vTaskStartScheduler+0x48>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    2034:	0f 91       	pop	r16
    2036:	ff 90       	pop	r15
    2038:	ef 90       	pop	r14
    203a:	df 90       	pop	r13
    203c:	cf 90       	pop	r12
    203e:	bf 90       	pop	r11
    2040:	af 90       	pop	r10
    2042:	08 95       	ret
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2044:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2046:	80 93 f8 19 	sts	0x19F8, r24
		xTickCount = ( portTickType ) 0U;
    204a:	10 92 fa 19 	sts	0x19FA, r1
    204e:	10 92 fb 19 	sts	0x19FB, r1
    2052:	10 92 fc 19 	sts	0x19FC, r1
    2056:	10 92 fd 19 	sts	0x19FD, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    205a:	0e 94 70 09 	call	0x12e0	; 0x12e0 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    205e:	0f 91       	pop	r16
    2060:	ff 90       	pop	r15
    2062:	ef 90       	pop	r14
    2064:	df 90       	pop	r13
    2066:	cf 90       	pop	r12
    2068:	bf 90       	pop	r11
    206a:	af 90       	pop	r10
    206c:	08 95       	ret

0000206e <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    206e:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2070:	10 92 f8 19 	sts	0x19F8, r1
	vPortEndScheduler();
    2074:	0e 94 ab 09 	call	0x1356	; 0x1356 <vPortEndScheduler>
}
    2078:	08 95       	ret

0000207a <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    207a:	80 91 f7 19 	lds	r24, 0x19F7
    207e:	8f 5f       	subi	r24, 0xFF	; 255
    2080:	80 93 f7 19 	sts	0x19F7, r24
}
    2084:	08 95       	ret

00002086 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    2086:	0f 93       	push	r16
    2088:	1f 93       	push	r17
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    208a:	0f b6       	in	r0, 0x3f	; 63
    208c:	f8 94       	cli
    208e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2090:	00 91 fa 19 	lds	r16, 0x19FA
    2094:	10 91 fb 19 	lds	r17, 0x19FB
    2098:	20 91 fc 19 	lds	r18, 0x19FC
    209c:	30 91 fd 19 	lds	r19, 0x19FD
	}
	taskEXIT_CRITICAL();
    20a0:	0f 90       	pop	r0
    20a2:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    20a4:	b8 01       	movw	r22, r16
    20a6:	c9 01       	movw	r24, r18
    20a8:	1f 91       	pop	r17
    20aa:	0f 91       	pop	r16
    20ac:	08 95       	ret

000020ae <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    20ae:	0f 93       	push	r16
    20b0:	1f 93       	push	r17
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    20b2:	00 91 fa 19 	lds	r16, 0x19FA
    20b6:	10 91 fb 19 	lds	r17, 0x19FB
    20ba:	20 91 fc 19 	lds	r18, 0x19FC
    20be:	30 91 fd 19 	lds	r19, 0x19FD
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    20c2:	b8 01       	movw	r22, r16
    20c4:	c9 01       	movw	r24, r18
    20c6:	1f 91       	pop	r17
    20c8:	0f 91       	pop	r16
    20ca:	08 95       	ret

000020cc <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    20cc:	80 91 fe 19 	lds	r24, 0x19FE
}
    20d0:	08 95       	ret

000020d2 <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    20d2:	00 97       	sbiw	r24, 0x00	; 0
    20d4:	11 f0       	breq	.+4      	; 0x20da <pcTaskGetTaskName+0x8>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
    20d6:	4d 96       	adiw	r24, 0x1d	; 29
	}
    20d8:	08 95       	ret
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    20da:	80 91 f2 19 	lds	r24, 0x19F2
    20de:	90 91 f3 19 	lds	r25, 0x19F3
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
    20e2:	4d 96       	adiw	r24, 0x1d	; 29
	}
    20e4:	08 95       	ret

000020e6 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    20e6:	80 91 52 1a 	lds	r24, 0x1A52
    20ea:	90 91 53 1a 	lds	r25, 0x1A53
    20ee:	08 95       	ret

000020f0 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    20f0:	0f 93       	push	r16
    20f2:	1f 93       	push	r17
    20f4:	cf 93       	push	r28
    20f6:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    20f8:	80 91 f7 19 	lds	r24, 0x19F7
    20fc:	88 23       	and	r24, r24
    20fe:	09 f0       	breq	.+2      	; 0x2102 <vTaskIncrementTick+0x12>
    2100:	93 c0       	rjmp	.+294    	; 0x2228 <__stack+0x29>
	{
		++xTickCount;
    2102:	80 91 fa 19 	lds	r24, 0x19FA
    2106:	90 91 fb 19 	lds	r25, 0x19FB
    210a:	a0 91 fc 19 	lds	r26, 0x19FC
    210e:	b0 91 fd 19 	lds	r27, 0x19FD
    2112:	01 96       	adiw	r24, 0x01	; 1
    2114:	a1 1d       	adc	r26, r1
    2116:	b1 1d       	adc	r27, r1
    2118:	80 93 fa 19 	sts	0x19FA, r24
    211c:	90 93 fb 19 	sts	0x19FB, r25
    2120:	a0 93 fc 19 	sts	0x19FC, r26
    2124:	b0 93 fd 19 	sts	0x19FD, r27
		if( xTickCount == ( portTickType ) 0U )
    2128:	80 91 fa 19 	lds	r24, 0x19FA
    212c:	90 91 fb 19 	lds	r25, 0x19FB
    2130:	a0 91 fc 19 	lds	r26, 0x19FC
    2134:	b0 91 fd 19 	lds	r27, 0x19FD
    2138:	00 97       	sbiw	r24, 0x00	; 0
    213a:	a1 05       	cpc	r26, r1
    213c:	b1 05       	cpc	r27, r1
    213e:	09 f4       	brne	.+2      	; 0x2142 <vTaskIncrementTick+0x52>
    2140:	7d c0       	rjmp	.+250    	; 0x223c <__stack+0x3d>
    2142:	80 91 95 02 	lds	r24, 0x0295
    2146:	90 91 96 02 	lds	r25, 0x0296
    214a:	a0 91 97 02 	lds	r26, 0x0297
    214e:	b0 91 98 02 	lds	r27, 0x0298
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2152:	40 91 fa 19 	lds	r20, 0x19FA
    2156:	50 91 fb 19 	lds	r21, 0x19FB
    215a:	60 91 fc 19 	lds	r22, 0x19FC
    215e:	70 91 fd 19 	lds	r23, 0x19FD
    2162:	48 17       	cp	r20, r24
    2164:	59 07       	cpc	r21, r25
    2166:	6a 07       	cpc	r22, r26
    2168:	7b 07       	cpc	r23, r27
    216a:	08 f0       	brcs	.+2      	; 0x216e <vTaskIncrementTick+0x7e>
    216c:	45 c0       	rjmp	.+138    	; 0x21f8 <vTaskIncrementTick+0x108>
    216e:	61 c0       	rjmp	.+194    	; 0x2232 <__stack+0x33>
    2170:	e0 91 01 1a 	lds	r30, 0x1A01
    2174:	f0 91 02 1a 	lds	r31, 0x1A02
    2178:	07 80       	ldd	r0, Z+7	; 0x07
    217a:	f0 85       	ldd	r31, Z+8	; 0x08
    217c:	e0 2d       	mov	r30, r0
    217e:	c0 85       	ldd	r28, Z+8	; 0x08
    2180:	d1 85       	ldd	r29, Z+9	; 0x09
    2182:	8a 81       	ldd	r24, Y+2	; 0x02
    2184:	9b 81       	ldd	r25, Y+3	; 0x03
    2186:	ac 81       	ldd	r26, Y+4	; 0x04
    2188:	bd 81       	ldd	r27, Y+5	; 0x05
    218a:	40 91 fa 19 	lds	r20, 0x19FA
    218e:	50 91 fb 19 	lds	r21, 0x19FB
    2192:	60 91 fc 19 	lds	r22, 0x19FC
    2196:	70 91 fd 19 	lds	r23, 0x19FD
    219a:	48 17       	cp	r20, r24
    219c:	59 07       	cpc	r21, r25
    219e:	6a 07       	cpc	r22, r26
    21a0:	7b 07       	cpc	r23, r27
    21a2:	08 f4       	brcc	.+2      	; 0x21a6 <vTaskIncrementTick+0xb6>
    21a4:	8a c0       	rjmp	.+276    	; 0x22ba <__stack+0xbb>
    21a6:	8e 01       	movw	r16, r28
    21a8:	0e 5f       	subi	r16, 0xFE	; 254
    21aa:	1f 4f       	sbci	r17, 0xFF	; 255
    21ac:	c8 01       	movw	r24, r16
    21ae:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <vListRemove>
    21b2:	88 8d       	ldd	r24, Y+24	; 0x18
    21b4:	99 8d       	ldd	r25, Y+25	; 0x19
    21b6:	00 97       	sbiw	r24, 0x00	; 0
    21b8:	21 f0       	breq	.+8      	; 0x21c2 <vTaskIncrementTick+0xd2>
    21ba:	ce 01       	movw	r24, r28
    21bc:	0e 96       	adiw	r24, 0x0e	; 14
    21be:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <vListRemove>
    21c2:	2a 8d       	ldd	r18, Y+26	; 0x1a
    21c4:	80 91 f9 19 	lds	r24, 0x19F9
    21c8:	82 17       	cp	r24, r18
    21ca:	10 f4       	brcc	.+4      	; 0x21d0 <vTaskIncrementTick+0xe0>
    21cc:	20 93 f9 19 	sts	0x19F9, r18
    21d0:	30 e0       	ldi	r19, 0x00	; 0
    21d2:	c9 01       	movw	r24, r18
    21d4:	88 0f       	add	r24, r24
    21d6:	99 1f       	adc	r25, r25
    21d8:	a9 01       	movw	r20, r18
    21da:	44 0f       	add	r20, r20
    21dc:	55 1f       	adc	r21, r21
    21de:	44 0f       	add	r20, r20
    21e0:	55 1f       	adc	r21, r21
    21e2:	44 0f       	add	r20, r20
    21e4:	55 1f       	adc	r21, r21
    21e6:	84 0f       	add	r24, r20
    21e8:	95 1f       	adc	r25, r21
    21ea:	82 0f       	add	r24, r18
    21ec:	93 1f       	adc	r25, r19
    21ee:	8d 5f       	subi	r24, 0xFD	; 253
    21f0:	95 4e       	sbci	r25, 0xE5	; 229
    21f2:	b8 01       	movw	r22, r16
    21f4:	0e 94 3b 15 	call	0x2a76	; 0x2a76 <vListInsertEnd>
    21f8:	e0 91 01 1a 	lds	r30, 0x1A01
    21fc:	f0 91 02 1a 	lds	r31, 0x1A02
    2200:	80 81       	ld	r24, Z
    2202:	88 23       	and	r24, r24
    2204:	09 f0       	breq	.+2      	; 0x2208 <__stack+0x9>
    2206:	b4 cf       	rjmp	.-152    	; 0x2170 <vTaskIncrementTick+0x80>
    2208:	8f ef       	ldi	r24, 0xFF	; 255
    220a:	9f ef       	ldi	r25, 0xFF	; 255
    220c:	dc 01       	movw	r26, r24
    220e:	80 93 95 02 	sts	0x0295, r24
    2212:	90 93 96 02 	sts	0x0296, r25
    2216:	a0 93 97 02 	sts	0x0297, r26
    221a:	b0 93 98 02 	sts	0x0298, r27
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    221e:	df 91       	pop	r29
    2220:	cf 91       	pop	r28
    2222:	1f 91       	pop	r17
    2224:	0f 91       	pop	r16
    2226:	08 95       	ret
		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
	}
	else
	{
		++uxMissedTicks;
    2228:	80 91 f6 19 	lds	r24, 0x19F6
    222c:	8f 5f       	subi	r24, 0xFF	; 255
    222e:	80 93 f6 19 	sts	0x19F6, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2232:	df 91       	pop	r29
    2234:	cf 91       	pop	r28
    2236:	1f 91       	pop	r17
    2238:	0f 91       	pop	r16
    223a:	08 95       	ret
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    223c:	80 91 01 1a 	lds	r24, 0x1A01
    2240:	90 91 02 1a 	lds	r25, 0x1A02
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2244:	20 91 ff 19 	lds	r18, 0x19FF
    2248:	30 91 00 1a 	lds	r19, 0x1A00
    224c:	30 93 02 1a 	sts	0x1A02, r19
    2250:	20 93 01 1a 	sts	0x1A01, r18
			pxOverflowDelayedTaskList = pxTemp;
    2254:	90 93 00 1a 	sts	0x1A00, r25
    2258:	80 93 ff 19 	sts	0x19FF, r24
			xNumOfOverflows++;
    225c:	80 91 f4 19 	lds	r24, 0x19F4
    2260:	8f 5f       	subi	r24, 0xFF	; 255
    2262:	80 93 f4 19 	sts	0x19F4, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2266:	e0 91 01 1a 	lds	r30, 0x1A01
    226a:	f0 91 02 1a 	lds	r31, 0x1A02
    226e:	80 81       	ld	r24, Z
    2270:	88 23       	and	r24, r24
    2272:	61 f4       	brne	.+24     	; 0x228c <__stack+0x8d>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2274:	8f ef       	ldi	r24, 0xFF	; 255
    2276:	9f ef       	ldi	r25, 0xFF	; 255
    2278:	dc 01       	movw	r26, r24
    227a:	80 93 95 02 	sts	0x0295, r24
    227e:	90 93 96 02 	sts	0x0296, r25
    2282:	a0 93 97 02 	sts	0x0297, r26
    2286:	b0 93 98 02 	sts	0x0298, r27
    228a:	63 cf       	rjmp	.-314    	; 0x2152 <vTaskIncrementTick+0x62>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    228c:	e0 91 01 1a 	lds	r30, 0x1A01
    2290:	f0 91 02 1a 	lds	r31, 0x1A02
    2294:	07 80       	ldd	r0, Z+7	; 0x07
    2296:	f0 85       	ldd	r31, Z+8	; 0x08
    2298:	e0 2d       	mov	r30, r0
    229a:	00 84       	ldd	r0, Z+8	; 0x08
    229c:	f1 85       	ldd	r31, Z+9	; 0x09
    229e:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    22a0:	82 81       	ldd	r24, Z+2	; 0x02
    22a2:	93 81       	ldd	r25, Z+3	; 0x03
    22a4:	a4 81       	ldd	r26, Z+4	; 0x04
    22a6:	b5 81       	ldd	r27, Z+5	; 0x05
    22a8:	80 93 95 02 	sts	0x0295, r24
    22ac:	90 93 96 02 	sts	0x0296, r25
    22b0:	a0 93 97 02 	sts	0x0297, r26
    22b4:	b0 93 98 02 	sts	0x0298, r27
    22b8:	4c cf       	rjmp	.-360    	; 0x2152 <vTaskIncrementTick+0x62>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    22ba:	80 93 95 02 	sts	0x0295, r24
    22be:	90 93 96 02 	sts	0x0296, r25
    22c2:	a0 93 97 02 	sts	0x0297, r26
    22c6:	b0 93 98 02 	sts	0x0298, r27
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    22ca:	df 91       	pop	r29
    22cc:	cf 91       	pop	r28
    22ce:	1f 91       	pop	r17
    22d0:	0f 91       	pop	r16
    22d2:	08 95       	ret

000022d4 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    22d4:	ef 92       	push	r14
    22d6:	ff 92       	push	r15
    22d8:	0f 93       	push	r16
    22da:	1f 93       	push	r17
    22dc:	cf 93       	push	r28
    22de:	df 93       	push	r29
    22e0:	0f 92       	push	r0
    22e2:	cd b7       	in	r28, 0x3d	; 61
    22e4:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    22e6:	0f b6       	in	r0, 0x3f	; 63
    22e8:	f8 94       	cli
    22ea:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    22ec:	80 91 f7 19 	lds	r24, 0x19F7
    22f0:	81 50       	subi	r24, 0x01	; 1
    22f2:	80 93 f7 19 	sts	0x19F7, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    22f6:	80 91 f7 19 	lds	r24, 0x19F7
    22fa:	88 23       	and	r24, r24
    22fc:	09 f0       	breq	.+2      	; 0x2300 <xTaskResumeAll+0x2c>
    22fe:	64 c0       	rjmp	.+200    	; 0x23c8 <xTaskResumeAll+0xf4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2300:	80 91 fe 19 	lds	r24, 0x19FE
    2304:	88 23       	and	r24, r24
    2306:	09 f4       	brne	.+2      	; 0x230a <xTaskResumeAll+0x36>
    2308:	55 c0       	rjmp	.+170    	; 0x23b4 <xTaskResumeAll+0xe0>
    230a:	19 82       	std	Y+1, r1	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    230c:	80 91 45 1a 	lds	r24, 0x1A45
    2310:	88 23       	and	r24, r24
    2312:	09 f4       	brne	.+2      	; 0x2316 <xTaskResumeAll+0x42>
    2314:	3f c0       	rjmp	.+126    	; 0x2394 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2316:	e0 91 4c 1a 	lds	r30, 0x1A4C
    231a:	f0 91 4d 1a 	lds	r31, 0x1A4D
    231e:	e0 84       	ldd	r14, Z+8	; 0x08
    2320:	f1 84       	ldd	r15, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    2322:	c7 01       	movw	r24, r14
    2324:	0e 96       	adiw	r24, 0x0e	; 14
    2326:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    232a:	87 01       	movw	r16, r14
    232c:	0e 5f       	subi	r16, 0xFE	; 254
    232e:	1f 4f       	sbci	r17, 0xFF	; 255
    2330:	c8 01       	movw	r24, r16
    2332:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2336:	d7 01       	movw	r26, r14
    2338:	5a 96       	adiw	r26, 0x1a	; 26
    233a:	2c 91       	ld	r18, X
    233c:	5a 97       	sbiw	r26, 0x1a	; 26
    233e:	80 91 f9 19 	lds	r24, 0x19F9
    2342:	82 17       	cp	r24, r18
    2344:	10 f4       	brcc	.+4      	; 0x234a <xTaskResumeAll+0x76>
    2346:	20 93 f9 19 	sts	0x19F9, r18
    234a:	30 e0       	ldi	r19, 0x00	; 0
    234c:	c9 01       	movw	r24, r18
    234e:	88 0f       	add	r24, r24
    2350:	99 1f       	adc	r25, r25
    2352:	a9 01       	movw	r20, r18
    2354:	44 0f       	add	r20, r20
    2356:	55 1f       	adc	r21, r21
    2358:	44 0f       	add	r20, r20
    235a:	55 1f       	adc	r21, r21
    235c:	44 0f       	add	r20, r20
    235e:	55 1f       	adc	r21, r21
    2360:	84 0f       	add	r24, r20
    2362:	95 1f       	adc	r25, r21
    2364:	82 0f       	add	r24, r18
    2366:	93 1f       	adc	r25, r19
    2368:	8d 5f       	subi	r24, 0xFD	; 253
    236a:	95 4e       	sbci	r25, 0xE5	; 229
    236c:	b8 01       	movw	r22, r16
    236e:	0e 94 3b 15 	call	0x2a76	; 0x2a76 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2372:	e0 91 f2 19 	lds	r30, 0x19F2
    2376:	f0 91 f3 19 	lds	r31, 0x19F3
    237a:	d7 01       	movw	r26, r14
    237c:	5a 96       	adiw	r26, 0x1a	; 26
    237e:	9c 91       	ld	r25, X
    2380:	5a 97       	sbiw	r26, 0x1a	; 26
    2382:	82 8d       	ldd	r24, Z+26	; 0x1a
    2384:	98 17       	cp	r25, r24
    2386:	10 f2       	brcs	.-124    	; 0x230c <xTaskResumeAll+0x38>
					{
						xYieldRequired = pdTRUE;
    2388:	b1 e0       	ldi	r27, 0x01	; 1
    238a:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    238c:	80 91 45 1a 	lds	r24, 0x1A45
    2390:	88 23       	and	r24, r24
    2392:	09 f6       	brne	.-126    	; 0x2316 <xTaskResumeAll+0x42>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2394:	80 91 f6 19 	lds	r24, 0x19F6
    2398:	88 23       	and	r24, r24
    239a:	c1 f4       	brne	.+48     	; 0x23cc <xTaskResumeAll+0xf8>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    239c:	e9 81       	ldd	r30, Y+1	; 0x01
    239e:	e1 30       	cpi	r30, 0x01	; 1
    23a0:	21 f0       	breq	.+8      	; 0x23aa <xTaskResumeAll+0xd6>
    23a2:	80 91 f5 19 	lds	r24, 0x19F5
    23a6:	81 30       	cpi	r24, 0x01	; 1
    23a8:	79 f4       	brne	.+30     	; 0x23c8 <xTaskResumeAll+0xf4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    23aa:	10 92 f5 19 	sts	0x19F5, r1
					portYIELD_WITHIN_API();
    23ae:	0e 94 ac 09 	call	0x1358	; 0x1358 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    23b2:	81 e0       	ldi	r24, 0x01	; 1
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    23b4:	0f 90       	pop	r0
    23b6:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    23b8:	0f 90       	pop	r0
    23ba:	df 91       	pop	r29
    23bc:	cf 91       	pop	r28
    23be:	1f 91       	pop	r17
    23c0:	0f 91       	pop	r16
    23c2:	ff 90       	pop	r15
    23c4:	ef 90       	pop	r14
    23c6:	08 95       	ret
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    23c8:	80 e0       	ldi	r24, 0x00	; 0
    23ca:	f4 cf       	rjmp	.-24     	; 0x23b4 <xTaskResumeAll+0xe0>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    23cc:	80 91 f6 19 	lds	r24, 0x19F6
    23d0:	88 23       	and	r24, r24
    23d2:	59 f3       	breq	.-42     	; 0x23aa <xTaskResumeAll+0xd6>
					{
						vTaskIncrementTick();
    23d4:	0e 94 78 10 	call	0x20f0	; 0x20f0 <vTaskIncrementTick>
						--uxMissedTicks;
    23d8:	80 91 f6 19 	lds	r24, 0x19F6
    23dc:	81 50       	subi	r24, 0x01	; 1
    23de:	80 93 f6 19 	sts	0x19F6, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    23e2:	80 91 f6 19 	lds	r24, 0x19F6
    23e6:	88 23       	and	r24, r24
    23e8:	a9 f7       	brne	.-22     	; 0x23d4 <xTaskResumeAll+0x100>
    23ea:	df cf       	rjmp	.-66     	; 0x23aa <xTaskResumeAll+0xd6>

000023ec <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    23ec:	cf 92       	push	r12
    23ee:	df 92       	push	r13
    23f0:	ef 92       	push	r14
    23f2:	ff 92       	push	r15
    23f4:	dc 01       	movw	r26, r24
    23f6:	cb 01       	movw	r24, r22
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    23f8:	00 97       	sbiw	r24, 0x00	; 0
    23fa:	a1 05       	cpc	r26, r1
    23fc:	b1 05       	cpc	r27, r1
    23fe:	39 f4       	brne	.+14     	; 0x240e <vTaskDelay+0x22>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
    2400:	0e 94 ac 09 	call	0x1358	; 0x1358 <vPortYield>
		}
	}
    2404:	ff 90       	pop	r15
    2406:	ef 90       	pop	r14
    2408:	df 90       	pop	r13
    240a:	cf 90       	pop	r12
    240c:	08 95       	ret

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    240e:	20 91 f7 19 	lds	r18, 0x19F7
    2412:	2f 5f       	subi	r18, 0xFF	; 255
    2414:	20 93 f7 19 	sts	0x19F7, r18
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2418:	c0 90 fa 19 	lds	r12, 0x19FA
    241c:	d0 90 fb 19 	lds	r13, 0x19FB
    2420:	e0 90 fc 19 	lds	r14, 0x19FC
    2424:	f0 90 fd 19 	lds	r15, 0x19FD
    2428:	c8 0e       	add	r12, r24
    242a:	d9 1e       	adc	r13, r25
    242c:	ea 1e       	adc	r14, r26
    242e:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2430:	80 91 f2 19 	lds	r24, 0x19F2
    2434:	90 91 f3 19 	lds	r25, 0x19F3
    2438:	02 96       	adiw	r24, 0x02	; 2
    243a:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    243e:	c7 01       	movw	r24, r14
    2440:	b6 01       	movw	r22, r12
    2442:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2446:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    244a:	88 23       	and	r24, r24
    244c:	c9 f2       	breq	.-78     	; 0x2400 <vTaskDelay+0x14>
		{
			portYIELD_WITHIN_API();
		}
	}
    244e:	ff 90       	pop	r15
    2450:	ef 90       	pop	r14
    2452:	df 90       	pop	r13
    2454:	cf 90       	pop	r12
    2456:	08 95       	ret

00002458 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2458:	cf 92       	push	r12
    245a:	df 92       	push	r13
    245c:	ef 92       	push	r14
    245e:	ff 92       	push	r15
    2460:	fc 01       	movw	r30, r24
    2462:	6a 01       	movw	r12, r20
    2464:	7b 01       	movw	r14, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2466:	80 91 f7 19 	lds	r24, 0x19F7
    246a:	8f 5f       	subi	r24, 0xFF	; 255
    246c:	80 93 f7 19 	sts	0x19F7, r24
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2470:	80 81       	ld	r24, Z
    2472:	91 81       	ldd	r25, Z+1	; 0x01
    2474:	a2 81       	ldd	r26, Z+2	; 0x02
    2476:	b3 81       	ldd	r27, Z+3	; 0x03
    2478:	c8 0e       	add	r12, r24
    247a:	d9 1e       	adc	r13, r25
    247c:	ea 1e       	adc	r14, r26
    247e:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2480:	40 91 fa 19 	lds	r20, 0x19FA
    2484:	50 91 fb 19 	lds	r21, 0x19FB
    2488:	60 91 fc 19 	lds	r22, 0x19FC
    248c:	70 91 fd 19 	lds	r23, 0x19FD
    2490:	48 17       	cp	r20, r24
    2492:	59 07       	cpc	r21, r25
    2494:	6a 07       	cpc	r22, r26
    2496:	7b 07       	cpc	r23, r27
    2498:	60 f5       	brcc	.+88     	; 0x24f2 <vTaskDelayUntil+0x9a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    249a:	c8 16       	cp	r12, r24
    249c:	d9 06       	cpc	r13, r25
    249e:	ea 06       	cpc	r14, r26
    24a0:	fb 06       	cpc	r15, r27
    24a2:	68 f5       	brcc	.+90     	; 0x24fe <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    24a4:	80 91 fa 19 	lds	r24, 0x19FA
    24a8:	90 91 fb 19 	lds	r25, 0x19FB
    24ac:	a0 91 fc 19 	lds	r26, 0x19FC
    24b0:	b0 91 fd 19 	lds	r27, 0x19FD
    24b4:	8c 15       	cp	r24, r12
    24b6:	9d 05       	cpc	r25, r13
    24b8:	ae 05       	cpc	r26, r14
    24ba:	bf 05       	cpc	r27, r15
    24bc:	00 f5       	brcc	.+64     	; 0x24fe <vTaskDelayUntil+0xa6>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    24be:	c0 82       	st	Z, r12
    24c0:	d1 82       	std	Z+1, r13	; 0x01
    24c2:	e2 82       	std	Z+2, r14	; 0x02
    24c4:	f3 82       	std	Z+3, r15	; 0x03
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24c6:	80 91 f2 19 	lds	r24, 0x19F2
    24ca:	90 91 f3 19 	lds	r25, 0x19F3
    24ce:	02 96       	adiw	r24, 0x02	; 2
    24d0:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    24d4:	c7 01       	movw	r24, r14
    24d6:	b6 01       	movw	r22, r12
    24d8:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    24dc:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    24e0:	88 23       	and	r24, r24
    24e2:	11 f4       	brne	.+4      	; 0x24e8 <vTaskDelayUntil+0x90>
		{
			portYIELD_WITHIN_API();
    24e4:	0e 94 ac 09 	call	0x1358	; 0x1358 <vPortYield>
		}
	}
    24e8:	ff 90       	pop	r15
    24ea:	ef 90       	pop	r14
    24ec:	df 90       	pop	r13
    24ee:	cf 90       	pop	r12
    24f0:	08 95       	ret
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    24f2:	c8 16       	cp	r12, r24
    24f4:	d9 06       	cpc	r13, r25
    24f6:	ea 06       	cpc	r14, r26
    24f8:	fb 06       	cpc	r15, r27
    24fa:	08 f3       	brcs	.-62     	; 0x24be <vTaskDelayUntil+0x66>
    24fc:	d3 cf       	rjmp	.-90     	; 0x24a4 <vTaskDelayUntil+0x4c>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    24fe:	c0 82       	st	Z, r12
    2500:	d1 82       	std	Z+1, r13	; 0x01
    2502:	e2 82       	std	Z+2, r14	; 0x02
    2504:	f3 82       	std	Z+3, r15	; 0x03
    2506:	ea cf       	rjmp	.-44     	; 0x24dc <vTaskDelayUntil+0x84>

00002508 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2508:	80 91 f7 19 	lds	r24, 0x19F7
    250c:	88 23       	and	r24, r24
    250e:	31 f0       	breq	.+12     	; 0x251c <vTaskSwitchContext+0x14>
    2510:	44 c0       	rjmp	.+136    	; 0x259a <vTaskSwitchContext+0x92>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2512:	80 91 f9 19 	lds	r24, 0x19F9
    2516:	81 50       	subi	r24, 0x01	; 1
    2518:	80 93 f9 19 	sts	0x19F9, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    251c:	80 91 f9 19 	lds	r24, 0x19F9
    2520:	90 e0       	ldi	r25, 0x00	; 0
    2522:	fc 01       	movw	r30, r24
    2524:	ee 0f       	add	r30, r30
    2526:	ff 1f       	adc	r31, r31
    2528:	9c 01       	movw	r18, r24
    252a:	22 0f       	add	r18, r18
    252c:	33 1f       	adc	r19, r19
    252e:	22 0f       	add	r18, r18
    2530:	33 1f       	adc	r19, r19
    2532:	22 0f       	add	r18, r18
    2534:	33 1f       	adc	r19, r19
    2536:	e2 0f       	add	r30, r18
    2538:	f3 1f       	adc	r31, r19
    253a:	e8 0f       	add	r30, r24
    253c:	f9 1f       	adc	r31, r25
    253e:	ed 5f       	subi	r30, 0xFD	; 253
    2540:	f5 4e       	sbci	r31, 0xE5	; 229
    2542:	80 81       	ld	r24, Z
    2544:	88 23       	and	r24, r24
    2546:	29 f3       	breq	.-54     	; 0x2512 <vTaskSwitchContext+0xa>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2548:	80 91 f9 19 	lds	r24, 0x19F9
    254c:	90 e0       	ldi	r25, 0x00	; 0
    254e:	fc 01       	movw	r30, r24
    2550:	ee 0f       	add	r30, r30
    2552:	ff 1f       	adc	r31, r31
    2554:	9c 01       	movw	r18, r24
    2556:	22 0f       	add	r18, r18
    2558:	33 1f       	adc	r19, r19
    255a:	22 0f       	add	r18, r18
    255c:	33 1f       	adc	r19, r19
    255e:	22 0f       	add	r18, r18
    2560:	33 1f       	adc	r19, r19
    2562:	e2 0f       	add	r30, r18
    2564:	f3 1f       	adc	r31, r19
    2566:	e8 0f       	add	r30, r24
    2568:	f9 1f       	adc	r31, r25
    256a:	ed 5f       	subi	r30, 0xFD	; 253
    256c:	f5 4e       	sbci	r31, 0xE5	; 229
    256e:	a1 81       	ldd	r26, Z+1	; 0x01
    2570:	b2 81       	ldd	r27, Z+2	; 0x02
    2572:	14 96       	adiw	r26, 0x04	; 4
    2574:	0d 90       	ld	r0, X+
    2576:	bc 91       	ld	r27, X
    2578:	a0 2d       	mov	r26, r0
    257a:	b2 83       	std	Z+2, r27	; 0x02
    257c:	a1 83       	std	Z+1, r26	; 0x01
    257e:	cf 01       	movw	r24, r30
    2580:	03 96       	adiw	r24, 0x03	; 3
    2582:	a8 17       	cp	r26, r24
    2584:	b9 07       	cpc	r27, r25
    2586:	69 f0       	breq	.+26     	; 0x25a2 <vTaskSwitchContext+0x9a>
    2588:	18 96       	adiw	r26, 0x08	; 8
    258a:	8d 91       	ld	r24, X+
    258c:	9c 91       	ld	r25, X
    258e:	19 97       	sbiw	r26, 0x09	; 9
    2590:	90 93 f3 19 	sts	0x19F3, r25
    2594:	80 93 f2 19 	sts	0x19F2, r24
    2598:	08 95       	ret
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    259a:	81 e0       	ldi	r24, 0x01	; 1
    259c:	80 93 f5 19 	sts	0x19F5, r24
    25a0:	08 95       	ret
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    25a2:	14 96       	adiw	r26, 0x04	; 4
    25a4:	0d 90       	ld	r0, X+
    25a6:	bc 91       	ld	r27, X
    25a8:	a0 2d       	mov	r26, r0
    25aa:	b2 83       	std	Z+2, r27	; 0x02
    25ac:	a1 83       	std	Z+1, r26	; 0x01
    25ae:	ec cf       	rjmp	.-40     	; 0x2588 <vTaskSwitchContext+0x80>

000025b0 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    25b0:	cf 92       	push	r12
    25b2:	df 92       	push	r13
    25b4:	ef 92       	push	r14
    25b6:	ff 92       	push	r15
    25b8:	6a 01       	movw	r12, r20
    25ba:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    25bc:	60 91 f2 19 	lds	r22, 0x19F2
    25c0:	70 91 f3 19 	lds	r23, 0x19F3
    25c4:	62 5f       	subi	r22, 0xF2	; 242
    25c6:	7f 4f       	sbci	r23, 0xFF	; 255
    25c8:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25cc:	80 91 f2 19 	lds	r24, 0x19F2
    25d0:	90 91 f3 19 	lds	r25, 0x19F3
    25d4:	02 96       	adiw	r24, 0x02	; 2
    25d6:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    25da:	80 91 fa 19 	lds	r24, 0x19FA
    25de:	90 91 fb 19 	lds	r25, 0x19FB
    25e2:	a0 91 fc 19 	lds	r26, 0x19FC
    25e6:	b0 91 fd 19 	lds	r27, 0x19FD
    25ea:	8c 0d       	add	r24, r12
    25ec:	9d 1d       	adc	r25, r13
    25ee:	ae 1d       	adc	r26, r14
    25f0:	bf 1d       	adc	r27, r15
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    25f2:	bc 01       	movw	r22, r24
    25f4:	cd 01       	movw	r24, r26
    25f6:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    25fa:	ff 90       	pop	r15
    25fc:	ef 90       	pop	r14
    25fe:	df 90       	pop	r13
    2600:	cf 90       	pop	r12
    2602:	08 95       	ret

00002604 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2604:	0f 93       	push	r16
    2606:	1f 93       	push	r17
    2608:	cf 93       	push	r28
    260a:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    260c:	dc 01       	movw	r26, r24
    260e:	17 96       	adiw	r26, 0x07	; 7
    2610:	ed 91       	ld	r30, X+
    2612:	fc 91       	ld	r31, X
    2614:	18 97       	sbiw	r26, 0x08	; 8
    2616:	00 85       	ldd	r16, Z+8	; 0x08
    2618:	11 85       	ldd	r17, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    261a:	e8 01       	movw	r28, r16
    261c:	2e 96       	adiw	r28, 0x0e	; 14
    261e:	ce 01       	movw	r24, r28
    2620:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2624:	80 91 f7 19 	lds	r24, 0x19F7
    2628:	88 23       	and	r24, r24
    262a:	89 f5       	brne	.+98     	; 0x268e <xTaskRemoveFromEventList+0x8a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    262c:	e8 01       	movw	r28, r16
    262e:	22 96       	adiw	r28, 0x02	; 2
    2630:	ce 01       	movw	r24, r28
    2632:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2636:	f8 01       	movw	r30, r16
    2638:	22 8d       	ldd	r18, Z+26	; 0x1a
    263a:	80 91 f9 19 	lds	r24, 0x19F9
    263e:	82 17       	cp	r24, r18
    2640:	60 f1       	brcs	.+88     	; 0x269a <xTaskRemoveFromEventList+0x96>
    2642:	30 e0       	ldi	r19, 0x00	; 0
    2644:	c9 01       	movw	r24, r18
    2646:	88 0f       	add	r24, r24
    2648:	99 1f       	adc	r25, r25
    264a:	a9 01       	movw	r20, r18
    264c:	44 0f       	add	r20, r20
    264e:	55 1f       	adc	r21, r21
    2650:	44 0f       	add	r20, r20
    2652:	55 1f       	adc	r21, r21
    2654:	44 0f       	add	r20, r20
    2656:	55 1f       	adc	r21, r21
    2658:	84 0f       	add	r24, r20
    265a:	95 1f       	adc	r25, r21
    265c:	82 0f       	add	r24, r18
    265e:	93 1f       	adc	r25, r19
    2660:	8d 5f       	subi	r24, 0xFD	; 253
    2662:	95 4e       	sbci	r25, 0xE5	; 229
    2664:	be 01       	movw	r22, r28
    2666:	0e 94 3b 15 	call	0x2a76	; 0x2a76 <vListInsertEnd>
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    266a:	e0 91 f2 19 	lds	r30, 0x19F2
    266e:	f0 91 f3 19 	lds	r31, 0x19F3
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2672:	81 e0       	ldi	r24, 0x01	; 1
    2674:	d8 01       	movw	r26, r16
    2676:	5a 96       	adiw	r26, 0x1a	; 26
    2678:	2c 91       	ld	r18, X
    267a:	5a 97       	sbiw	r26, 0x1a	; 26
    267c:	92 8d       	ldd	r25, Z+26	; 0x1a
    267e:	29 17       	cp	r18, r25
    2680:	08 f4       	brcc	.+2      	; 0x2684 <xTaskRemoveFromEventList+0x80>
    2682:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    2684:	df 91       	pop	r29
    2686:	cf 91       	pop	r28
    2688:	1f 91       	pop	r17
    268a:	0f 91       	pop	r16
    268c:	08 95       	ret
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    268e:	85 e4       	ldi	r24, 0x45	; 69
    2690:	9a e1       	ldi	r25, 0x1A	; 26
    2692:	be 01       	movw	r22, r28
    2694:	0e 94 3b 15 	call	0x2a76	; 0x2a76 <vListInsertEnd>
    2698:	e8 cf       	rjmp	.-48     	; 0x266a <xTaskRemoveFromEventList+0x66>
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    269a:	20 93 f9 19 	sts	0x19F9, r18
    269e:	d1 cf       	rjmp	.-94     	; 0x2642 <xTaskRemoveFromEventList+0x3e>

000026a0 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    26a0:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    26a2:	80 91 f4 19 	lds	r24, 0x19F4
    26a6:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    26a8:	40 91 fa 19 	lds	r20, 0x19FA
    26ac:	50 91 fb 19 	lds	r21, 0x19FB
    26b0:	60 91 fc 19 	lds	r22, 0x19FC
    26b4:	70 91 fd 19 	lds	r23, 0x19FD
    26b8:	41 83       	std	Z+1, r20	; 0x01
    26ba:	52 83       	std	Z+2, r21	; 0x02
    26bc:	63 83       	std	Z+3, r22	; 0x03
    26be:	74 83       	std	Z+4, r23	; 0x04
}
    26c0:	08 95       	ret

000026c2 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    26c2:	0f 93       	push	r16
    26c4:	1f 93       	push	r17
    26c6:	cf 93       	push	r28
    26c8:	df 93       	push	r29
    26ca:	fc 01       	movw	r30, r24
    26cc:	eb 01       	movw	r28, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    26ce:	0f b6       	in	r0, 0x3f	; 63
    26d0:	f8 94       	cli
    26d2:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    26d4:	80 91 f4 19 	lds	r24, 0x19F4
    26d8:	90 81       	ld	r25, Z
    26da:	98 17       	cp	r25, r24
    26dc:	09 f4       	brne	.+2      	; 0x26e0 <xTaskCheckForTimeOut+0x1e>
    26de:	53 c0       	rjmp	.+166    	; 0x2786 <xTaskCheckForTimeOut+0xc4>
    26e0:	81 81       	ldd	r24, Z+1	; 0x01
    26e2:	92 81       	ldd	r25, Z+2	; 0x02
    26e4:	a3 81       	ldd	r26, Z+3	; 0x03
    26e6:	b4 81       	ldd	r27, Z+4	; 0x04
    26e8:	40 91 fa 19 	lds	r20, 0x19FA
    26ec:	50 91 fb 19 	lds	r21, 0x19FB
    26f0:	60 91 fc 19 	lds	r22, 0x19FC
    26f4:	70 91 fd 19 	lds	r23, 0x19FD
    26f8:	48 17       	cp	r20, r24
    26fa:	59 07       	cpc	r21, r25
    26fc:	6a 07       	cpc	r22, r26
    26fe:	7b 07       	cpc	r23, r27
    2700:	d0 f5       	brcc	.+116    	; 0x2776 <xTaskCheckForTimeOut+0xb4>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2702:	40 91 fa 19 	lds	r20, 0x19FA
    2706:	50 91 fb 19 	lds	r21, 0x19FB
    270a:	60 91 fc 19 	lds	r22, 0x19FC
    270e:	70 91 fd 19 	lds	r23, 0x19FD
    2712:	08 81       	ld	r16, Y
    2714:	19 81       	ldd	r17, Y+1	; 0x01
    2716:	2a 81       	ldd	r18, Y+2	; 0x02
    2718:	3b 81       	ldd	r19, Y+3	; 0x03
    271a:	48 1b       	sub	r20, r24
    271c:	59 0b       	sbc	r21, r25
    271e:	6a 0b       	sbc	r22, r26
    2720:	7b 0b       	sbc	r23, r27
    2722:	40 17       	cp	r20, r16
    2724:	51 07       	cpc	r21, r17
    2726:	62 07       	cpc	r22, r18
    2728:	73 07       	cpc	r23, r19
    272a:	28 f5       	brcc	.+74     	; 0x2776 <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    272c:	40 91 fa 19 	lds	r20, 0x19FA
    2730:	50 91 fb 19 	lds	r21, 0x19FB
    2734:	60 91 fc 19 	lds	r22, 0x19FC
    2738:	70 91 fd 19 	lds	r23, 0x19FD
    273c:	04 1b       	sub	r16, r20
    273e:	15 0b       	sbc	r17, r21
    2740:	26 0b       	sbc	r18, r22
    2742:	37 0b       	sbc	r19, r23
    2744:	08 0f       	add	r16, r24
    2746:	19 1f       	adc	r17, r25
    2748:	2a 1f       	adc	r18, r26
    274a:	3b 1f       	adc	r19, r27
    274c:	08 83       	st	Y, r16
    274e:	19 83       	std	Y+1, r17	; 0x01
    2750:	2a 83       	std	Y+2, r18	; 0x02
    2752:	3b 83       	std	Y+3, r19	; 0x03
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2754:	80 91 f4 19 	lds	r24, 0x19F4
    2758:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    275a:	80 91 fa 19 	lds	r24, 0x19FA
    275e:	90 91 fb 19 	lds	r25, 0x19FB
    2762:	a0 91 fc 19 	lds	r26, 0x19FC
    2766:	b0 91 fd 19 	lds	r27, 0x19FD
    276a:	81 83       	std	Z+1, r24	; 0x01
    276c:	92 83       	std	Z+2, r25	; 0x02
    276e:	a3 83       	std	Z+3, r26	; 0x03
    2770:	b4 83       	std	Z+4, r27	; 0x04
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
    2772:	80 e0       	ldi	r24, 0x00	; 0
    2774:	01 c0       	rjmp	.+2      	; 0x2778 <xTaskCheckForTimeOut+0xb6>
		}
		else
		{
			xReturn = pdTRUE;
    2776:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2778:	0f 90       	pop	r0
    277a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    277c:	df 91       	pop	r29
    277e:	cf 91       	pop	r28
    2780:	1f 91       	pop	r17
    2782:	0f 91       	pop	r16
    2784:	08 95       	ret
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2786:	81 81       	ldd	r24, Z+1	; 0x01
    2788:	92 81       	ldd	r25, Z+2	; 0x02
    278a:	a3 81       	ldd	r26, Z+3	; 0x03
    278c:	b4 81       	ldd	r27, Z+4	; 0x04
    278e:	b9 cf       	rjmp	.-142    	; 0x2702 <xTaskCheckForTimeOut+0x40>

00002790 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2790:	81 e0       	ldi	r24, 0x01	; 1
    2792:	80 93 f5 19 	sts	0x19F5, r24
}
    2796:	08 95       	ret

00002798 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2798:	00 97       	sbiw	r24, 0x00	; 0
    279a:	79 f0       	breq	.+30     	; 0x27ba <uxTaskGetStackHighWaterMark+0x22>
    279c:	fc 01       	movw	r30, r24

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    279e:	03 8c       	ldd	r0, Z+27	; 0x1b
    27a0:	f4 8d       	ldd	r31, Z+28	; 0x1c
    27a2:	e0 2d       	mov	r30, r0

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27a4:	80 81       	ld	r24, Z
    27a6:	81 31       	cpi	r24, 0x11	; 17
    27a8:	69 f4       	brne	.+26     	; 0x27c4 <uxTaskGetStackHighWaterMark+0x2c>
#endif
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
    27aa:	31 96       	adiw	r30, 0x01	; 1

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    27ac:	80 e0       	ldi	r24, 0x00	; 0
    27ae:	90 e0       	ldi	r25, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    27b0:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27b2:	21 91       	ld	r18, Z+
    27b4:	21 31       	cpi	r18, 0x11	; 17
    27b6:	e1 f3       	breq	.-8      	; 0x27b0 <uxTaskGetStackHighWaterMark+0x18>
    27b8:	08 95       	ret
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    27ba:	e0 91 f2 19 	lds	r30, 0x19F2
    27be:	f0 91 f3 19 	lds	r31, 0x19F3
    27c2:	ed cf       	rjmp	.-38     	; 0x279e <uxTaskGetStackHighWaterMark+0x6>

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27c4:	80 e0       	ldi	r24, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    27c6:	08 95       	ret

000027c8 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    27c8:	80 91 f2 19 	lds	r24, 0x19F2
    27cc:	90 91 f3 19 	lds	r25, 0x19F3

		return xReturn;
	}
    27d0:	08 95       	ret

000027d2 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    27d2:	0f 93       	push	r16
    27d4:	1f 93       	push	r17
    27d6:	cf 93       	push	r28
    27d8:	df 93       	push	r29
    27da:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    27dc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    27de:	e0 91 f2 19 	lds	r30, 0x19F2
    27e2:	f0 91 f3 19 	lds	r31, 0x19F3
    27e6:	92 8d       	ldd	r25, Z+26	; 0x1a
    27e8:	89 17       	cp	r24, r25
    27ea:	68 f5       	brcc	.+90     	; 0x2846 <vTaskPriorityInherit+0x74>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    27ec:	e0 91 f2 19 	lds	r30, 0x19F2
    27f0:	f0 91 f3 19 	lds	r31, 0x19F3
    27f4:	92 8d       	ldd	r25, Z+26	; 0x1a
    27f6:	44 e0       	ldi	r20, 0x04	; 4
    27f8:	50 e0       	ldi	r21, 0x00	; 0
    27fa:	60 e0       	ldi	r22, 0x00	; 0
    27fc:	70 e0       	ldi	r23, 0x00	; 0
    27fe:	49 1b       	sub	r20, r25
    2800:	51 09       	sbc	r21, r1
    2802:	61 09       	sbc	r22, r1
    2804:	71 09       	sbc	r23, r1
    2806:	4e 87       	std	Y+14, r20	; 0x0e
    2808:	5f 87       	std	Y+15, r21	; 0x0f
    280a:	68 8b       	std	Y+16, r22	; 0x10
    280c:	79 8b       	std	Y+17, r23	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    280e:	90 e0       	ldi	r25, 0x00	; 0
    2810:	ac 01       	movw	r20, r24
    2812:	44 0f       	add	r20, r20
    2814:	55 1f       	adc	r21, r21
    2816:	9c 01       	movw	r18, r24
    2818:	22 0f       	add	r18, r18
    281a:	33 1f       	adc	r19, r19
    281c:	22 0f       	add	r18, r18
    281e:	33 1f       	adc	r19, r19
    2820:	22 0f       	add	r18, r18
    2822:	33 1f       	adc	r19, r19
    2824:	42 0f       	add	r20, r18
    2826:	53 1f       	adc	r21, r19
    2828:	48 0f       	add	r20, r24
    282a:	59 1f       	adc	r21, r25
    282c:	4d 5f       	subi	r20, 0xFD	; 253
    282e:	55 4e       	sbci	r21, 0xE5	; 229
    2830:	8c 85       	ldd	r24, Y+12	; 0x0c
    2832:	9d 85       	ldd	r25, Y+13	; 0x0d
    2834:	84 17       	cp	r24, r20
    2836:	95 07       	cpc	r25, r21
    2838:	59 f0       	breq	.+22     	; 0x2850 <vTaskPriorityInherit+0x7e>
				prvAddTaskToReadyQueue( pxTCB );
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    283a:	e0 91 f2 19 	lds	r30, 0x19F2
    283e:	f0 91 f3 19 	lds	r31, 0x19F3
    2842:	82 8d       	ldd	r24, Z+26	; 0x1a
    2844:	8a 8f       	std	Y+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2846:	df 91       	pop	r29
    2848:	cf 91       	pop	r28
    284a:	1f 91       	pop	r17
    284c:	0f 91       	pop	r16
    284e:	08 95       	ret

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2850:	8e 01       	movw	r16, r28
    2852:	0e 5f       	subi	r16, 0xFE	; 254
    2854:	1f 4f       	sbci	r17, 0xFF	; 255
    2856:	c8 01       	movw	r24, r16
    2858:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    285c:	e0 91 f2 19 	lds	r30, 0x19F2
    2860:	f0 91 f3 19 	lds	r31, 0x19F3
    2864:	22 8d       	ldd	r18, Z+26	; 0x1a
    2866:	2a 8f       	std	Y+26, r18	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2868:	80 91 f9 19 	lds	r24, 0x19F9
    286c:	82 17       	cp	r24, r18
    286e:	10 f4       	brcc	.+4      	; 0x2874 <vTaskPriorityInherit+0xa2>
    2870:	20 93 f9 19 	sts	0x19F9, r18
    2874:	30 e0       	ldi	r19, 0x00	; 0
    2876:	c9 01       	movw	r24, r18
    2878:	88 0f       	add	r24, r24
    287a:	99 1f       	adc	r25, r25
    287c:	a9 01       	movw	r20, r18
    287e:	44 0f       	add	r20, r20
    2880:	55 1f       	adc	r21, r21
    2882:	44 0f       	add	r20, r20
    2884:	55 1f       	adc	r21, r21
    2886:	44 0f       	add	r20, r20
    2888:	55 1f       	adc	r21, r21
    288a:	84 0f       	add	r24, r20
    288c:	95 1f       	adc	r25, r21
    288e:	82 0f       	add	r24, r18
    2890:	93 1f       	adc	r25, r19
    2892:	8d 5f       	subi	r24, 0xFD	; 253
    2894:	95 4e       	sbci	r25, 0xE5	; 229
    2896:	b8 01       	movw	r22, r16
    2898:	0e 94 3b 15 	call	0x2a76	; 0x2a76 <vListInsertEnd>
    289c:	d4 cf       	rjmp	.-88     	; 0x2846 <vTaskPriorityInherit+0x74>

0000289e <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    289e:	0f 93       	push	r16
    28a0:	1f 93       	push	r17
    28a2:	cf 93       	push	r28
    28a4:	df 93       	push	r29
    28a6:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    28a8:	00 97       	sbiw	r24, 0x00	; 0
    28aa:	81 f1       	breq	.+96     	; 0x290c <vTaskPriorityDisinherit+0x6e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    28ac:	9a 8d       	ldd	r25, Y+26	; 0x1a
    28ae:	8f a1       	lds	r24, 0x4f
    28b0:	98 17       	cp	r25, r24
    28b2:	61 f1       	breq	.+88     	; 0x290c <vTaskPriorityDisinherit+0x6e>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    28b4:	8e 01       	movw	r16, r28
    28b6:	0e 5f       	subi	r16, 0xFE	; 254
    28b8:	1f 4f       	sbci	r17, 0xFF	; 255
    28ba:	c8 01       	movw	r24, r16
    28bc:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    28c0:	2f a1       	lds	r18, 0x4f
    28c2:	2a 8f       	std	Y+26, r18	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    28c4:	84 e0       	ldi	r24, 0x04	; 4
    28c6:	90 e0       	ldi	r25, 0x00	; 0
    28c8:	a0 e0       	ldi	r26, 0x00	; 0
    28ca:	b0 e0       	ldi	r27, 0x00	; 0
    28cc:	82 1b       	sub	r24, r18
    28ce:	91 09       	sbc	r25, r1
    28d0:	a1 09       	sbc	r26, r1
    28d2:	b1 09       	sbc	r27, r1
    28d4:	8e 87       	std	Y+14, r24	; 0x0e
    28d6:	9f 87       	std	Y+15, r25	; 0x0f
    28d8:	a8 8b       	std	Y+16, r26	; 0x10
    28da:	b9 8b       	std	Y+17, r27	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    28dc:	80 91 f9 19 	lds	r24, 0x19F9
    28e0:	82 17       	cp	r24, r18
    28e2:	c8 f0       	brcs	.+50     	; 0x2916 <vTaskPriorityDisinherit+0x78>
    28e4:	30 e0       	ldi	r19, 0x00	; 0
    28e6:	c9 01       	movw	r24, r18
    28e8:	88 0f       	add	r24, r24
    28ea:	99 1f       	adc	r25, r25
    28ec:	a9 01       	movw	r20, r18
    28ee:	44 0f       	add	r20, r20
    28f0:	55 1f       	adc	r21, r21
    28f2:	44 0f       	add	r20, r20
    28f4:	55 1f       	adc	r21, r21
    28f6:	44 0f       	add	r20, r20
    28f8:	55 1f       	adc	r21, r21
    28fa:	84 0f       	add	r24, r20
    28fc:	95 1f       	adc	r25, r21
    28fe:	82 0f       	add	r24, r18
    2900:	93 1f       	adc	r25, r19
    2902:	8d 5f       	subi	r24, 0xFD	; 253
    2904:	95 4e       	sbci	r25, 0xE5	; 229
    2906:	b8 01       	movw	r22, r16
    2908:	0e 94 3b 15 	call	0x2a76	; 0x2a76 <vListInsertEnd>
			}
		}
	}
    290c:	df 91       	pop	r29
    290e:	cf 91       	pop	r28
    2910:	1f 91       	pop	r17
    2912:	0f 91       	pop	r16
    2914:	08 95       	ret
				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
    2916:	20 93 f9 19 	sts	0x19F9, r18
    291a:	e4 cf       	rjmp	.-56     	; 0x28e4 <vTaskPriorityDisinherit+0x46>

0000291c <_ZN7base232C1Ejh>:
 *                     1 only exists on some processors). The default is port 0 
 */

// This section compiles for the AVR microcontroller
#ifdef __AVR
base232::base232 (unsigned int baud_rate, unsigned char port_number)
    291c:	0f 93       	push	r16
    291e:	1f 93       	push	r17
    2920:	cf 93       	push	r28
    2922:	df 93       	push	r29
    2924:	ec 01       	movw	r28, r24
{
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A
		if (port_number == 0)
    2926:	44 23       	and	r20, r20
    2928:	09 f4       	brne	.+2      	; 0x292c <_ZN7base232C1Ejh+0x10>
    292a:	45 c0       	rjmp	.+138    	; 0x29b6 <_ZN7base232C1Ejh+0x9a>
			mask_TXC = (1 << TXC0);
		}
		else	// The port number isn't 0, so it presumably must be serial port 1
		{
		#if defined UCSR1A
			p_UDR = &UDR1;
    292c:	8e ec       	ldi	r24, 0xCE	; 206
    292e:	90 e0       	ldi	r25, 0x00	; 0
    2930:	99 83       	std	Y+1, r25	; 0x01
    2932:	88 83       	st	Y, r24
			p_USR = &UCSR1A;
    2934:	88 ec       	ldi	r24, 0xC8	; 200
    2936:	90 e0       	ldi	r25, 0x00	; 0
    2938:	9b 83       	std	Y+3, r25	; 0x03
    293a:	8a 83       	std	Y+2, r24	; 0x02
			p_UCR = &UCSR1B;
    293c:	89 ec       	ldi	r24, 0xC9	; 201
    293e:	90 e0       	ldi	r25, 0x00	; 0
    2940:	9d 83       	std	Y+5, r25	; 0x05
    2942:	8c 83       	std	Y+4, r24	; 0x04
			UCSR1B = (1 << RXEN1) | (1 << TXEN1);
    2944:	88 e1       	ldi	r24, 0x18	; 24
    2946:	80 93 c9 00 	sts	0x00C9, r24
			UCSR1C = (1 << UCSZ11) | (1 << UCSZ10); // | (1 << USBS1);
    294a:	86 e0       	ldi	r24, 0x06	; 6
    294c:	80 93 ca 00 	sts	0x00CA, r24
			UBRR1H = 0x00;
    2950:	10 92 cd 00 	sts	0x00CD, r1
			UBRR1L = calc_baud_div (baud_rate);
    2954:	8b 01       	movw	r16, r22
    2956:	20 e0       	ldi	r18, 0x00	; 0
    2958:	30 e0       	ldi	r19, 0x00	; 0
    295a:	00 0f       	add	r16, r16
    295c:	11 1f       	adc	r17, r17
    295e:	22 1f       	adc	r18, r18
    2960:	33 1f       	adc	r19, r19
    2962:	00 0f       	add	r16, r16
    2964:	11 1f       	adc	r17, r17
    2966:	22 1f       	adc	r18, r18
    2968:	33 1f       	adc	r19, r19
    296a:	00 0f       	add	r16, r16
    296c:	11 1f       	adc	r17, r17
    296e:	22 1f       	adc	r18, r18
    2970:	33 1f       	adc	r19, r19
    2972:	00 0f       	add	r16, r16
    2974:	11 1f       	adc	r17, r17
    2976:	22 1f       	adc	r18, r18
    2978:	33 1f       	adc	r19, r19
    297a:	60 e0       	ldi	r22, 0x00	; 0
    297c:	74 e2       	ldi	r23, 0x24	; 36
    297e:	84 ef       	ldi	r24, 0xF4	; 244
    2980:	90 e0       	ldi	r25, 0x00	; 0
    2982:	a9 01       	movw	r20, r18
    2984:	98 01       	movw	r18, r16
    2986:	0e 94 51 16 	call	0x2ca2	; 0x2ca2 <__udivmodsi4>
    298a:	20 93 cc 00 	sts	0x00CC, r18
			#ifdef UART_DOUBLE_SPEED		// If double-speed macro has been defined,
				UCSR1A |= U2X1;				// turn on double-speed operation
    298e:	80 91 c8 00 	lds	r24, 0x00C8
    2992:	81 60       	ori	r24, 0x01	; 1
    2994:	80 93 c8 00 	sts	0x00C8, r24
			#endif
			mask_UDRE = (1 << UDRE1);
    2998:	80 e2       	ldi	r24, 0x20	; 32
    299a:	8e 83       	std	Y+6, r24	; 0x06
			mask_RXC = (1 << RXC1);
    299c:	80 e8       	ldi	r24, 0x80	; 128
    299e:	8f 83       	std	Y+7, r24	; 0x07
			mask_TXC = (1 << TXC1);
    29a0:	80 e4       	ldi	r24, 0x40	; 64
    29a2:	88 87       	std	Y+8, r24	; 0x08
			mask_TXC = (1 << TXC);
		#endif // UCSRA
	#endif // UCSR0A

	// Read the data register to ensure that it's empty
	port_number = *p_UDR;
    29a4:	e8 81       	ld	r30, Y
    29a6:	f9 81       	ldd	r31, Y+1	; 0x01
    29a8:	80 81       	ld	r24, Z
	port_number = *p_UDR;
    29aa:	80 81       	ld	r24, Z
}
    29ac:	df 91       	pop	r29
    29ae:	cf 91       	pop	r28
    29b0:	1f 91       	pop	r17
    29b2:	0f 91       	pop	r16
    29b4:	08 95       	ret
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A
		if (port_number == 0)
		{
			p_UDR = &UDR0;
    29b6:	86 ec       	ldi	r24, 0xC6	; 198
    29b8:	90 e0       	ldi	r25, 0x00	; 0
    29ba:	99 83       	std	Y+1, r25	; 0x01
    29bc:	88 83       	st	Y, r24
			p_USR = &UCSR0A;
    29be:	80 ec       	ldi	r24, 0xC0	; 192
    29c0:	90 e0       	ldi	r25, 0x00	; 0
    29c2:	9b 83       	std	Y+3, r25	; 0x03
    29c4:	8a 83       	std	Y+2, r24	; 0x02
			p_UCR = &UCSR0B;
    29c6:	81 ec       	ldi	r24, 0xC1	; 193
    29c8:	90 e0       	ldi	r25, 0x00	; 0
    29ca:	9d 83       	std	Y+5, r25	; 0x05
    29cc:	8c 83       	std	Y+4, r24	; 0x04
			UCSR0B = (1 << RXEN0) | (1 << TXEN0);
    29ce:	88 e1       	ldi	r24, 0x18	; 24
    29d0:	80 93 c1 00 	sts	0x00C1, r24
			UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); // | (1 << USBS0);
    29d4:	86 e0       	ldi	r24, 0x06	; 6
    29d6:	80 93 c2 00 	sts	0x00C2, r24
			UBRR0H = 0x00;
    29da:	10 92 c5 00 	sts	0x00C5, r1
			UBRR0L = calc_baud_div (baud_rate);
    29de:	8b 01       	movw	r16, r22
    29e0:	20 e0       	ldi	r18, 0x00	; 0
    29e2:	30 e0       	ldi	r19, 0x00	; 0
    29e4:	00 0f       	add	r16, r16
    29e6:	11 1f       	adc	r17, r17
    29e8:	22 1f       	adc	r18, r18
    29ea:	33 1f       	adc	r19, r19
    29ec:	00 0f       	add	r16, r16
    29ee:	11 1f       	adc	r17, r17
    29f0:	22 1f       	adc	r18, r18
    29f2:	33 1f       	adc	r19, r19
    29f4:	00 0f       	add	r16, r16
    29f6:	11 1f       	adc	r17, r17
    29f8:	22 1f       	adc	r18, r18
    29fa:	33 1f       	adc	r19, r19
    29fc:	00 0f       	add	r16, r16
    29fe:	11 1f       	adc	r17, r17
    2a00:	22 1f       	adc	r18, r18
    2a02:	33 1f       	adc	r19, r19
    2a04:	60 e0       	ldi	r22, 0x00	; 0
    2a06:	74 e2       	ldi	r23, 0x24	; 36
    2a08:	84 ef       	ldi	r24, 0xF4	; 244
    2a0a:	90 e0       	ldi	r25, 0x00	; 0
    2a0c:	a9 01       	movw	r20, r18
    2a0e:	98 01       	movw	r18, r16
    2a10:	0e 94 51 16 	call	0x2ca2	; 0x2ca2 <__udivmodsi4>
    2a14:	20 93 c4 00 	sts	0x00C4, r18
			#ifdef UART_DOUBLE_SPEED					// Activate double speed mode
				UCSR0A |= U2X0;							// if required
    2a18:	80 91 c0 00 	lds	r24, 0x00C0
    2a1c:	81 60       	ori	r24, 0x01	; 1
    2a1e:	80 93 c0 00 	sts	0x00C0, r24
    2a22:	ba cf       	rjmp	.-140    	; 0x2998 <_ZN7base232C1Ejh+0x7c>

00002a24 <_ZN7base23213ready_to_sendEv>:
 *  tests whether transmitter buffer is empty. 
 *  @return True if the serial port is ready to send, and false if not
 */

bool base232::ready_to_send (void)
{
    2a24:	fc 01       	movw	r30, r24
#ifdef __AVR
	// If transmitter buffer is full, we're not ready to send
	if (*p_USR & mask_UDRE)
    2a26:	a2 81       	ldd	r26, Z+2	; 0x02
    2a28:	b3 81       	ldd	r27, Z+3	; 0x03
    2a2a:	9c 91       	ld	r25, X
    2a2c:	86 81       	ldd	r24, Z+6	; 0x06
    2a2e:	98 23       	and	r25, r24
/** This method checks if the serial port transmitter is ready to send data.  It 
 *  tests whether transmitter buffer is empty. 
 *  @return True if the serial port is ready to send, and false if not
 */

bool base232::ready_to_send (void)
    2a30:	81 e0       	ldi	r24, 0x01	; 1
    2a32:	09 f4       	brne	.+2      	; 0x2a36 <_ZN7base23213ready_to_sendEv+0x12>
    2a34:	80 e0       	ldi	r24, 0x00	; 0
	return (false);
#else
	// The non-AVR (that is, PC) serial port buffer should always be ready
	return (true);
#endif
}
    2a36:	08 95       	ret

00002a38 <_ZN7base23210is_sendingEv>:
 *  has been sent. 
 *  @return True if the port is currently sending a character, false if it's idle
 */

bool base232::is_sending (void)
{
    2a38:	fc 01       	movw	r30, r24
#ifdef __AVR
	if (*p_USR & mask_TXC)
    2a3a:	a2 81       	ldd	r26, Z+2	; 0x02
    2a3c:	b3 81       	ldd	r27, Z+3	; 0x03
    2a3e:	9c 91       	ld	r25, X
    2a40:	80 85       	ldd	r24, Z+8	; 0x08
    2a42:	98 23       	and	r25, r24
 *  last one; it would be a bad idea to put the processor to sleep before the character
 *  has been sent. 
 *  @return True if the port is currently sending a character, false if it's idle
 */

bool base232::is_sending (void)
    2a44:	81 e0       	ldi	r24, 0x01	; 1
    2a46:	09 f0       	breq	.+2      	; 0x2a4a <_ZN7base23210is_sendingEv+0x12>
    2a48:	80 e0       	ldi	r24, 0x00	; 0
		return (true);
#else
	// We don't really care if a PC is sending, as it has a buffer anyway
	return (false);
#endif
}
    2a4a:	08 95       	ret

00002a4c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2a4c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2a4e:	03 96       	adiw	r24, 0x03	; 3
    2a50:	92 83       	std	Z+2, r25	; 0x02
    2a52:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2a54:	4f ef       	ldi	r20, 0xFF	; 255
    2a56:	5f ef       	ldi	r21, 0xFF	; 255
    2a58:	ba 01       	movw	r22, r20
    2a5a:	43 83       	std	Z+3, r20	; 0x03
    2a5c:	54 83       	std	Z+4, r21	; 0x04
    2a5e:	65 83       	std	Z+5, r22	; 0x05
    2a60:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2a62:	90 87       	std	Z+8, r25	; 0x08
    2a64:	87 83       	std	Z+7, r24	; 0x07
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    2a66:	92 87       	std	Z+10, r25	; 0x0a
    2a68:	81 87       	std	Z+9, r24	; 0x09

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    2a6a:	10 82       	st	Z, r1
}
    2a6c:	08 95       	ret

00002a6e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2a6e:	fc 01       	movw	r30, r24
    2a70:	13 86       	std	Z+11, r1	; 0x0b
    2a72:	12 86       	std	Z+10, r1	; 0x0a
}
    2a74:	08 95       	ret

00002a76 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    2a76:	cf 93       	push	r28
    2a78:	df 93       	push	r29
    2a7a:	ec 01       	movw	r28, r24
    2a7c:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2a7e:	89 81       	ldd	r24, Y+1	; 0x01
    2a80:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    2a82:	dc 01       	movw	r26, r24
    2a84:	14 96       	adiw	r26, 0x04	; 4
    2a86:	2d 91       	ld	r18, X+
    2a88:	3c 91       	ld	r19, X
    2a8a:	15 97       	sbiw	r26, 0x05	; 5
    2a8c:	35 83       	std	Z+5, r19	; 0x05
    2a8e:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2a90:	97 83       	std	Z+7, r25	; 0x07
    2a92:	86 83       	std	Z+6, r24	; 0x06
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2a94:	14 96       	adiw	r26, 0x04	; 4
    2a96:	2d 91       	ld	r18, X+
    2a98:	3c 91       	ld	r19, X
    2a9a:	15 97       	sbiw	r26, 0x05	; 5
    2a9c:	d9 01       	movw	r26, r18
    2a9e:	17 96       	adiw	r26, 0x07	; 7
    2aa0:	7c 93       	st	X, r23
    2aa2:	6e 93       	st	-X, r22
    2aa4:	16 97       	sbiw	r26, 0x06	; 6
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    2aa6:	dc 01       	movw	r26, r24
    2aa8:	15 96       	adiw	r26, 0x05	; 5
    2aaa:	7c 93       	st	X, r23
    2aac:	6e 93       	st	-X, r22
    2aae:	14 97       	sbiw	r26, 0x04	; 4
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    2ab0:	7a 83       	std	Y+2, r23	; 0x02
    2ab2:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2ab4:	d3 87       	std	Z+11, r29	; 0x0b
    2ab6:	c2 87       	std	Z+10, r28	; 0x0a

	( pxList->uxNumberOfItems )++;
    2ab8:	88 81       	ld	r24, Y
    2aba:	8f 5f       	subi	r24, 0xFF	; 255
    2abc:	88 83       	st	Y, r24
}
    2abe:	df 91       	pop	r29
    2ac0:	cf 91       	pop	r28
    2ac2:	08 95       	ret

00002ac4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2ac4:	cf 92       	push	r12
    2ac6:	df 92       	push	r13
    2ac8:	ef 92       	push	r14
    2aca:	ff 92       	push	r15
    2acc:	cf 93       	push	r28
    2ace:	df 93       	push	r29
    2ad0:	9c 01       	movw	r18, r24
    2ad2:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    2ad4:	48 81       	ld	r20, Y
    2ad6:	59 81       	ldd	r21, Y+1	; 0x01
    2ad8:	6a 81       	ldd	r22, Y+2	; 0x02
    2ada:	7b 81       	ldd	r23, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2adc:	4f 3f       	cpi	r20, 0xFF	; 255
    2ade:	8f ef       	ldi	r24, 0xFF	; 255
    2ae0:	58 07       	cpc	r21, r24
    2ae2:	8f ef       	ldi	r24, 0xFF	; 255
    2ae4:	68 07       	cpc	r22, r24
    2ae6:	8f ef       	ldi	r24, 0xFF	; 255
    2ae8:	78 07       	cpc	r23, r24
    2aea:	d1 f1       	breq	.+116    	; 0x2b60 <vListInsert+0x9c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2aec:	f9 01       	movw	r30, r18
    2aee:	33 96       	adiw	r30, 0x03	; 3
    2af0:	d9 01       	movw	r26, r18
    2af2:	17 96       	adiw	r26, 0x07	; 7
    2af4:	8d 91       	ld	r24, X+
    2af6:	9c 91       	ld	r25, X
    2af8:	18 97       	sbiw	r26, 0x08	; 8
    2afa:	dc 01       	movw	r26, r24
    2afc:	cd 90       	ld	r12, X+
    2afe:	dd 90       	ld	r13, X+
    2b00:	ed 90       	ld	r14, X+
    2b02:	fc 90       	ld	r15, X
    2b04:	13 97       	sbiw	r26, 0x03	; 3
    2b06:	4c 15       	cp	r20, r12
    2b08:	5d 05       	cpc	r21, r13
    2b0a:	6e 05       	cpc	r22, r14
    2b0c:	7f 05       	cpc	r23, r15
    2b0e:	78 f0       	brcs	.+30     	; 0x2b2e <vListInsert+0x6a>
    2b10:	04 80       	ldd	r0, Z+4	; 0x04
    2b12:	f5 81       	ldd	r31, Z+5	; 0x05
    2b14:	e0 2d       	mov	r30, r0
    2b16:	a4 81       	ldd	r26, Z+4	; 0x04
    2b18:	b5 81       	ldd	r27, Z+5	; 0x05
    2b1a:	8d 91       	ld	r24, X+
    2b1c:	9d 91       	ld	r25, X+
    2b1e:	0d 90       	ld	r0, X+
    2b20:	bc 91       	ld	r27, X
    2b22:	a0 2d       	mov	r26, r0
    2b24:	48 17       	cp	r20, r24
    2b26:	59 07       	cpc	r21, r25
    2b28:	6a 07       	cpc	r22, r26
    2b2a:	7b 07       	cpc	r23, r27
    2b2c:	88 f7       	brcc	.-30     	; 0x2b10 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2b2e:	a4 81       	ldd	r26, Z+4	; 0x04
    2b30:	b5 81       	ldd	r27, Z+5	; 0x05
    2b32:	bd 83       	std	Y+5, r27	; 0x05
    2b34:	ac 83       	std	Y+4, r26	; 0x04
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2b36:	17 96       	adiw	r26, 0x07	; 7
    2b38:	dc 93       	st	X, r29
    2b3a:	ce 93       	st	-X, r28
    2b3c:	16 97       	sbiw	r26, 0x06	; 6
	pxNewListItem->pxPrevious = pxIterator;
    2b3e:	ff 83       	std	Y+7, r31	; 0x07
    2b40:	ee 83       	std	Y+6, r30	; 0x06
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2b42:	d5 83       	std	Z+5, r29	; 0x05
    2b44:	c4 83       	std	Z+4, r28	; 0x04

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2b46:	3b 87       	std	Y+11, r19	; 0x0b
    2b48:	2a 87       	std	Y+10, r18	; 0x0a

	( pxList->uxNumberOfItems )++;
    2b4a:	f9 01       	movw	r30, r18
    2b4c:	80 81       	ld	r24, Z
    2b4e:	8f 5f       	subi	r24, 0xFF	; 255
    2b50:	80 83       	st	Z, r24
}
    2b52:	df 91       	pop	r29
    2b54:	cf 91       	pop	r28
    2b56:	ff 90       	pop	r15
    2b58:	ef 90       	pop	r14
    2b5a:	df 90       	pop	r13
    2b5c:	cf 90       	pop	r12
    2b5e:	08 95       	ret
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2b60:	d9 01       	movw	r26, r18
    2b62:	19 96       	adiw	r26, 0x09	; 9
    2b64:	ed 91       	ld	r30, X+
    2b66:	fc 91       	ld	r31, X
    2b68:	1a 97       	sbiw	r26, 0x0a	; 10
    2b6a:	e1 cf       	rjmp	.-62     	; 0x2b2e <vListInsert+0x6a>

00002b6c <vListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    2b6c:	cf 93       	push	r28
    2b6e:	df 93       	push	r29
    2b70:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2b72:	a4 81       	ldd	r26, Z+4	; 0x04
    2b74:	b5 81       	ldd	r27, Z+5	; 0x05
    2b76:	86 81       	ldd	r24, Z+6	; 0x06
    2b78:	97 81       	ldd	r25, Z+7	; 0x07
    2b7a:	17 96       	adiw	r26, 0x07	; 7
    2b7c:	9c 93       	st	X, r25
    2b7e:	8e 93       	st	-X, r24
    2b80:	16 97       	sbiw	r26, 0x06	; 6
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2b82:	c6 81       	ldd	r28, Z+6	; 0x06
    2b84:	d7 81       	ldd	r29, Z+7	; 0x07
    2b86:	bd 83       	std	Y+5, r27	; 0x05
    2b88:	ac 83       	std	Y+4, r26	; 0x04
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    2b8a:	a2 85       	ldd	r26, Z+10	; 0x0a
    2b8c:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2b8e:	11 96       	adiw	r26, 0x01	; 1
    2b90:	8d 91       	ld	r24, X+
    2b92:	9c 91       	ld	r25, X
    2b94:	12 97       	sbiw	r26, 0x02	; 2
    2b96:	8e 17       	cp	r24, r30
    2b98:	9f 07       	cpc	r25, r31
    2b9a:	41 f0       	breq	.+16     	; 0x2bac <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
	}

	pxItemToRemove->pvContainer = NULL;
    2b9c:	13 86       	std	Z+11, r1	; 0x0b
    2b9e:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
    2ba0:	8c 91       	ld	r24, X
    2ba2:	81 50       	subi	r24, 0x01	; 1
    2ba4:	8c 93       	st	X, r24
}
    2ba6:	df 91       	pop	r29
    2ba8:	cf 91       	pop	r28
    2baa:	08 95       	ret
	pxList = ( xList * ) pxItemToRemove->pvContainer;

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2bac:	12 96       	adiw	r26, 0x02	; 2
    2bae:	dc 93       	st	X, r29
    2bb0:	ce 93       	st	-X, r28
    2bb2:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    2bb4:	13 86       	std	Z+11, r1	; 0x0b
    2bb6:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
    2bb8:	8c 91       	ld	r24, X
    2bba:	81 50       	subi	r24, 0x01	; 1
    2bbc:	8c 93       	st	X, r24
}
    2bbe:	df 91       	pop	r29
    2bc0:	cf 91       	pop	r28
    2bc2:	08 95       	ret

00002bc4 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    2bc4:	0f 93       	push	r16
    2bc6:	1f 93       	push	r17
    2bc8:	cf 93       	push	r28
    2bca:	df 93       	push	r29
    2bcc:	cd b7       	in	r28, 0x3d	; 61
    2bce:	de b7       	in	r29, 0x3e	; 62
    2bd0:	62 97       	sbiw	r28, 0x12	; 18
    2bd2:	0f b6       	in	r0, 0x3f	; 63
    2bd4:	f8 94       	cli
    2bd6:	de bf       	out	0x3e, r29	; 62
    2bd8:	0f be       	out	0x3f, r0	; 63
    2bda:	cd bf       	out	0x3d, r28	; 61
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on
	MCUSR = 0;
    2bdc:	14 be       	out	0x34, r1	; 52
	wdt_disable ();
    2bde:	88 e1       	ldi	r24, 0x18	; 24
    2be0:	0f b6       	in	r0, 0x3f	; 63
    2be2:	f8 94       	cli
    2be4:	80 93 60 00 	sts	0x0060, r24
    2be8:	10 92 60 00 	sts	0x0060, r1
    2bec:	0f be       	out	0x3f, r0	; 63

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_port (9600, 1);
    2bee:	ce 01       	movw	r24, r28
    2bf0:	01 96       	adiw	r24, 0x01	; 1
    2bf2:	60 e8       	ldi	r22, 0x80	; 128
    2bf4:	75 e2       	ldi	r23, 0x25	; 37
    2bf6:	41 e0       	ldi	r20, 0x01	; 1
    2bf8:	0e 94 ba 07 	call	0xf74	; 0xf74 <_ZN5rs232C1Ejh>
	ser_port << clrscr << PMS ("ME405 Lab 1 Starting Program") << endl;
    2bfc:	ce 01       	movw	r24, r28
    2bfe:	01 96       	adiw	r24, 0x01	; 1
    2c00:	67 e0       	ldi	r22, 0x07	; 7
    2c02:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
    2c06:	6a e0       	ldi	r22, 0x0A	; 10
    2c08:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>
    2c0c:	8c 01       	movw	r16, r24
    2c0e:	6c ec       	ldi	r22, 0xCC	; 204
    2c10:	70 e0       	ldi	r23, 0x00	; 0
    2c12:	0e 94 98 05 	call	0xb30	; 0xb30 <_ZN8emstream4putsEPKc>
    2c16:	c8 01       	movw	r24, r16
    2c18:	66 e0       	ldi	r22, 0x06	; 6
    2c1a:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_ZN8emstreamlsE15ser_manipulator>

	// Create the queues and other shared data items here
 	// print_ser_queue = new frt_text_queue (32, ser_port, 10);

	// Create a task which reads the A/D and adjusts an LED's brightness accordingly
	new motor_controller ("Bright", task_priority (2), 280, &ser_port);
    2c1e:	82 e1       	ldi	r24, 0x12	; 18
    2c20:	90 e0       	ldi	r25, 0x00	; 0
    2c22:	0e 94 61 05 	call	0xac2	; 0xac2 <_Znwj>
    2c26:	60 e0       	ldi	r22, 0x00	; 0
    2c28:	72 e0       	ldi	r23, 0x02	; 2
    2c2a:	42 e0       	ldi	r20, 0x02	; 2
    2c2c:	28 e1       	ldi	r18, 0x18	; 24
    2c2e:	31 e0       	ldi	r19, 0x01	; 1
    2c30:	8e 01       	movw	r16, r28
    2c32:	0f 5f       	subi	r16, 0xFF	; 255
    2c34:	1f 4f       	sbci	r17, 0xFF	; 255
    2c36:	0e 94 67 01 	call	0x2ce	; 0x2ce <_ZN16motor_controllerC1EPKchjP8emstream>

	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    2c3a:	0e 94 fe 0f 	call	0x1ffc	; 0x1ffc <vTaskStartScheduler>
}
    2c3e:	80 e0       	ldi	r24, 0x00	; 0
    2c40:	90 e0       	ldi	r25, 0x00	; 0
    2c42:	62 96       	adiw	r28, 0x12	; 18
    2c44:	0f b6       	in	r0, 0x3f	; 63
    2c46:	f8 94       	cli
    2c48:	de bf       	out	0x3e, r29	; 62
    2c4a:	0f be       	out	0x3f, r0	; 63
    2c4c:	cd bf       	out	0x3d, r28	; 61
    2c4e:	df 91       	pop	r29
    2c50:	cf 91       	pop	r28
    2c52:	1f 91       	pop	r17
    2c54:	0f 91       	pop	r16
    2c56:	08 95       	ret

00002c58 <_GLOBAL__sub_I_print_ser_queue>:
    2c58:	0f 93       	push	r16
    2c5a:	1f 93       	push	r17
/** This is a print queue, descended from \c emstream so that things can be printed 
 *  into the queue using the "<<" operator and they'll come out the other end as a 
 *  stream of characters. It's used by tasks that send things to the user interface 
 *  task to be printed. 
 */
frt_text_queue print_ser_queue (32, NULL, 10);
    2c5c:	8a e9       	ldi	r24, 0x9A	; 154
    2c5e:	92 e0       	ldi	r25, 0x02	; 2
    2c60:	60 e2       	ldi	r22, 0x20	; 32
    2c62:	70 e0       	ldi	r23, 0x00	; 0
    2c64:	40 e0       	ldi	r20, 0x00	; 0
    2c66:	50 e0       	ldi	r21, 0x00	; 0
    2c68:	0a e0       	ldi	r16, 0x0A	; 10
    2c6a:	10 e0       	ldi	r17, 0x00	; 0
    2c6c:	20 e0       	ldi	r18, 0x00	; 0
    2c6e:	30 e0       	ldi	r19, 0x00	; 0
    2c70:	0e 94 29 05 	call	0xa52	; 0xa52 <_ZN14frt_text_queueC1EjP8emstreamm>
	new motor_controller ("Bright", task_priority (2), 280, &ser_port);

	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    2c74:	1f 91       	pop	r17
    2c76:	0f 91       	pop	r16
    2c78:	08 95       	ret

00002c7a <__udivmodhi4>:
    2c7a:	aa 1b       	sub	r26, r26
    2c7c:	bb 1b       	sub	r27, r27
    2c7e:	51 e1       	ldi	r21, 0x11	; 17
    2c80:	07 c0       	rjmp	.+14     	; 0x2c90 <__udivmodhi4_ep>

00002c82 <__udivmodhi4_loop>:
    2c82:	aa 1f       	adc	r26, r26
    2c84:	bb 1f       	adc	r27, r27
    2c86:	a6 17       	cp	r26, r22
    2c88:	b7 07       	cpc	r27, r23
    2c8a:	10 f0       	brcs	.+4      	; 0x2c90 <__udivmodhi4_ep>
    2c8c:	a6 1b       	sub	r26, r22
    2c8e:	b7 0b       	sbc	r27, r23

00002c90 <__udivmodhi4_ep>:
    2c90:	88 1f       	adc	r24, r24
    2c92:	99 1f       	adc	r25, r25
    2c94:	5a 95       	dec	r21
    2c96:	a9 f7       	brne	.-22     	; 0x2c82 <__udivmodhi4_loop>
    2c98:	80 95       	com	r24
    2c9a:	90 95       	com	r25
    2c9c:	bc 01       	movw	r22, r24
    2c9e:	cd 01       	movw	r24, r26
    2ca0:	08 95       	ret

00002ca2 <__udivmodsi4>:
    2ca2:	a1 e2       	ldi	r26, 0x21	; 33
    2ca4:	1a 2e       	mov	r1, r26
    2ca6:	aa 1b       	sub	r26, r26
    2ca8:	bb 1b       	sub	r27, r27
    2caa:	fd 01       	movw	r30, r26
    2cac:	0d c0       	rjmp	.+26     	; 0x2cc8 <__udivmodsi4_ep>

00002cae <__udivmodsi4_loop>:
    2cae:	aa 1f       	adc	r26, r26
    2cb0:	bb 1f       	adc	r27, r27
    2cb2:	ee 1f       	adc	r30, r30
    2cb4:	ff 1f       	adc	r31, r31
    2cb6:	a2 17       	cp	r26, r18
    2cb8:	b3 07       	cpc	r27, r19
    2cba:	e4 07       	cpc	r30, r20
    2cbc:	f5 07       	cpc	r31, r21
    2cbe:	20 f0       	brcs	.+8      	; 0x2cc8 <__udivmodsi4_ep>
    2cc0:	a2 1b       	sub	r26, r18
    2cc2:	b3 0b       	sbc	r27, r19
    2cc4:	e4 0b       	sbc	r30, r20
    2cc6:	f5 0b       	sbc	r31, r21

00002cc8 <__udivmodsi4_ep>:
    2cc8:	66 1f       	adc	r22, r22
    2cca:	77 1f       	adc	r23, r23
    2ccc:	88 1f       	adc	r24, r24
    2cce:	99 1f       	adc	r25, r25
    2cd0:	1a 94       	dec	r1
    2cd2:	69 f7       	brne	.-38     	; 0x2cae <__udivmodsi4_loop>
    2cd4:	60 95       	com	r22
    2cd6:	70 95       	com	r23
    2cd8:	80 95       	com	r24
    2cda:	90 95       	com	r25
    2cdc:	9b 01       	movw	r18, r22
    2cde:	ac 01       	movw	r20, r24
    2ce0:	bd 01       	movw	r22, r26
    2ce2:	cf 01       	movw	r24, r30
    2ce4:	08 95       	ret

00002ce6 <__tablejump_elpm__>:
    2ce6:	07 90       	elpm	r0, Z+
    2ce8:	f6 91       	elpm	r31, Z
    2cea:	e0 2d       	mov	r30, r0
    2cec:	09 94       	ijmp

00002cee <memcpy>:
    2cee:	fb 01       	movw	r30, r22
    2cf0:	dc 01       	movw	r26, r24
    2cf2:	02 c0       	rjmp	.+4      	; 0x2cf8 <memcpy+0xa>
    2cf4:	01 90       	ld	r0, Z+
    2cf6:	0d 92       	st	X+, r0
    2cf8:	41 50       	subi	r20, 0x01	; 1
    2cfa:	50 40       	sbci	r21, 0x00	; 0
    2cfc:	d8 f7       	brcc	.-10     	; 0x2cf4 <memcpy+0x6>
    2cfe:	08 95       	ret

00002d00 <memset>:
    2d00:	dc 01       	movw	r26, r24
    2d02:	01 c0       	rjmp	.+2      	; 0x2d06 <memset+0x6>
    2d04:	6d 93       	st	X+, r22
    2d06:	41 50       	subi	r20, 0x01	; 1
    2d08:	50 40       	sbci	r21, 0x00	; 0
    2d0a:	e0 f7       	brcc	.-8      	; 0x2d04 <memset+0x4>
    2d0c:	08 95       	ret

00002d0e <strncpy>:
    2d0e:	fb 01       	movw	r30, r22
    2d10:	dc 01       	movw	r26, r24
    2d12:	41 50       	subi	r20, 0x01	; 1
    2d14:	50 40       	sbci	r21, 0x00	; 0
    2d16:	48 f0       	brcs	.+18     	; 0x2d2a <strncpy+0x1c>
    2d18:	01 90       	ld	r0, Z+
    2d1a:	0d 92       	st	X+, r0
    2d1c:	00 20       	and	r0, r0
    2d1e:	c9 f7       	brne	.-14     	; 0x2d12 <strncpy+0x4>
    2d20:	01 c0       	rjmp	.+2      	; 0x2d24 <strncpy+0x16>
    2d22:	1d 92       	st	X+, r1
    2d24:	41 50       	subi	r20, 0x01	; 1
    2d26:	50 40       	sbci	r21, 0x00	; 0
    2d28:	e0 f7       	brcc	.-8      	; 0x2d22 <strncpy+0x14>
    2d2a:	08 95       	ret

00002d2c <ultoa>:
    2d2c:	fa 01       	movw	r30, r20
    2d2e:	cf 93       	push	r28
    2d30:	ff 93       	push	r31
    2d32:	ef 93       	push	r30
    2d34:	22 30       	cpi	r18, 0x02	; 2
    2d36:	cc f0       	brlt	.+50     	; 0x2d6a <ultoa+0x3e>
    2d38:	25 32       	cpi	r18, 0x25	; 37
    2d3a:	bc f4       	brge	.+46     	; 0x2d6a <ultoa+0x3e>
    2d3c:	c2 2f       	mov	r28, r18
    2d3e:	2c 2f       	mov	r18, r28
    2d40:	33 27       	eor	r19, r19
    2d42:	44 27       	eor	r20, r20
    2d44:	55 27       	eor	r21, r21
    2d46:	ff 93       	push	r31
    2d48:	ef 93       	push	r30
    2d4a:	0e 94 51 16 	call	0x2ca2	; 0x2ca2 <__udivmodsi4>
    2d4e:	ef 91       	pop	r30
    2d50:	ff 91       	pop	r31
    2d52:	60 5d       	subi	r22, 0xD0	; 208
    2d54:	6a 33       	cpi	r22, 0x3A	; 58
    2d56:	0c f0       	brlt	.+2      	; 0x2d5a <ultoa+0x2e>
    2d58:	69 5d       	subi	r22, 0xD9	; 217
    2d5a:	61 93       	st	Z+, r22
    2d5c:	b9 01       	movw	r22, r18
    2d5e:	ca 01       	movw	r24, r20
    2d60:	60 50       	subi	r22, 0x00	; 0
    2d62:	70 40       	sbci	r23, 0x00	; 0
    2d64:	80 40       	sbci	r24, 0x00	; 0
    2d66:	90 40       	sbci	r25, 0x00	; 0
    2d68:	51 f7       	brne	.-44     	; 0x2d3e <ultoa+0x12>
    2d6a:	10 82       	st	Z, r1
    2d6c:	8f 91       	pop	r24
    2d6e:	9f 91       	pop	r25
    2d70:	cf 91       	pop	r28
    2d72:	0c 94 d1 16 	jmp	0x2da2	; 0x2da2 <strrev>

00002d76 <utoa>:
    2d76:	fb 01       	movw	r30, r22
    2d78:	9f 01       	movw	r18, r30
    2d7a:	42 30       	cpi	r20, 0x02	; 2
    2d7c:	74 f0       	brlt	.+28     	; 0x2d9a <utoa+0x24>
    2d7e:	45 32       	cpi	r20, 0x25	; 37
    2d80:	64 f4       	brge	.+24     	; 0x2d9a <utoa+0x24>
    2d82:	64 2f       	mov	r22, r20
    2d84:	77 27       	eor	r23, r23
    2d86:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <__udivmodhi4>
    2d8a:	80 5d       	subi	r24, 0xD0	; 208
    2d8c:	8a 33       	cpi	r24, 0x3A	; 58
    2d8e:	0c f0       	brlt	.+2      	; 0x2d92 <utoa+0x1c>
    2d90:	89 5d       	subi	r24, 0xD9	; 217
    2d92:	81 93       	st	Z+, r24
    2d94:	cb 01       	movw	r24, r22
    2d96:	00 97       	sbiw	r24, 0x00	; 0
    2d98:	a1 f7       	brne	.-24     	; 0x2d82 <utoa+0xc>
    2d9a:	10 82       	st	Z, r1
    2d9c:	c9 01       	movw	r24, r18
    2d9e:	0c 94 d1 16 	jmp	0x2da2	; 0x2da2 <strrev>

00002da2 <strrev>:
    2da2:	dc 01       	movw	r26, r24
    2da4:	fc 01       	movw	r30, r24
    2da6:	67 2f       	mov	r22, r23
    2da8:	71 91       	ld	r23, Z+
    2daa:	77 23       	and	r23, r23
    2dac:	e1 f7       	brne	.-8      	; 0x2da6 <strrev+0x4>
    2dae:	32 97       	sbiw	r30, 0x02	; 2
    2db0:	04 c0       	rjmp	.+8      	; 0x2dba <strrev+0x18>
    2db2:	7c 91       	ld	r23, X
    2db4:	6d 93       	st	X+, r22
    2db6:	70 83       	st	Z, r23
    2db8:	62 91       	ld	r22, -Z
    2dba:	ae 17       	cp	r26, r30
    2dbc:	bf 07       	cpc	r27, r31
    2dbe:	c8 f3       	brcs	.-14     	; 0x2db2 <strrev+0x10>
    2dc0:	08 95       	ret

00002dc2 <_exit>:
    2dc2:	f8 94       	cli

00002dc4 <__stop_program>:
    2dc4:	ff cf       	rjmp	.-2      	; 0x2dc4 <__stop_program>

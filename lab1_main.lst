
lab1_main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000009a  00800200  00002dbe  00002e52  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002dbe  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000017bc  0080029a  0080029a  00002eec  2**0
                  ALLOC
  3 .stab         00000c6c  00000000  00000000  00002eec  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000002ae  00000000  00000000  00003b58  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000348  00000000  00000000  00003e08  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000059c7  00000000  00000000  00004150  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000021a7  00000000  00000000  00009b17  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001c10  00000000  00000000  0000bcbe  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000e4c  00000000  00000000  0000d8d0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001eab  00000000  00000000  0000e71c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004120  00000000  00000000  000105c7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001e8  00000000  00000000  000146e7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__ctors_end>
       4:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
       8:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
       c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      10:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      14:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      18:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      1c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      20:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      24:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      28:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      2c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      30:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      34:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      38:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      3c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      40:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      44:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      48:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      4c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      50:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      54:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      58:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      5c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      60:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      64:	0c 94 03 08 	jmp	0x1006	; 0x1006 <__vector_25>
      68:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      6c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      70:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      74:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      78:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      7c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      80:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      84:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      88:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      8c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      90:	0c 94 50 08 	jmp	0x10a0	; 0x10a0 <__vector_36>
      94:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      98:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      9c:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      a0:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      a4:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      a8:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      ac:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      b0:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      b4:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      b8:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      bc:	0c 94 5c 0a 	jmp	0x14b8	; 0x14b8 <__vector_47>
      c0:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      c4:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>
      c8:	0c 94 05 01 	jmp	0x20a	; 0x20a <__bad_interrupt>

000000cc <_ZZ4mainE3__c>:
      cc:	4d 45 34 30 35 20 4c 61 62 20 31 20 53 74 61 72     ME405 Lab 1 Star
      dc:	74 69 6e 67 20 50 72 6f 67 72 61 6d 00              ting Program.

000000e9 <_ZZN8frt_taskC1EPKchjP8emstreamE3__c>:
      e9:	54 61 73 6b 20 00                                   Task .

000000ef <_ZZN8frt_taskC1EPKchjP8emstreamE3__c_0>:
      ef:	20 63 72 65 61 74 65 64 00                           created.

000000f8 <_ZZN8frt_taskC1EPKchjP8emstreamE3__c_1>:
      f8:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000106 <_ZZN8frt_taskC1EPKchjP8emstreamE3__c_2>:
     106:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     116:	61 73 6b 20 00                                      ask .

0000011b <_ZZN8frt_task15emergency_resetEvE3__c>:
     11b:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

0000012a <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     12a:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000134 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     134:	09 00                                               ..

00000136 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     136:	09 00                                               ..

00000138 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     138:	2f 00                                               /.

0000013a <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     13a:	09 00                                               ..

0000013c <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     13c:	09 00                                               ..

0000013e <_ZZ15print_task_listP8emstreamE3__c>:
     13e:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000149 <_ZZ15print_task_listP8emstreamE3__c_0>:
     149:	09 53 74 61 63 6b 00                                .Stack.

00000150 <_ZZ15print_task_listP8emstreamE3__c_1>:
     150:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000161 <_ZZ15print_task_listP8emstreamE3__c_2>:
     161:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

0000016d <_ZZ15print_task_listP8emstreamE3__c_3>:
     16d:	09 52 75 6e 73 00                                   .Runs.

00000173 <_ZZ15print_task_listP8emstreamE3__c_4>:
     173:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

00000184 <_ZZ15print_task_listP8emstreamE3__c_5>:
     184:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

00000190 <_ZZ15print_task_listP8emstreamE3__c_6>:
     190:	09 2d 2d 2d 2d 00                                   .----.

00000196 <_ZZ15print_task_listP8emstreamE3__c_7>:
     196:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000001a1 <_ZZ15print_task_listP8emstreamE3__c_8>:
     1a1:	2f 00                                               /.

000001a3 <_ZZ15print_task_listP8emstreamE3__c_9>:
     1a3:	09 09 00                                            ...

000001a6 <__ctors_start>:
     1a6:	28 16       	cp	r2, r24

000001a8 <__ctors_end>:
     1a8:	11 24       	eor	r1, r1
     1aa:	1f be       	out	0x3f, r1	; 63
     1ac:	cf ef       	ldi	r28, 0xFF	; 255
     1ae:	d1 e2       	ldi	r29, 0x21	; 33
     1b0:	de bf       	out	0x3e, r29	; 62
     1b2:	cd bf       	out	0x3d, r28	; 61

000001b4 <__do_copy_data>:
     1b4:	12 e0       	ldi	r17, 0x02	; 2
     1b6:	a0 e0       	ldi	r26, 0x00	; 0
     1b8:	b2 e0       	ldi	r27, 0x02	; 2
     1ba:	ee eb       	ldi	r30, 0xBE	; 190
     1bc:	fd e2       	ldi	r31, 0x2D	; 45
     1be:	00 e0       	ldi	r16, 0x00	; 0
     1c0:	0b bf       	out	0x3b, r16	; 59
     1c2:	02 c0       	rjmp	.+4      	; 0x1c8 <__do_copy_data+0x14>
     1c4:	07 90       	elpm	r0, Z+
     1c6:	0d 92       	st	X+, r0
     1c8:	aa 39       	cpi	r26, 0x9A	; 154
     1ca:	b1 07       	cpc	r27, r17
     1cc:	d9 f7       	brne	.-10     	; 0x1c4 <__do_copy_data+0x10>
     1ce:	1b be       	out	0x3b, r1	; 59

000001d0 <__do_clear_bss>:
     1d0:	1a e1       	ldi	r17, 0x1A	; 26
     1d2:	aa e9       	ldi	r26, 0x9A	; 154
     1d4:	b2 e0       	ldi	r27, 0x02	; 2
     1d6:	01 c0       	rjmp	.+2      	; 0x1da <.do_clear_bss_start>

000001d8 <.do_clear_bss_loop>:
     1d8:	1d 92       	st	X+, r1

000001da <.do_clear_bss_start>:
     1da:	a6 35       	cpi	r26, 0x56	; 86
     1dc:	b1 07       	cpc	r27, r17
     1de:	e1 f7       	brne	.-8      	; 0x1d8 <.do_clear_bss_loop>

000001e0 <__do_global_ctors>:
     1e0:	11 e0       	ldi	r17, 0x01	; 1
     1e2:	c8 ea       	ldi	r28, 0xA8	; 168
     1e4:	d1 e0       	ldi	r29, 0x01	; 1
     1e6:	00 e0       	ldi	r16, 0x00	; 0
     1e8:	06 c0       	rjmp	.+12     	; 0x1f6 <__do_global_ctors+0x16>
     1ea:	22 97       	sbiw	r28, 0x02	; 2
     1ec:	01 09       	sbc	r16, r1
     1ee:	fe 01       	movw	r30, r28
     1f0:	0b bf       	out	0x3b, r16	; 59
     1f2:	0e 94 6f 16 	call	0x2cde	; 0x2cde <__tablejump_elpm__>
     1f6:	c6 3a       	cpi	r28, 0xA6	; 166
     1f8:	d1 07       	cpc	r29, r17
     1fa:	80 e0       	ldi	r24, 0x00	; 0
     1fc:	08 07       	cpc	r16, r24
     1fe:	a9 f7       	brne	.-22     	; 0x1ea <__do_global_ctors+0xa>
     200:	1b be       	out	0x3b, r1	; 59
     202:	0e 94 de 15 	call	0x2bbc	; 0x2bbc <main>
     206:	0c 94 dd 16 	jmp	0x2dba	; 0x2dba <_exit>

0000020a <__bad_interrupt>:
     20a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000020e <_ZN16motor_controller3runEv>:
 *  loop, it reads the A/D converter and uses the result to control the brightness of 
 *  an LED. 
 */

void motor_controller::run (void)
{
     20e:	cf 93       	push	r28
     210:	df 93       	push	r29
     212:	00 d0       	rcall	.+0      	; 0x214 <_ZN16motor_controller3runEv+0x6>
     214:	00 d0       	rcall	.+0      	; 0x216 <_ZN16motor_controller3runEv+0x8>
     216:	cd b7       	in	r28, 0x3d	; 61
     218:	de b7       	in	r29, 0x3e	; 62
     21a:	2c 01       	movw	r4, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     21c:	0e 94 3f 10 	call	0x207e	; 0x207e <xTaskGetTickCount>
     220:	dc 01       	movw	r26, r24
     222:	cb 01       	movw	r24, r22
     224:	89 83       	std	Y+1, r24	; 0x01
     226:	9a 83       	std	Y+2, r25	; 0x02
     228:	ab 83       	std	Y+3, r26	; 0x03
     22a:	bc 83       	std	Y+4, r27	; 0x04

	// (1 << COM1A1) | (1 << COM1B1) | (1 << COM1C1) | (1 << WGM10) Fast PWM 8-bit
   // (1 << WGM12) | (1 << CS11) | (1 << CS10) clk/64 (prescaler)
   // outputs 16E6/64/255 = 980Hz PWM
	motor_driver *p_my_motor_driver1 = new motor_driver(p_serial, &DDRC, 0x06, &DDRB, 0x20, &TCCR1A, 0xA9, &TCCR1B, 0x0B, &OCR1B);
     22c:	84 e0       	ldi	r24, 0x04	; 4
     22e:	90 e0       	ldi	r25, 0x00	; 0
     230:	0e 94 5d 05 	call	0xaba	; 0xaba <_Znwj>
     234:	3c 01       	movw	r6, r24
     236:	00 d0       	rcall	.+0      	; 0x238 <_ZN16motor_controller3runEv+0x2a>
     238:	0f 92       	push	r0
     23a:	f2 01       	movw	r30, r4
     23c:	66 81       	ldd	r22, Z+6	; 0x06
     23e:	77 81       	ldd	r23, Z+7	; 0x07
     240:	2b e0       	ldi	r18, 0x0B	; 11
     242:	f2 2e       	mov	r15, r18
     244:	ed b7       	in	r30, 0x3d	; 61
     246:	fe b7       	in	r31, 0x3e	; 62
     248:	f1 82       	std	Z+1, r15	; 0x01
     24a:	8a e8       	ldi	r24, 0x8A	; 138
     24c:	90 e0       	ldi	r25, 0x00	; 0
     24e:	93 83       	std	Z+3, r25	; 0x03
     250:	82 83       	std	Z+2, r24	; 0x02
     252:	c3 01       	movw	r24, r6
     254:	47 e2       	ldi	r20, 0x27	; 39
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	26 e0       	ldi	r18, 0x06	; 6
     25a:	04 e2       	ldi	r16, 0x24	; 36
     25c:	10 e0       	ldi	r17, 0x00	; 0
     25e:	30 e2       	ldi	r19, 0x20	; 32
     260:	e3 2e       	mov	r14, r19
     262:	30 e8       	ldi	r19, 0x80	; 128
     264:	c3 2e       	mov	r12, r19
     266:	d1 2c       	mov	r13, r1
     268:	39 ea       	ldi	r19, 0xA9	; 169
     26a:	a3 2e       	mov	r10, r19
     26c:	31 e8       	ldi	r19, 0x81	; 129
     26e:	83 2e       	mov	r8, r19
     270:	91 2c       	mov	r9, r1
     272:	0e 94 2d 02 	call	0x45a	; 0x45a <_ZN12motor_driverC1EP8emstreamPVhhS3_hS3_hS3_hPVj>
	motor_driver *p_my_motor_driver2 = new motor_driver(p_serial, &DDRD, 0x70, &DDRB, 0x10, &TCCR1A, 0xA9, &TCCR1B, 0x0B, &OCR1A);
     276:	0f 90       	pop	r0
     278:	0f 90       	pop	r0
     27a:	0f 90       	pop	r0
     27c:	84 e0       	ldi	r24, 0x04	; 4
     27e:	90 e0       	ldi	r25, 0x00	; 0
     280:	0e 94 5d 05 	call	0xaba	; 0xaba <_Znwj>
     284:	00 d0       	rcall	.+0      	; 0x286 <_ZN16motor_controller3runEv+0x78>
     286:	0f 92       	push	r0
     288:	f2 01       	movw	r30, r4
     28a:	66 81       	ldd	r22, Z+6	; 0x06
     28c:	77 81       	ldd	r23, Z+7	; 0x07
     28e:	ed b7       	in	r30, 0x3d	; 61
     290:	fe b7       	in	r31, 0x3e	; 62
     292:	f1 82       	std	Z+1, r15	; 0x01
     294:	28 e8       	ldi	r18, 0x88	; 136
     296:	30 e0       	ldi	r19, 0x00	; 0
     298:	33 83       	std	Z+3, r19	; 0x03
     29a:	22 83       	std	Z+2, r18	; 0x02
     29c:	4a e2       	ldi	r20, 0x2A	; 42
     29e:	50 e0       	ldi	r21, 0x00	; 0
     2a0:	20 e7       	ldi	r18, 0x70	; 112
     2a2:	ee 24       	eor	r14, r14
     2a4:	68 94       	set
     2a6:	e4 f8       	bld	r14, 4
     2a8:	0e 94 2d 02 	call	0x45a	; 0x45a <_ZN12motor_driverC1EP8emstreamPVhhS3_hS3_hS3_hPVj>

	// Configure counter/timer 3 as a PWM for LED brightness. First set the data
	// direction register so that the pin used for the PWM will be an output. The 
	// pin is Port E pin 4, which is also OC3B (Output Compare B for Timer 3)
	DDRE = (1 << 4);
     2ac:	80 e1       	ldi	r24, 0x10	; 16
     2ae:	8d b9       	out	0x0d, r24	; 13
	// To set 8-bit fast PWM mode we must set bits WGM30 and WGM32, which are in two
	// different registers (ugh). We use COM3B1 and Com3B0 to set up the PWM so that
	// the pin output will have inverted sense, that is, a 0 is on and a 1 is off; 
	// this is needed because the LED connects from Vcc to the pin. 
	TCCR3A = (1 << WGM30)
			 | (1 << COM3B1) | (1 << COM3B0);
     2b0:	81 e3       	ldi	r24, 0x31	; 49
     2b2:	80 93 90 00 	sts	0x0090, r24

	// The CS31 and CS30 bits set the prescaler for this timer/counter to run the
	// timer at F_CPU / 64
	TCCR3B = (1 << WGM32)
			 | (1 << CS31)  | (1 << CS30);
     2b6:	f0 92 91 00 	sts	0x0091, r15
     2ba:	0f 90       	pop	r0
     2bc:	0f 90       	pop	r0
     2be:	0f 90       	pop	r0

	// This is the task loop for the brightness control task. This loop runs until the
	// power is turned off or something equally dramatic occurs
	for (;;)
	{
      p_my_motor_driver1->sample();
     2c0:	c3 01       	movw	r24, r6
     2c2:	0e 94 69 02 	call	0x4d2	; 0x4d2 <_ZN12motor_driver6sampleEv>
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     2c6:	ce 01       	movw	r24, r28
     2c8:	01 96       	adiw	r24, 0x01	; 1
     2ca:	44 e6       	ldi	r20, 0x64	; 100
     2cc:	50 e0       	ldi	r21, 0x00	; 0
     2ce:	60 e0       	ldi	r22, 0x00	; 0
     2d0:	70 e0       	ldi	r23, 0x00	; 0
     2d2:	0e 94 28 12 	call	0x2450	; 0x2450 <vTaskDelayUntil>
     2d6:	f4 cf       	rjmp	.-24     	; 0x2c0 <_ZN16motor_controller3runEv+0xb2>

000002d8 <_ZN16motor_controllerC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

motor_controller::motor_controller (const char* a_name, 
     2d8:	0f 93       	push	r16
     2da:	1f 93       	push	r17
     2dc:	cf 93       	push	r28
     2de:	df 93       	push	r29
     2e0:	ec 01       	movw	r28, r24
								 unsigned portBASE_TYPE a_priority, 
								 size_t a_stack_size,
								 emstream* p_ser_dev
								)
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     2e2:	0e 94 97 02 	call	0x52e	; 0x52e <_ZN8frt_taskC1EPKchjP8emstream>
     2e6:	8b e0       	ldi	r24, 0x0B	; 11
     2e8:	92 e0       	ldi	r25, 0x02	; 2
     2ea:	99 83       	std	Y+1, r25	; 0x01
     2ec:	88 83       	st	Y, r24
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     2ee:	df 91       	pop	r29
     2f0:	cf 91       	pop	r28
     2f2:	1f 91       	pop	r17
     2f4:	0f 91       	pop	r16
     2f6:	08 95       	ret

000002f8 <_ZN3adcC1EP8emstream>:
/** \brief This constructor sets up an A/D converter. 
 *  \details \b Details: The A/D converter is enabled and the division factor is set to 32.
 *  @param p_serial_port A pointer to the serial port where debugging info is written. 
 */

adc::adc (emstream* p_serial_port) {  
     2f8:	cf 93       	push	r28
     2fa:	df 93       	push	r29
     2fc:	fc 01       	movw	r30, r24
	ptr_to_serial = p_serial_port;
     2fe:	71 83       	std	Z+1, r23	; 0x01
     300:	60 83       	st	Z, r22
   
   // Set AVCC with external capacitor at AREF pin.
	ADMUX = (1 << REFS0);
     302:	80 e4       	ldi	r24, 0x40	; 64
     304:	80 93 7c 00 	sts	0x007C, r24
	ADMUX_init = ADMUX;
     308:	80 91 7c 00 	lds	r24, 0x007C
     30c:	82 83       	std	Z+2, r24	; 0x02
	
	// Enable ADC and set prescaler to 32.
	ADCSRA = (1 << ADEN) | (1 << ADPS2) | (1 << ADPS0);
     30e:	85 e8       	ldi	r24, 0x85	; 133
     310:	80 93 7a 00 	sts	0x007A, r24

	// Print a handy debugging message
  	DBG (ptr_to_serial, "A/D constructor OK" << endl);
     314:	c0 81       	ld	r28, Z
     316:	d1 81       	ldd	r29, Z+1	; 0x01
     318:	20 97       	sbiw	r28, 0x00	; 0
     31a:	49 f0       	breq	.+18     	; 0x32e <_ZN3adcC1EP8emstream+0x36>
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     31c:	ce 01       	movw	r24, r28
     31e:	6f e0       	ldi	r22, 0x0F	; 15
     320:	72 e0       	ldi	r23, 0x02	; 2
     322:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
     326:	ce 01       	movw	r24, r28
     328:	66 e0       	ldi	r22, 0x06	; 6
     32a:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
}
     32e:	df 91       	pop	r29
     330:	cf 91       	pop	r28
     332:	08 95       	ret

00000334 <_ZN3adc9read_onceEh>:

uint16_t adc::read_once (uint8_t ch) {
   uint8_t i = 0;
   uint16_t result;

   ADMUX = ADMUX_init;
     334:	fc 01       	movw	r30, r24
     336:	82 81       	ldd	r24, Z+2	; 0x02
     338:	80 93 7c 00 	sts	0x007C, r24
   ADMUX |= ch;
     33c:	80 91 7c 00 	lds	r24, 0x007C
     340:	68 2b       	or	r22, r24
     342:	60 93 7c 00 	sts	0x007C, r22

   // start conversion with ADSC
   ADCSRA |= (1 << ADSC);
     346:	80 91 7a 00 	lds	r24, 0x007A
     34a:	80 64       	ori	r24, 0x40	; 64
     34c:	80 93 7a 00 	sts	0x007A, r24
   while (ADCSRA & (1 << ADSC) && i < 65) {
     350:	80 91 7a 00 	lds	r24, 0x007A
     354:	86 ff       	sbrs	r24, 6
     356:	1b c0       	rjmp	.+54     	; 0x38e <_ZN3adc9read_onceEh+0x5a>
     358:	90 e0       	ldi	r25, 0x00	; 0
      i++;
     35a:	9f 5f       	subi	r25, 0xFF	; 255
   ADMUX = ADMUX_init;
   ADMUX |= ch;

   // start conversion with ADSC
   ADCSRA |= (1 << ADSC);
   while (ADCSRA & (1 << ADSC) && i < 65) {
     35c:	80 91 7a 00 	lds	r24, 0x007A
     360:	86 fd       	sbrc	r24, 6
     362:	0c c0       	rjmp	.+24     	; 0x37c <_ZN3adc9read_onceEh+0x48>
      i++;
   }
   
   result = ADCL | (ADCH << 8);
     364:	80 91 78 00 	lds	r24, 0x0078
     368:	40 91 79 00 	lds	r20, 0x0079
   //DBG (ptr_to_serial, "result: " << result << endl);
   return i == 65 ? -1 : result;
     36c:	91 34       	cpi	r25, 0x41	; 65
     36e:	c9 f0       	breq	.+50     	; 0x3a2 <_ZN3adc9read_onceEh+0x6e>
   ADCSRA |= (1 << ADSC);
   while (ADCSRA & (1 << ADSC) && i < 65) {
      i++;
   }
   
   result = ADCL | (ADCH << 8);
     370:	34 2f       	mov	r19, r20
     372:	20 e0       	ldi	r18, 0x00	; 0
     374:	90 e0       	ldi	r25, 0x00	; 0
     376:	82 2b       	or	r24, r18
     378:	93 2b       	or	r25, r19
     37a:	08 95       	ret
   ADMUX = ADMUX_init;
   ADMUX |= ch;

   // start conversion with ADSC
   ADCSRA |= (1 << ADSC);
   while (ADCSRA & (1 << ADSC) && i < 65) {
     37c:	91 34       	cpi	r25, 0x41	; 65
     37e:	69 f7       	brne	.-38     	; 0x35a <_ZN3adc9read_onceEh+0x26>
      i++;
   }
   
   result = ADCL | (ADCH << 8);
     380:	80 91 78 00 	lds	r24, 0x0078
     384:	80 91 79 00 	lds	r24, 0x0079
   //DBG (ptr_to_serial, "result: " << result << endl);
   return i == 65 ? -1 : result;
     388:	8f ef       	ldi	r24, 0xFF	; 255
     38a:	9f ef       	ldi	r25, 0xFF	; 255
     38c:	08 95       	ret
   ADCSRA |= (1 << ADSC);
   while (ADCSRA & (1 << ADSC) && i < 65) {
      i++;
   }
   
   result = ADCL | (ADCH << 8);
     38e:	80 91 78 00 	lds	r24, 0x0078
     392:	90 91 79 00 	lds	r25, 0x0079
     396:	39 2f       	mov	r19, r25
     398:	20 e0       	ldi	r18, 0x00	; 0
     39a:	90 e0       	ldi	r25, 0x00	; 0
     39c:	82 2b       	or	r24, r18
     39e:	93 2b       	or	r25, r19
     3a0:	08 95       	ret
   //DBG (ptr_to_serial, "result: " << result << endl);
   return i == 65 ? -1 : result;
     3a2:	8f ef       	ldi	r24, 0xFF	; 255
     3a4:	9f ef       	ldi	r25, 0xFF	; 255
}
     3a6:	08 95       	ret

000003a8 <_ZN3adc16read_oversampledEhh>:
 *  @param channel A selected channel to read from.
 *  @param samples The chosen number of samples.
 *  @return The average readings from a chosen number of samples.
 */

uint16_t adc::read_oversampled (uint8_t channel, uint8_t samples) {
     3a8:	df 92       	push	r13
     3aa:	ef 92       	push	r14
     3ac:	ff 92       	push	r15
     3ae:	0f 93       	push	r16
     3b0:	1f 93       	push	r17
     3b2:	cf 93       	push	r28
     3b4:	df 93       	push	r29
     3b6:	8c 01       	movw	r16, r24
     3b8:	f6 2e       	mov	r15, r22
     3ba:	d4 2e       	mov	r13, r20
	uint16_t sum = 0;
     3bc:	80 e2       	ldi	r24, 0x20	; 32
     3be:	84 17       	cp	r24, r20
     3c0:	e0 f4       	brcc	.+56     	; 0x3fa <_ZN3adc16read_oversampledEhh+0x52>
     3c2:	80 e2       	ldi	r24, 0x20	; 32
     3c4:	d8 2e       	mov	r13, r24

   if (samples > 32) {
      samples = 32;
   }
   
   for (i = 0; i < samples; i++) {
     3c6:	ee 24       	eor	r14, r14
     3c8:	c0 e0       	ldi	r28, 0x00	; 0
     3ca:	d0 e0       	ldi	r29, 0x00	; 0
      sum += read_once(channel);
     3cc:	c8 01       	movw	r24, r16
     3ce:	6f 2d       	mov	r22, r15
     3d0:	0e 94 9a 01 	call	0x334	; 0x334 <_ZN3adc9read_onceEh>
     3d4:	c8 0f       	add	r28, r24
     3d6:	d9 1f       	adc	r29, r25

   if (samples > 32) {
      samples = 32;
   }
   
   for (i = 0; i < samples; i++) {
     3d8:	e3 94       	inc	r14
     3da:	ed 14       	cp	r14, r13
     3dc:	b9 f7       	brne	.-18     	; 0x3cc <_ZN3adc16read_oversampledEhh+0x24>
      sum += read_once(channel);
   }

   //DBG (ptr_to_serial, "average: " << sum / samples << endl);
   return sum / samples;
     3de:	6d 2d       	mov	r22, r13
     3e0:	ce 01       	movw	r24, r28
     3e2:	70 e0       	ldi	r23, 0x00	; 0
     3e4:	0e 94 39 16 	call	0x2c72	; 0x2c72 <__udivmodhi4>
     3e8:	cb 01       	movw	r24, r22
}
     3ea:	df 91       	pop	r29
     3ec:	cf 91       	pop	r28
     3ee:	1f 91       	pop	r17
     3f0:	0f 91       	pop	r16
     3f2:	ff 90       	pop	r15
     3f4:	ef 90       	pop	r14
     3f6:	df 90       	pop	r13
     3f8:	08 95       	ret

   if (samples > 32) {
      samples = 32;
   }
   
   for (i = 0; i < samples; i++) {
     3fa:	44 23       	and	r20, r20
     3fc:	21 f7       	brne	.-56     	; 0x3c6 <_ZN3adc16read_oversampledEhh+0x1e>
 *  @param samples The chosen number of samples.
 *  @return The average readings from a chosen number of samples.
 */

uint16_t adc::read_oversampled (uint8_t channel, uint8_t samples) {
	uint16_t sum = 0;
     3fe:	c0 e0       	ldi	r28, 0x00	; 0
     400:	d0 e0       	ldi	r29, 0x00	; 0
     402:	ed cf       	rjmp	.-38     	; 0x3de <_ZN3adc16read_oversampledEhh+0x36>

00000404 <_ZlsR8emstreamR3adc>:
 *  @param a2d The A/D driver which is being printed.
 *  @return A reference to the same serial device that the information is written to.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& serpt, adc& a2d) {
     404:	cf 93       	push	r28
     406:	df 93       	push	r29
     408:	d8 2f       	mov	r29, r24
     40a:	c9 2f       	mov	r28, r25
     40c:	62 e2       	ldi	r22, 0x22	; 34
     40e:	72 e0       	ldi	r23, 0x02	; 2
     410:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>

	serpt << "ADMUX: " << bin << ADMUX << endl;
     414:	8d 2f       	mov	r24, r29
     416:	9c 2f       	mov	r25, r28
     418:	60 e0       	ldi	r22, 0x00	; 0
     41a:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     41e:	60 91 7c 00 	lds	r22, 0x007C
     422:	0e 94 a6 06 	call	0xd4c	; 0xd4c <_ZN8emstreamlsEh>
     426:	66 e0       	ldi	r22, 0x06	; 6
     428:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     42c:	8d 2f       	mov	r24, r29
     42e:	9c 2f       	mov	r25, r28
     430:	6a e2       	ldi	r22, 0x2A	; 42
     432:	72 e0       	ldi	r23, 0x02	; 2
     434:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
   serpt << "ADCSRA: " << bin << ADCSRA << endl;
     438:	8d 2f       	mov	r24, r29
     43a:	9c 2f       	mov	r25, r28
     43c:	60 e0       	ldi	r22, 0x00	; 0
     43e:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     442:	60 91 7a 00 	lds	r22, 0x007A
     446:	0e 94 a6 06 	call	0xd4c	; 0xd4c <_ZN8emstreamlsEh>
     44a:	66 e0       	ldi	r22, 0x06	; 6
     44c:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>

	return (serpt);
}
     450:	8d 2f       	mov	r24, r29
     452:	9c 2f       	mov	r25, r28
     454:	df 91       	pop	r29
     456:	cf 91       	pop	r28
     458:	08 95       	ret

0000045a <_ZN12motor_driverC1EP8emstreamPVhhS3_hS3_hS3_hPVj>:
 *  \details \b Details: The A/D converter is enabled and the division factor is set to 32.
 *  @param p_serial_port A pointer to the serial port where debugging info is written. 
 */

// use mask...
motor_driver::motor_driver(emstream *p_serial_port,
     45a:	8f 92       	push	r8
     45c:	9f 92       	push	r9
     45e:	af 92       	push	r10
     460:	cf 92       	push	r12
     462:	df 92       	push	r13
     464:	ef 92       	push	r14
     466:	0f 93       	push	r16
     468:	1f 93       	push	r17
     46a:	cf 93       	push	r28
     46c:	df 93       	push	r29
     46e:	cd b7       	in	r28, 0x3d	; 61
     470:	de b7       	in	r29, 0x3e	; 62
     472:	fc 01       	movw	r30, r24
                           uint8_t tccra_mask,
                           volatile uint8_t *p_tccrb,
                           uint8_t tccrb_mask,
                           volatile uint16_t *OCR) {  

   ptr_to_serial = p_serial_port;
     474:	71 83       	std	Z+1, r23	; 0x01
     476:	60 83       	st	Z, r22
   compare = OCR;
     478:	8e 85       	ldd	r24, Y+14	; 0x0e
     47a:	9f 85       	ldd	r25, Y+15	; 0x0f
     47c:	93 83       	std	Z+3, r25	; 0x03
     47e:	82 83       	std	Z+2, r24	; 0x02

   *p_ddr = ddr_mask;
     480:	da 01       	movw	r26, r20
     482:	2c 93       	st	X, r18
   *pwm = pwm_mask;
     484:	d8 01       	movw	r26, r16
     486:	ec 92       	st	X, r14
   *p_tccra = tccra_mask;
     488:	d6 01       	movw	r26, r12
     48a:	ac 92       	st	X, r10
   *p_tccrb = tccrb_mask;
     48c:	8d 85       	ldd	r24, Y+13	; 0x0d
     48e:	d4 01       	movw	r26, r8
     490:	8c 93       	st	X, r24
   *compare = 0;
     492:	a2 81       	ldd	r26, Z+2	; 0x02
     494:	b3 81       	ldd	r27, Z+3	; 0x03
     496:	11 96       	adiw	r26, 0x01	; 1
     498:	1c 92       	st	X, r1
     49a:	1e 92       	st	-X, r1

   DBG(ptr_to_serial, "Motor driver constructor OK" << endl);
     49c:	00 81       	ld	r16, Z
     49e:	11 81       	ldd	r17, Z+1	; 0x01
     4a0:	01 15       	cp	r16, r1
     4a2:	11 05       	cpc	r17, r1
     4a4:	49 f0       	breq	.+18     	; 0x4b8 <_ZN12motor_driverC1EP8emstreamPVhhS3_hS3_hS3_hPVj+0x5e>
     4a6:	c8 01       	movw	r24, r16
     4a8:	63 e3       	ldi	r22, 0x33	; 51
     4aa:	72 e0       	ldi	r23, 0x02	; 2
     4ac:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
     4b0:	c8 01       	movw	r24, r16
     4b2:	66 e0       	ldi	r22, 0x06	; 6
     4b4:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
}
     4b8:	df 91       	pop	r29
     4ba:	cf 91       	pop	r28
     4bc:	1f 91       	pop	r17
     4be:	0f 91       	pop	r16
     4c0:	ef 90       	pop	r14
     4c2:	df 90       	pop	r13
     4c4:	cf 90       	pop	r12
     4c6:	af 90       	pop	r10
     4c8:	9f 90       	pop	r9
     4ca:	8f 90       	pop	r8
     4cc:	08 95       	ret

000004ce <_ZN12motor_driver9set_powerEi>:
void motor_driver::set_power(int16_t power) {
   // compare = something;
   // 128 = 0;
   // < 128 = negative;
   // > 128 = positive;
}
     4ce:	08 95       	ret

000004d0 <_ZN12motor_driver5brakeEv>:

void motor_driver::brake(void) {


}
     4d0:	08 95       	ret

000004d2 <_ZN12motor_driver6sampleEv>:

void motor_driver::sample(void) {
     4d2:	cf 93       	push	r28
     4d4:	df 93       	push	r29
   DBG(ptr_to_serial, "TCNT1: " << TCNT1 << endl);
     4d6:	fc 01       	movw	r30, r24
     4d8:	c0 81       	ld	r28, Z
     4da:	d1 81       	ldd	r29, Z+1	; 0x01
     4dc:	20 97       	sbiw	r28, 0x00	; 0
     4de:	79 f0       	breq	.+30     	; 0x4fe <_ZN12motor_driver6sampleEv+0x2c>
     4e0:	ce 01       	movw	r24, r28
     4e2:	6f e4       	ldi	r22, 0x4F	; 79
     4e4:	72 e0       	ldi	r23, 0x02	; 2
     4e6:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
     4ea:	60 91 84 00 	lds	r22, 0x0084
     4ee:	70 91 85 00 	lds	r23, 0x0085
     4f2:	ce 01       	movw	r24, r28
     4f4:	0e 94 26 06 	call	0xc4c	; 0xc4c <_ZN8emstreamlsEj>
     4f8:	66 e0       	ldi	r22, 0x06	; 6
     4fa:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     4fe:	df 91       	pop	r29
     500:	cf 91       	pop	r28
     502:	08 95       	ret

00000504 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
     504:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
     506:	e8 81       	ld	r30, Y
     508:	f9 81       	ldd	r31, Y+1	; 0x01
     50a:	01 90       	ld	r0, Z+
     50c:	f0 81       	ld	r31, Z
     50e:	e0 2d       	mov	r30, r0
     510:	09 95       	icall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
     512:	1b 82       	std	Y+3, r1	; 0x03
     514:	1a 82       	std	Y+2, r1	; 0x02

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
     516:	6f ef       	ldi	r22, 0xFF	; 255
     518:	7f ef       	ldi	r23, 0xFF	; 255
     51a:	cb 01       	movw	r24, r22
     51c:	0e 94 f2 11 	call	0x23e4	; 0x23e4 <vTaskDelay>
     520:	fa cf       	rjmp	.-12     	; 0x516 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00000522 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     522:	0e 94 82 02 	call	0x504	; 0x504 <_ZN8frt_task22_call_users_run_methodEPS_>

00000526 <_ZN8frt_task13transition_toEh>:
 *  variable 'state', and if transition logging is enabled, it logs the transition to 
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
     526:	fc 01       	movw	r30, r24
	state = new_state;
     528:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
     52a:	65 87       	std	Z+13, r22	; 0x0d
}
     52c:	08 95       	ret

0000052e <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
     52e:	2f 92       	push	r2
     530:	3f 92       	push	r3
     532:	4f 92       	push	r4
     534:	5f 92       	push	r5
     536:	6f 92       	push	r6
     538:	7f 92       	push	r7
     53a:	8f 92       	push	r8
     53c:	9f 92       	push	r9
     53e:	af 92       	push	r10
     540:	bf 92       	push	r11
     542:	cf 92       	push	r12
     544:	df 92       	push	r13
     546:	ef 92       	push	r14
     548:	ff 92       	push	r15
     54a:	0f 93       	push	r16
     54c:	1f 93       	push	r17
     54e:	cf 93       	push	r28
     550:	df 93       	push	r29
     552:	cd b7       	in	r28, 0x3d	; 61
     554:	de b7       	in	r29, 0x3e	; 62
     556:	2a 97       	sbiw	r28, 0x0a	; 10
     558:	0f b6       	in	r0, 0x3f	; 63
     55a:	f8 94       	cli
     55c:	de bf       	out	0x3e, r29	; 62
     55e:	0f be       	out	0x3f, r0	; 63
     560:	cd bf       	out	0x3d, r28	; 61
     562:	4c 01       	movw	r8, r24
     564:	db 01       	movw	r26, r22
     566:	d4 2e       	mov	r13, r20
     568:	19 01       	movw	r2, r18
     56a:	28 01       	movw	r4, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
     56c:	8b e5       	ldi	r24, 0x5B	; 91
     56e:	92 e0       	ldi	r25, 0x02	; 2
     570:	f4 01       	movw	r30, r8
     572:	91 83       	std	Z+1, r25	; 0x01
     574:	80 83       	st	Z, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
     576:	2c 91       	ld	r18, X
     578:	22 23       	and	r18, r18
     57a:	09 f4       	brne	.+2      	; 0x57e <_ZN8frt_taskC1EPKchjP8emstream+0x50>
     57c:	7b c0       	rjmp	.+246    	; 0x674 <_ZN8frt_taskC1EPKchjP8emstream+0x146>
     57e:	3e 01       	movw	r6, r28
     580:	08 94       	sec
     582:	61 1c       	adc	r6, r1
     584:	71 1c       	adc	r7, r1
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
     586:	11 96       	adiw	r26, 0x01	; 1
     588:	ce 01       	movw	r24, r28
     58a:	0a 96       	adiw	r24, 0x0a	; 10
     58c:	f3 01       	movw	r30, r6
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
     58e:	21 93       	st	Z+, r18
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
     590:	3e 2f       	mov	r19, r30
     592:	36 19       	sub	r19, r6
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
     594:	2d 91       	ld	r18, X+
     596:	22 23       	and	r18, r18
     598:	09 f0       	breq	.+2      	; 0x59c <_ZN8frt_taskC1EPKchjP8emstream+0x6e>
     59a:	67 c0       	rjmp	.+206    	; 0x66a <_ZN8frt_taskC1EPKchjP8emstream+0x13c>
     59c:	83 2f       	mov	r24, r19
     59e:	90 e0       	ldi	r25, 0x00	; 0
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
     5a0:	86 0d       	add	r24, r6
     5a2:	97 1d       	adc	r25, r7
     5a4:	fc 01       	movw	r30, r24
     5a6:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
     5a8:	22 e0       	ldi	r18, 0x02	; 2
     5aa:	e2 2e       	mov	r14, r18
     5ac:	f1 2c       	mov	r15, r1
     5ae:	e8 0c       	add	r14, r8
     5b0:	f9 1c       	adc	r15, r9
     5b2:	81 e9       	ldi	r24, 0x91	; 145
     5b4:	92 e0       	ldi	r25, 0x02	; 2
     5b6:	b3 01       	movw	r22, r6
     5b8:	a1 01       	movw	r20, r2
     5ba:	94 01       	movw	r18, r8
     5bc:	0d 2d       	mov	r16, r13
     5be:	cc 24       	eor	r12, r12
     5c0:	dd 24       	eor	r13, r13
     5c2:	aa 24       	eor	r10, r10
     5c4:	bb 24       	eor	r11, r11
     5c6:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
     5ca:	f4 01       	movw	r30, r8
     5cc:	57 82       	std	Z+7, r5	; 0x07
     5ce:	46 82       	std	Z+6, r4	; 0x06
	total_stack = a_stack_size;
     5d0:	31 86       	std	Z+9, r3	; 0x09
     5d2:	20 86       	std	Z+8, r2	; 0x08

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
     5d4:	20 91 aa 02 	lds	r18, 0x02AA
     5d8:	30 91 ab 02 	lds	r19, 0x02AB
     5dc:	35 83       	std	Z+5, r19	; 0x05
     5de:	24 83       	std	Z+4, r18	; 0x04
	last_created_task_pointer = this;
     5e0:	90 92 ab 02 	sts	0x02AB, r9
     5e4:	80 92 aa 02 	sts	0x02AA, r8

	// Initialize the finite state machine and its transition logger
	state = 0;
     5e8:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
     5ea:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
     5ec:	20 91 54 1a 	lds	r18, 0x1A54
     5f0:	30 91 55 1a 	lds	r19, 0x1A55
     5f4:	2f 5f       	subi	r18, 0xFF	; 255
     5f6:	3f 4f       	sbci	r19, 0xFF	; 255
     5f8:	30 93 55 1a 	sts	0x1A55, r19
     5fc:	20 93 54 1a 	sts	0x1A54, r18
     600:	33 87       	std	Z+11, r19	; 0x0b
     602:	22 87       	std	Z+10, r18	; 0x0a

	// Initialize the run counter
	runs = 0;
     604:	16 86       	std	Z+14, r1	; 0x0e
     606:	17 86       	std	Z+15, r1	; 0x0f
     608:	10 8a       	std	Z+16, r1	; 0x10
     60a:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
     60c:	41 14       	cp	r4, r1
     60e:	51 04       	cpc	r5, r1
     610:	99 f0       	breq	.+38     	; 0x638 <_ZN8frt_taskC1EPKchjP8emstream+0x10a>
	{
		if (task_status == pdPASS)
     612:	81 30       	cpi	r24, 0x01	; 1
     614:	b1 f1       	breq	.+108    	; 0x682 <_ZN8frt_taskC1EPKchjP8emstream+0x154>
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
     616:	c2 01       	movw	r24, r4
     618:	6a e0       	ldi	r22, 0x0A	; 10
     61a:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     61e:	7c 01       	movw	r14, r24
     620:	66 e0       	ldi	r22, 0x06	; 6
     622:	71 e0       	ldi	r23, 0x01	; 1
     624:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
     628:	c7 01       	movw	r24, r14
     62a:	b3 01       	movw	r22, r6
     62c:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
     630:	c7 01       	movw	r24, r14
     632:	66 e0       	ldi	r22, 0x06	; 6
     634:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
     638:	2a 96       	adiw	r28, 0x0a	; 10
     63a:	0f b6       	in	r0, 0x3f	; 63
     63c:	f8 94       	cli
     63e:	de bf       	out	0x3e, r29	; 62
     640:	0f be       	out	0x3f, r0	; 63
     642:	cd bf       	out	0x3d, r28	; 61
     644:	df 91       	pop	r29
     646:	cf 91       	pop	r28
     648:	1f 91       	pop	r17
     64a:	0f 91       	pop	r16
     64c:	ff 90       	pop	r15
     64e:	ef 90       	pop	r14
     650:	df 90       	pop	r13
     652:	cf 90       	pop	r12
     654:	bf 90       	pop	r11
     656:	af 90       	pop	r10
     658:	9f 90       	pop	r9
     65a:	8f 90       	pop	r8
     65c:	7f 90       	pop	r7
     65e:	6f 90       	pop	r6
     660:	5f 90       	pop	r5
     662:	4f 90       	pop	r4
     664:	3f 90       	pop	r3
     666:	2f 90       	pop	r2
     668:	08 95       	ret
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
     66a:	e8 17       	cp	r30, r24
     66c:	f9 07       	cpc	r31, r25
     66e:	09 f0       	breq	.+2      	; 0x672 <_ZN8frt_taskC1EPKchjP8emstream+0x144>
     670:	8e cf       	rjmp	.-228    	; 0x58e <_ZN8frt_taskC1EPKchjP8emstream+0x60>
     672:	94 cf       	rjmp	.-216    	; 0x59c <_ZN8frt_taskC1EPKchjP8emstream+0x6e>
     674:	80 e0       	ldi	r24, 0x00	; 0
     676:	90 e0       	ldi	r25, 0x00	; 0
     678:	3e 01       	movw	r6, r28
     67a:	08 94       	sec
     67c:	61 1c       	adc	r6, r1
     67e:	71 1c       	adc	r7, r1
     680:	8f cf       	rjmp	.-226    	; 0x5a0 <_ZN8frt_taskC1EPKchjP8emstream+0x72>
	// successfully
	if (p_serial != NULL)
	{
		if (task_status == pdPASS)
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
     682:	c2 01       	movw	r24, r4
     684:	6a e0       	ldi	r22, 0x0A	; 10
     686:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     68a:	7c 01       	movw	r14, r24
     68c:	69 ee       	ldi	r22, 0xE9	; 233
     68e:	70 e0       	ldi	r23, 0x00	; 0
     690:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
     694:	c7 01       	movw	r24, r14
     696:	b3 01       	movw	r22, r6
     698:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
     69c:	c7 01       	movw	r24, r14
     69e:	6a e0       	ldi	r22, 0x0A	; 10
     6a0:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     6a4:	7c 01       	movw	r14, r24
     6a6:	6f ee       	ldi	r22, 0xEF	; 239
     6a8:	70 e0       	ldi	r23, 0x00	; 0
     6aa:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
     6ae:	c7 01       	movw	r24, r14
     6b0:	6a e0       	ldi	r22, 0x0A	; 10
     6b2:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     6b6:	7c 01       	movw	r14, r24
     6b8:	68 ef       	ldi	r22, 0xF8	; 248
     6ba:	70 e0       	ldi	r23, 0x00	; 0
     6bc:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
     6c0:	c7 01       	movw	r24, r14
     6c2:	63 e0       	ldi	r22, 0x03	; 3
     6c4:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     6c8:	f4 01       	movw	r30, r8
     6ca:	62 85       	ldd	r22, Z+10	; 0x0a
     6cc:	73 85       	ldd	r23, Z+11	; 0x0b
     6ce:	0e 94 26 06 	call	0xc4c	; 0xc4c <_ZN8emstreamlsEj>
     6d2:	62 e0       	ldi	r22, 0x02	; 2
     6d4:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     6d8:	66 e0       	ldi	r22, 0x06	; 6
     6da:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     6de:	ac cf       	rjmp	.-168    	; 0x638 <_ZN8frt_taskC1EPKchjP8emstream+0x10a>

000006e0 <_ZN8frt_task15emergency_resetEv>:
/** This method prints an error message and resets the processor. It should only be 
 *  used in cases of things going seriously to heck.
 */

void frt_task::emergency_reset (void)
{
     6e0:	ec 01       	movw	r28, r24
	*p_serial << PMS ("ERROR in task ") << get_name () << PMS ("Resetting") << endl;
     6e2:	8e 81       	ldd	r24, Y+6	; 0x06
     6e4:	9f 81       	ldd	r25, Y+7	; 0x07
     6e6:	6a e0       	ldi	r22, 0x0A	; 10
     6e8:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     6ec:	8c 01       	movw	r16, r24
     6ee:	6b e1       	ldi	r22, 0x1B	; 27
     6f0:	71 e0       	ldi	r23, 0x01	; 1
     6f2:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
		*  terminated character array belonging to the task. 
		*  @return A pointer to the task's name
		*/
		const char* get_name (void)
		{
			return ((const char*)(pcTaskGetTaskName (handle)));
     6f6:	8a 81       	ldd	r24, Y+2	; 0x02
     6f8:	9b 81       	ldd	r25, Y+3	; 0x03
     6fa:	0e 94 65 10 	call	0x20ca	; 0x20ca <pcTaskGetTaskName>
     6fe:	bc 01       	movw	r22, r24
     700:	c8 01       	movw	r24, r16
     702:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
     706:	c8 01       	movw	r24, r16
     708:	6a e0       	ldi	r22, 0x0A	; 10
     70a:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     70e:	ec 01       	movw	r28, r24
     710:	6a e2       	ldi	r22, 0x2A	; 42
     712:	71 e0       	ldi	r23, 0x01	; 1
     714:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
     718:	ce 01       	movw	r24, r28
     71a:	66 e0       	ldi	r22, 0x06	; 6
     71c:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
	wdt_enable (WDTO_120MS);
     720:	2b e0       	ldi	r18, 0x0B	; 11
     722:	88 e1       	ldi	r24, 0x18	; 24
     724:	90 e0       	ldi	r25, 0x00	; 0
     726:	0f b6       	in	r0, 0x3f	; 63
     728:	f8 94       	cli
     72a:	a8 95       	wdr
     72c:	80 93 60 00 	sts	0x0060, r24
     730:	0f be       	out	0x3f, r0	; 63
     732:	20 93 60 00 	sts	0x0060, r18
     736:	ff cf       	rjmp	.-2      	; 0x736 <_ZN8frt_task15emergency_resetEv+0x56>

00000738 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
     738:	0f 93       	push	r16
     73a:	1f 93       	push	r17
     73c:	cf 93       	push	r28
     73e:	df 93       	push	r29
     740:	8c 01       	movw	r16, r24
     742:	eb 01       	movw	r28, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
     744:	fc 01       	movw	r30, r24
     746:	82 81       	ldd	r24, Z+2	; 0x02
     748:	93 81       	ldd	r25, Z+3	; 0x03
     74a:	0e 94 65 10 	call	0x20ca	; 0x20ca <pcTaskGetTaskName>
     74e:	bc 01       	movw	r22, r24
     750:	ce 01       	movw	r24, r28
     752:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
     756:	e8 81       	ld	r30, Y
     758:	f9 81       	ldd	r31, Y+1	; 0x01
     75a:	02 80       	ldd	r0, Z+2	; 0x02
     75c:	f3 81       	ldd	r31, Z+3	; 0x03
     75e:	e0 2d       	mov	r30, r0
     760:	ce 01       	movw	r24, r28
     762:	69 e0       	ldi	r22, 0x09	; 9
     764:	09 95       	icall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
     766:	f8 01       	movw	r30, r16
     768:	82 81       	ldd	r24, Z+2	; 0x02
     76a:	93 81       	ldd	r25, Z+3	; 0x03
     76c:	0e 94 65 10 	call	0x20ca	; 0x20ca <pcTaskGetTaskName>
     770:	dc 01       	movw	r26, r24
     772:	0d 90       	ld	r0, X+
     774:	00 20       	and	r0, r0
     776:	e9 f7       	brne	.-6      	; 0x772 <_ZN8frt_task12print_statusER8emstream+0x3a>
     778:	11 97       	sbiw	r26, 0x01	; 1
     77a:	a8 1b       	sub	r26, r24
     77c:	b9 0b       	sbc	r27, r25
     77e:	a8 30       	cpi	r26, 0x08	; 8
     780:	b1 05       	cpc	r27, r1
     782:	40 f4       	brcc	.+16     	; 0x794 <_ZN8frt_task12print_statusER8emstream+0x5c>
	{
		ser_dev.putchar ('\t');
     784:	e8 81       	ld	r30, Y
     786:	f9 81       	ldd	r31, Y+1	; 0x01
     788:	02 80       	ldd	r0, Z+2	; 0x02
     78a:	f3 81       	ldd	r31, Z+3	; 0x03
     78c:	e0 2d       	mov	r30, r0
     78e:	ce 01       	movw	r24, r28
     790:	69 e0       	ldi	r22, 0x09	; 9
     792:	09 95       	icall
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
     794:	f8 01       	movw	r30, r16
     796:	82 81       	ldd	r24, Z+2	; 0x02
     798:	93 81       	ldd	r25, Z+3	; 0x03
     79a:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <uxTaskPriorityGet>
     79e:	68 2f       	mov	r22, r24
     7a0:	ce 01       	movw	r24, r28
     7a2:	0e 94 a6 06 	call	0xd4c	; 0xd4c <_ZN8emstreamlsEh>
     7a6:	6a e0       	ldi	r22, 0x0A	; 10
     7a8:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     7ac:	ec 01       	movw	r28, r24
     7ae:	64 e3       	ldi	r22, 0x34	; 52
     7b0:	71 e0       	ldi	r23, 0x01	; 1
     7b2:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
			<< get_state ()
     7b6:	ce 01       	movw	r24, r28
     7b8:	f8 01       	movw	r30, r16
     7ba:	64 85       	ldd	r22, Z+12	; 0x0c
     7bc:	0e 94 a6 06 	call	0xd4c	; 0xd4c <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
     7c0:	6a e0       	ldi	r22, 0x0A	; 10
     7c2:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     7c6:	ec 01       	movw	r28, r24
     7c8:	66 e3       	ldi	r22, 0x36	; 54
     7ca:	71 e0       	ldi	r23, 0x01	; 1
     7cc:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
     7d0:	f8 01       	movw	r30, r16
     7d2:	82 81       	ldd	r24, Z+2	; 0x02
     7d4:	93 81       	ldd	r25, Z+3	; 0x03
     7d6:	0e 94 c8 13 	call	0x2790	; 0x2790 <uxTaskGetStackHighWaterMark>
     7da:	68 2f       	mov	r22, r24
     7dc:	ce 01       	movw	r24, r28
     7de:	0e 94 a6 06 	call	0xd4c	; 0xd4c <_ZN8emstreamlsEh>
     7e2:	6a e0       	ldi	r22, 0x0A	; 10
     7e4:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     7e8:	ec 01       	movw	r28, r24
     7ea:	68 e3       	ldi	r22, 0x38	; 56
     7ec:	71 e0       	ldi	r23, 0x01	; 1
     7ee:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
     7f2:	f8 01       	movw	r30, r16
     7f4:	60 85       	ldd	r22, Z+8	; 0x08
     7f6:	71 85       	ldd	r23, Z+9	; 0x09
     7f8:	ce 01       	movw	r24, r28
     7fa:	0e 94 26 06 	call	0xc4c	; 0xc4c <_ZN8emstreamlsEj>
     7fe:	6a e0       	ldi	r22, 0x0A	; 10
     800:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     804:	ec 01       	movw	r28, r24
     806:	6a e3       	ldi	r22, 0x3A	; 58
     808:	71 e0       	ldi	r23, 0x01	; 1
     80a:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
     80e:	ce 01       	movw	r24, r28
     810:	6a e0       	ldi	r22, 0x0A	; 10
     812:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     816:	ec 01       	movw	r28, r24
     818:	6c e3       	ldi	r22, 0x3C	; 60
     81a:	71 e0       	ldi	r23, 0x01	; 1
     81c:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
     820:	f8 01       	movw	r30, r16
     822:	46 85       	ldd	r20, Z+14	; 0x0e
     824:	57 85       	ldd	r21, Z+15	; 0x0f
     826:	60 89       	ldd	r22, Z+16	; 0x10
     828:	71 89       	ldd	r23, Z+17	; 0x11
     82a:	ce 01       	movw	r24, r28
     82c:	0e 94 60 06 	call	0xcc0	; 0xcc0 <_ZN8emstreamlsEm>
}
     830:	df 91       	pop	r29
     832:	cf 91       	pop	r28
     834:	1f 91       	pop	r17
     836:	0f 91       	pop	r16
     838:	08 95       	ret

0000083a <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
     83a:	0f 93       	push	r16
     83c:	1f 93       	push	r17
     83e:	cf 93       	push	r28
     840:	df 93       	push	r29
     842:	ec 01       	movw	r28, r24
     844:	8b 01       	movw	r16, r22
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
	a_task.print_status (ser_dev);
     846:	e8 81       	ld	r30, Y
     848:	f9 81       	ldd	r31, Y+1	; 0x01
     84a:	02 80       	ldd	r0, Z+2	; 0x02
     84c:	f3 81       	ldd	r31, Z+3	; 0x03
     84e:	e0 2d       	mov	r30, r0
     850:	ce 01       	movw	r24, r28
     852:	b8 01       	movw	r22, r16
     854:	09 95       	icall
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
	*ser_device << *this << endl;
     856:	c8 01       	movw	r24, r16
     858:	66 e0       	ldi	r22, 0x06	; 6
     85a:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
     85e:	0c 80       	ldd	r0, Y+4	; 0x04
     860:	dd 81       	ldd	r29, Y+5	; 0x05
     862:	c0 2d       	mov	r28, r0
     864:	20 97       	sbiw	r28, 0x00	; 0
     866:	79 f7       	brne	.-34     	; 0x846 <_ZN8frt_task20print_status_in_listEP8emstream+0xc>
	{
		prev_task_pointer->print_status_in_list (ser_device);
	}
}
     868:	df 91       	pop	r29
     86a:	cf 91       	pop	r28
     86c:	1f 91       	pop	r17
     86e:	0f 91       	pop	r16
     870:	08 95       	ret

00000872 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
     872:	cf 93       	push	r28
     874:	df 93       	push	r29
     876:	d8 2f       	mov	r29, r24
     878:	c9 2f       	mov	r28, r25
     87a:	db 01       	movw	r26, r22
	a_task.print_status (ser_dev);
     87c:	ed 91       	ld	r30, X+
     87e:	fc 91       	ld	r31, X
     880:	02 80       	ldd	r0, Z+2	; 0x02
     882:	f3 81       	ldd	r31, Z+3	; 0x03
     884:	e0 2d       	mov	r30, r0
     886:	cb 01       	movw	r24, r22
     888:	6d 2f       	mov	r22, r29
     88a:	7c 2f       	mov	r23, r28
     88c:	09 95       	icall
	return (ser_dev);
}
     88e:	8d 2f       	mov	r24, r29
     890:	9c 2f       	mov	r25, r28
     892:	df 91       	pop	r29
     894:	cf 91       	pop	r28
     896:	08 95       	ret

00000898 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
     898:	0f 93       	push	r16
     89a:	1f 93       	push	r17
     89c:	cf 93       	push	r28
     89e:	df 93       	push	r29
     8a0:	8c 01       	movw	r16, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
     8a2:	6a e0       	ldi	r22, 0x0A	; 10
     8a4:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     8a8:	ec 01       	movw	r28, r24
     8aa:	6e e3       	ldi	r22, 0x3E	; 62
     8ac:	71 e0       	ldi	r23, 0x01	; 1
     8ae:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
     8b2:	ce 01       	movw	r24, r28
     8b4:	6a e0       	ldi	r22, 0x0A	; 10
     8b6:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     8ba:	ec 01       	movw	r28, r24
     8bc:	69 e4       	ldi	r22, 0x49	; 73
     8be:	71 e0       	ldi	r23, 0x01	; 1
     8c0:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
     8c4:	ce 01       	movw	r24, r28
     8c6:	66 e0       	ldi	r22, 0x06	; 6
     8c8:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
     8cc:	c8 01       	movw	r24, r16
     8ce:	6a e0       	ldi	r22, 0x0A	; 10
     8d0:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     8d4:	ec 01       	movw	r28, r24
     8d6:	60 e5       	ldi	r22, 0x50	; 80
     8d8:	71 e0       	ldi	r23, 0x01	; 1
     8da:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
     8de:	ce 01       	movw	r24, r28
     8e0:	6a e0       	ldi	r22, 0x0A	; 10
     8e2:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     8e6:	ec 01       	movw	r28, r24
     8e8:	61 e6       	ldi	r22, 0x61	; 97
     8ea:	71 e0       	ldi	r23, 0x01	; 1
     8ec:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
     8f0:	ce 01       	movw	r24, r28
     8f2:	6a e0       	ldi	r22, 0x0A	; 10
     8f4:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     8f8:	ec 01       	movw	r28, r24
     8fa:	6d e6       	ldi	r22, 0x6D	; 109
     8fc:	71 e0       	ldi	r23, 0x01	; 1
     8fe:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
     902:	ce 01       	movw	r24, r28
     904:	66 e0       	ldi	r22, 0x06	; 6
     906:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
     90a:	c8 01       	movw	r24, r16
     90c:	6a e0       	ldi	r22, 0x0A	; 10
     90e:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     912:	ec 01       	movw	r28, r24
     914:	63 e7       	ldi	r22, 0x73	; 115
     916:	71 e0       	ldi	r23, 0x01	; 1
     918:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
     91c:	ce 01       	movw	r24, r28
     91e:	6a e0       	ldi	r22, 0x0A	; 10
     920:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     924:	ec 01       	movw	r28, r24
     926:	64 e8       	ldi	r22, 0x84	; 132
     928:	71 e0       	ldi	r23, 0x01	; 1
     92a:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
     92e:	ce 01       	movw	r24, r28
     930:	6a e0       	ldi	r22, 0x0A	; 10
     932:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     936:	ec 01       	movw	r28, r24
     938:	60 e9       	ldi	r22, 0x90	; 144
     93a:	71 e0       	ldi	r23, 0x01	; 1
     93c:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
     940:	ce 01       	movw	r24, r28
     942:	66 e0       	ldi	r22, 0x06	; 6
     944:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
     948:	80 91 aa 02 	lds	r24, 0x02AA
     94c:	90 91 ab 02 	lds	r25, 0x02AB
     950:	00 97       	sbiw	r24, 0x00	; 0
     952:	19 f0       	breq	.+6      	; 0x95a <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
     954:	b8 01       	movw	r22, r16
     956:	0e 94 1d 04 	call	0x83a	; 0x83a <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
     95a:	c8 01       	movw	r24, r16
     95c:	6a e0       	ldi	r22, 0x0A	; 10
     95e:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     962:	ec 01       	movw	r28, r24
     964:	66 e9       	ldi	r22, 0x96	; 150
     966:	71 e0       	ldi	r23, 0x01	; 1
     968:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
     96c:	0e 94 6f 10 	call	0x20de	; 0x20de <xTaskGetIdleTaskHandle>
     970:	0e 94 c8 13 	call	0x2790	; 0x2790 <uxTaskGetStackHighWaterMark>
     974:	68 2f       	mov	r22, r24
     976:	ce 01       	movw	r24, r28
     978:	0e 94 a6 06 	call	0xd4c	; 0xd4c <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
     97c:	6a e0       	ldi	r22, 0x0A	; 10
     97e:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     982:	ec 01       	movw	r28, r24
     984:	61 ea       	ldi	r22, 0xA1	; 161
     986:	71 e0       	ldi	r23, 0x01	; 1
     988:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
     98c:	ce 01       	movw	r24, r28
     98e:	64 e6       	ldi	r22, 0x64	; 100
     990:	70 e0       	ldi	r23, 0x00	; 0
     992:	0e 94 26 06 	call	0xc4c	; 0xc4c <_ZN8emstreamlsEj>
     996:	6a e0       	ldi	r22, 0x0A	; 10
     998:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
     99c:	ec 01       	movw	r28, r24
     99e:	63 ea       	ldi	r22, 0xA3	; 163
     9a0:	71 e0       	ldi	r23, 0x01	; 1
     9a2:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
     9a6:	ce 01       	movw	r24, r28
     9a8:	66 e0       	ldi	r22, 0x06	; 6
     9aa:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
}
     9ae:	df 91       	pop	r29
     9b0:	cf 91       	pop	r28
     9b2:	1f 91       	pop	r17
     9b4:	0f 91       	pop	r16
     9b6:	08 95       	ret

000009b8 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
     9b8:	0f 93       	push	r16
     9ba:	cf 93       	push	r28
     9bc:	df 93       	push	r29
     9be:	0f 92       	push	r0
     9c0:	cd b7       	in	r28, 0x3d	; 61
     9c2:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
     9c4:	fc 01       	movw	r30, r24
     9c6:	80 85       	ldd	r24, Z+8	; 0x08
     9c8:	91 85       	ldd	r25, Z+9	; 0x09
     9ca:	be 01       	movw	r22, r28
     9cc:	6f 5f       	subi	r22, 0xFF	; 255
     9ce:	7f 4f       	sbci	r23, 0xFF	; 255
     9d0:	2f ef       	ldi	r18, 0xFF	; 255
     9d2:	3f ef       	ldi	r19, 0xFF	; 255
     9d4:	a9 01       	movw	r20, r18
     9d6:	00 e0       	ldi	r16, 0x00	; 0
     9d8:	0e 94 b2 0c 	call	0x1964	; 0x1964 <xQueueGenericReceive>
     9dc:	81 30       	cpi	r24, 0x01	; 1
     9de:	49 f4       	brne	.+18     	; 0x9f2 <_ZN14frt_text_queue7getcharEv+0x3a>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
     9e0:	89 81       	ldd	r24, Y+1	; 0x01
     9e2:	99 27       	eor	r25, r25
     9e4:	87 fd       	sbrc	r24, 7
     9e6:	90 95       	com	r25
}
     9e8:	0f 90       	pop	r0
     9ea:	df 91       	pop	r29
     9ec:	cf 91       	pop	r28
     9ee:	0f 91       	pop	r16
     9f0:	08 95       	ret
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
     9f2:	8f ef       	ldi	r24, 0xFF	; 255
     9f4:	9f ef       	ldi	r25, 0xFF	; 255
     9f6:	f8 cf       	rjmp	.-16     	; 0x9e8 <_ZN14frt_text_queue7getcharEv+0x30>

000009f8 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
     9f8:	fc 01       	movw	r30, r24
     9fa:	80 85       	ldd	r24, Z+8	; 0x08
     9fc:	91 85       	ldd	r25, Z+9	; 0x09
     9fe:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <uxQueueMessagesWaiting>
 *  function uxQueueMessagesWaiting(); if there's anything in the queue, the return 
 *  value from that function will be greater than zero. 
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
     a02:	91 e0       	ldi	r25, 0x01	; 1
     a04:	88 23       	and	r24, r24
     a06:	09 f4       	brne	.+2      	; 0xa0a <_ZN14frt_text_queue14check_for_charEv+0x12>
     a08:	90 e0       	ldi	r25, 0x00	; 0
	if (uxQueueMessagesWaiting (the_queue) == 0)
	{
		return (false);
	}
	return (true);
}
     a0a:	89 2f       	mov	r24, r25
     a0c:	08 95       	ret

00000a0e <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
     a0e:	0f 93       	push	r16
     a10:	cf 93       	push	r28
     a12:	df 93       	push	r29
     a14:	0f 92       	push	r0
     a16:	cd b7       	in	r28, 0x3d	; 61
     a18:	de b7       	in	r29, 0x3e	; 62
     a1a:	fc 01       	movw	r30, r24
     a1c:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
     a1e:	22 85       	ldd	r18, Z+10	; 0x0a
     a20:	33 85       	ldd	r19, Z+11	; 0x0b
     a22:	44 85       	ldd	r20, Z+12	; 0x0c
     a24:	55 85       	ldd	r21, Z+13	; 0x0d
     a26:	80 85       	ldd	r24, Z+8	; 0x08
     a28:	91 85       	ldd	r25, Z+9	; 0x09
     a2a:	be 01       	movw	r22, r28
     a2c:	6f 5f       	subi	r22, 0xFF	; 255
     a2e:	7f 4f       	sbci	r23, 0xFF	; 255
     a30:	00 e0       	ldi	r16, 0x00	; 0
     a32:	0e 94 a9 0b 	call	0x1752	; 0x1752 <xQueueGenericSend>
 *  become empty, give up in frustration and return false. 
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
     a36:	91 e0       	ldi	r25, 0x01	; 1
     a38:	88 23       	and	r24, r24
     a3a:	09 f4       	brne	.+2      	; 0xa3e <_ZN14frt_text_queue7putcharEc+0x30>
     a3c:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
     a3e:	89 2f       	mov	r24, r25
     a40:	0f 90       	pop	r0
     a42:	df 91       	pop	r29
     a44:	cf 91       	pop	r28
     a46:	0f 91       	pop	r16
     a48:	08 95       	ret

00000a4a <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
     a4a:	8f 92       	push	r8
     a4c:	9f 92       	push	r9
     a4e:	af 92       	push	r10
     a50:	bf 92       	push	r11
     a52:	cf 92       	push	r12
     a54:	df 92       	push	r13
     a56:	ef 92       	push	r14
     a58:	ff 92       	push	r15
     a5a:	0f 93       	push	r16
     a5c:	1f 93       	push	r17
     a5e:	cf 93       	push	r28
     a60:	df 93       	push	r29
     a62:	0f 92       	push	r0
     a64:	cd b7       	in	r28, 0x3d	; 61
     a66:	de b7       	in	r29, 0x3e	; 62
     a68:	4c 01       	movw	r8, r24
     a6a:	5a 01       	movw	r10, r20
     a6c:	68 01       	movw	r12, r16
     a6e:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
     a70:	69 83       	std	Y+1, r22	; 0x01
     a72:	0e 94 86 05 	call	0xb0c	; 0xb0c <_ZN8emstreamC1Ev>
     a76:	83 e6       	ldi	r24, 0x63	; 99
     a78:	92 e0       	ldi	r25, 0x02	; 2
     a7a:	f4 01       	movw	r30, r8
     a7c:	91 83       	std	Z+1, r25	; 0x01
     a7e:	80 83       	st	Z, r24
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
     a80:	b7 86       	std	Z+15, r11	; 0x0f
     a82:	a6 86       	std	Z+14, r10	; 0x0e

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
     a84:	69 81       	ldd	r22, Y+1	; 0x01
     a86:	86 2f       	mov	r24, r22
     a88:	61 e0       	ldi	r22, 0x01	; 1
     a8a:	40 e0       	ldi	r20, 0x00	; 0
     a8c:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <xQueueGenericCreate>
     a90:	f4 01       	movw	r30, r8
     a92:	91 87       	std	Z+9, r25	; 0x09
     a94:	80 87       	std	Z+8, r24	; 0x08

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
     a96:	c2 86       	std	Z+10, r12	; 0x0a
     a98:	d3 86       	std	Z+11, r13	; 0x0b
     a9a:	e4 86       	std	Z+12, r14	; 0x0c
     a9c:	f5 86       	std	Z+13, r15	; 0x0d
}
     a9e:	0f 90       	pop	r0
     aa0:	df 91       	pop	r29
     aa2:	cf 91       	pop	r28
     aa4:	1f 91       	pop	r17
     aa6:	0f 91       	pop	r16
     aa8:	ff 90       	pop	r15
     aaa:	ef 90       	pop	r14
     aac:	df 90       	pop	r13
     aae:	cf 90       	pop	r12
     ab0:	bf 90       	pop	r11
     ab2:	af 90       	pop	r10
     ab4:	9f 90       	pop	r9
     ab6:	8f 90       	pop	r8
     ab8:	08 95       	ret

00000aba <_Znwj>:
	*  @return A pointer to the memory area which has just been allocated
	*/

	void* operator new (size_t size)
	{
		return pvPortMalloc (size);
     aba:	0e 94 9d 08 	call	0x113a	; 0x113a <pvPortMalloc>
	}
     abe:	08 95       	ret

00000ac0 <_ZdlPv>:
	 *  @param ptr A pointer to the memory area whose contents are to be deleted
	 */

	void operator delete (void *ptr)
	{
		if (ptr) vPortFree (ptr);
     ac0:	00 97       	sbiw	r24, 0x00	; 0
     ac2:	11 f0       	breq	.+4      	; 0xac8 <_ZdlPv+0x8>
     ac4:	0e 94 c9 08 	call	0x1192	; 0x1192 <vPortFree>
     ac8:	08 95       	ret

00000aca <_Znaj>:
	 *  @return A pointer to the memory area which has just been allocated
	 */

	void* operator new[] (size_t size)
	{
		return pvPortMalloc (size);
     aca:	0e 94 9d 08 	call	0x113a	; 0x113a <pvPortMalloc>
	}
     ace:	08 95       	ret

00000ad0 <_ZdaPv>:
	 *  @param ptr A pointer to the memory area whose contents are to be deleted
	 */

	void operator delete[] (void *ptr)
	{
		if (ptr) vPortFree (ptr);
     ad0:	00 97       	sbiw	r24, 0x00	; 0
     ad2:	11 f0       	breq	.+4      	; 0xad8 <_ZdaPv+0x8>
     ad4:	0e 94 c9 08 	call	0x1192	; 0x1192 <vPortFree>
     ad8:	08 95       	ret

00000ada <__cxa_guard_acquire>:
 */
extern "C"
{
int __cxa_guard_acquire (__guard *g)
    {
    return !*(char *)(g);
     ada:	21 e0       	ldi	r18, 0x01	; 1
     adc:	30 e0       	ldi	r19, 0x00	; 0
     ade:	fc 01       	movw	r30, r24
     ae0:	80 81       	ld	r24, Z
     ae2:	88 23       	and	r24, r24
     ae4:	11 f0       	breq	.+4      	; 0xaea <__cxa_guard_acquire+0x10>
     ae6:	20 e0       	ldi	r18, 0x00	; 0
     ae8:	30 e0       	ldi	r19, 0x00	; 0
    }
     aea:	c9 01       	movw	r24, r18
     aec:	08 95       	ret

00000aee <__cxa_guard_release>:
 */
extern "C"
{
void __cxa_guard_release (__guard *g)
    {
    *(char *)g = 1;
     aee:	21 e0       	ldi	r18, 0x01	; 1
     af0:	fc 01       	movw	r30, r24
     af2:	20 83       	st	Z, r18
    }
     af4:	08 95       	ret

00000af6 <__cxa_guard_abort>:
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
		(void)g;							// Shuts up a dumb compiler warning
    }
     af6:	08 95       	ret

00000af8 <__cxa_pure_virtual>:

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    }
     af8:	08 95       	ret

00000afa <_ZN8emstream13ready_to_sendEv>:
 */

bool emstream::ready_to_send (void)
{
	return (true);                          // By default the port's always ready
}
     afa:	81 e0       	ldi	r24, 0x01	; 1
     afc:	08 95       	ret

00000afe <_ZN8emstream7getcharEv>:
 */

int16_t emstream::getchar (void)
{
	return ('\0');                          // Nothing to return, really
}
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	08 95       	ret

00000b04 <_ZN8emstream14check_for_charEv>:
 */

bool emstream::check_for_char (void)
{
	return (false);
}
     b04:	80 e0       	ldi	r24, 0x00	; 0
     b06:	08 95       	ret

00000b08 <_ZN8emstream12transmit_nowEv>:
 *  need to respond to calls for immediate transmission. 
 */

void emstream::transmit_now (void)
{
}
     b08:	08 95       	ret

00000b0a <_ZN8emstream12clear_screenEv>:
 *  classes which send things to displays should respond by clearing themselves.
 */

void emstream::clear_screen (void)
{
}
     b0a:	08 95       	ret

00000b0c <_ZN8emstreamC1Ev>:
//-------------------------------------------------------------------------------------
/** This constructor sets up the base serial port object. It sets the default base for
 *  the conversion of numbers to text and the default format for converting chars. 
 */

emstream::emstream (void)
     b0c:	fc 01       	movw	r30, r24
     b0e:	83 e7       	ldi	r24, 0x73	; 115
     b10:	92 e0       	ldi	r25, 0x02	; 2
     b12:	91 83       	std	Z+1, r25	; 0x01
     b14:	80 83       	st	Z, r24
{
	base = 10;                              // Numbers are shown as decimal by default
     b16:	8a e0       	ldi	r24, 0x0A	; 10
     b18:	82 83       	std	Z+2, r24	; 0x02
	print_ascii = false;                    // Print 8-bit chars as numbers by default
     b1a:	13 82       	std	Z+3, r1	; 0x03
	precision = 3;                          // Print 3 digits after a decimal point
     b1c:	83 e0       	ldi	r24, 0x03	; 3
     b1e:	85 83       	std	Z+5, r24	; 0x05
	pgm_string = false;                     // Print strings from SRAM by default
     b20:	14 82       	std	Z+4, r1	; 0x04
	p_hex_receiver = NULL;                  // No hex packet receiver has been set up
     b22:	17 82       	std	Z+7, r1	; 0x07
     b24:	16 82       	std	Z+6, r1	; 0x06
}
     b26:	08 95       	ret

00000b28 <_ZN8emstream4putsEPKc>:
 *  reached.
 *  @param p_string A pointer to the string which is to be printed
 */

void emstream::puts (const char* p_string)
{
     b28:	0f 93       	push	r16
     b2a:	1f 93       	push	r17
     b2c:	cf 93       	push	r28
     b2e:	df 93       	push	r29
     b30:	8c 01       	movw	r16, r24
     b32:	eb 01       	movw	r28, r22
	char ch;                                // Temporary storage for a character

	// If the program-string variable is set, this string is to be found in program
	// memory rather than data memory
	if (pgm_string)
     b34:	dc 01       	movw	r26, r24
     b36:	14 96       	adiw	r26, 0x04	; 4
     b38:	8c 91       	ld	r24, X
     b3a:	14 97       	sbiw	r26, 0x04	; 4
     b3c:	88 23       	and	r24, r24
     b3e:	a1 f4       	brne	.+40     	; 0xb68 <_ZN8emstream4putsEPKc+0x40>
	}
	// If the program-string variable is not set, the string is in RAM and printed
	// in the normal way
	else
	{
		while (*p_string)
     b40:	68 81       	ld	r22, Y
     b42:	66 23       	and	r22, r22
     b44:	61 f0       	breq	.+24     	; 0xb5e <_ZN8emstream4putsEPKc+0x36>
 *  character until and end of string character (the null character, \c '\0') is 
 *  reached.
 *  @param p_string A pointer to the string which is to be printed
 */

void emstream::puts (const char* p_string)
     b46:	21 96       	adiw	r28, 0x01	; 1
	// in the normal way
	else
	{
		while (*p_string)
		{
			putchar (*p_string++);
     b48:	d8 01       	movw	r26, r16
     b4a:	ed 91       	ld	r30, X+
     b4c:	fc 91       	ld	r31, X
     b4e:	02 80       	ldd	r0, Z+2	; 0x02
     b50:	f3 81       	ldd	r31, Z+3	; 0x03
     b52:	e0 2d       	mov	r30, r0
     b54:	c8 01       	movw	r24, r16
     b56:	09 95       	icall
	}
	// If the program-string variable is not set, the string is in RAM and printed
	// in the normal way
	else
	{
		while (*p_string)
     b58:	69 91       	ld	r22, Y+
     b5a:	66 23       	and	r22, r22
     b5c:	a9 f7       	brne	.-22     	; 0xb48 <_ZN8emstream4putsEPKc+0x20>
		{
			putchar (*p_string++);
		}
	}
}
     b5e:	df 91       	pop	r29
     b60:	cf 91       	pop	r28
     b62:	1f 91       	pop	r17
     b64:	0f 91       	pop	r16
     b66:	08 95       	ret

	// If the program-string variable is set, this string is to be found in program
	// memory rather than data memory
	if (pgm_string)
	{
		pgm_string = false;
     b68:	f8 01       	movw	r30, r16
     b6a:	14 82       	std	Z+4, r1	; 0x04
		while ((ch = pgm_read_byte_near (p_string++)))
     b6c:	fb 01       	movw	r30, r22
     b6e:	64 91       	lpm	r22, Z
     b70:	66 23       	and	r22, r22
     b72:	a9 f3       	breq	.-22     	; 0xb5e <_ZN8emstream4putsEPKc+0x36>
     b74:	21 96       	adiw	r28, 0x01	; 1
		{
			putchar (ch);
     b76:	f8 01       	movw	r30, r16
     b78:	a0 81       	ld	r26, Z
     b7a:	b1 81       	ldd	r27, Z+1	; 0x01
     b7c:	12 96       	adiw	r26, 0x02	; 2
     b7e:	ed 91       	ld	r30, X+
     b80:	fc 91       	ld	r31, X
     b82:	13 97       	sbiw	r26, 0x03	; 3
     b84:	c8 01       	movw	r24, r16
     b86:	09 95       	icall
	// If the program-string variable is set, this string is to be found in program
	// memory rather than data memory
	if (pgm_string)
	{
		pgm_string = false;
		while ((ch = pgm_read_byte_near (p_string++)))
     b88:	fe 01       	movw	r30, r28
     b8a:	21 96       	adiw	r28, 0x01	; 1
     b8c:	64 91       	lpm	r22, Z
     b8e:	66 23       	and	r22, r22
     b90:	91 f7       	brne	.-28     	; 0xb76 <_ZN8emstream4putsEPKc+0x4e>
		while (*p_string)
		{
			putchar (*p_string++);
		}
	}
}
     b92:	df 91       	pop	r29
     b94:	cf 91       	pop	r28
     b96:	1f 91       	pop	r17
     b98:	0f 91       	pop	r16
     b9a:	08 95       	ret

00000b9c <_Z12setprecisionh>:
{
	if (digits > 7)
	{
		digits = 7;
	}
	bts_glob_prec = digits;
     b9c:	88 30       	cpi	r24, 0x08	; 8
     b9e:	08 f0       	brcs	.+2      	; 0xba2 <_Z12setprecisionh+0x6>
     ba0:	87 e0       	ldi	r24, 0x07	; 7
     ba2:	80 93 7f 02 	sts	0x027F, r24

	return (manip_set_precision);
}
     ba6:	89 e0       	ldi	r24, 0x09	; 9
     ba8:	08 95       	ret

00000baa <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
     baa:	cf 93       	push	r28
     bac:	df 93       	push	r29
     bae:	ec 01       	movw	r28, r24
	switch (new_manip)
     bb0:	64 30       	cpi	r22, 0x04	; 4
     bb2:	09 f4       	brne	.+2      	; 0xbb6 <_ZN8emstreamlsE15ser_manipulator+0xc>
     bb4:	48 c0       	rjmp	.+144    	; 0xc46 <_ZN8emstreamlsE15ser_manipulator+0x9c>
     bb6:	65 30       	cpi	r22, 0x05	; 5
     bb8:	d8 f0       	brcs	.+54     	; 0xbf0 <_ZN8emstreamlsE15ser_manipulator+0x46>
     bba:	67 30       	cpi	r22, 0x07	; 7
     bbc:	81 f1       	breq	.+96     	; 0xc1e <_ZN8emstreamlsE15ser_manipulator+0x74>
     bbe:	68 30       	cpi	r22, 0x08	; 8
     bc0:	10 f5       	brcc	.+68     	; 0xc06 <_ZN8emstreamlsE15ser_manipulator+0x5c>
     bc2:	65 30       	cpi	r22, 0x05	; 5
     bc4:	51 f1       	breq	.+84     	; 0xc1a <_ZN8emstreamlsE15ser_manipulator+0x70>
     bc6:	66 30       	cpi	r22, 0x06	; 6
     bc8:	79 f4       	brne	.+30     	; 0xbe8 <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
			break;
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
     bca:	e8 81       	ld	r30, Y
     bcc:	f9 81       	ldd	r31, Y+1	; 0x01
     bce:	02 80       	ldd	r0, Z+2	; 0x02
     bd0:	f3 81       	ldd	r31, Z+3	; 0x03
     bd2:	e0 2d       	mov	r30, r0
     bd4:	6d e0       	ldi	r22, 0x0D	; 13
     bd6:	09 95       	icall
     bd8:	e8 81       	ld	r30, Y
     bda:	f9 81       	ldd	r31, Y+1	; 0x01
     bdc:	02 80       	ldd	r0, Z+2	; 0x02
     bde:	f3 81       	ldd	r31, Z+3	; 0x03
     be0:	e0 2d       	mov	r30, r0
     be2:	ce 01       	movw	r24, r28
     be4:	6a e0       	ldi	r22, 0x0A	; 10
     be6:	09 95       	icall
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
     be8:	ce 01       	movw	r24, r28
     bea:	df 91       	pop	r29
     bec:	cf 91       	pop	r28
     bee:	08 95       	ret
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
	switch (new_manip)
     bf0:	61 30       	cpi	r22, 0x01	; 1
     bf2:	31 f1       	breq	.+76     	; 0xc40 <_ZN8emstreamlsE15ser_manipulator+0x96>
     bf4:	61 30       	cpi	r22, 0x01	; 1
     bf6:	70 f0       	brcs	.+28     	; 0xc14 <_ZN8emstreamlsE15ser_manipulator+0x6a>
     bf8:	62 30       	cpi	r22, 0x02	; 2
     bfa:	c1 f0       	breq	.+48     	; 0xc2c <_ZN8emstreamlsE15ser_manipulator+0x82>
     bfc:	63 30       	cpi	r22, 0x03	; 3
     bfe:	a1 f7       	brne	.-24     	; 0xbe8 <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (dec):                         // Print integers in decimal
			base = 10;
			break;
		case (hex):                         // Print integers in hexadecimal
			base = 16;
     c00:	80 e1       	ldi	r24, 0x10	; 16
     c02:	8a 83       	std	Y+2, r24	; 0x02
			break;
     c04:	f1 cf       	rjmp	.-30     	; 0xbe8 <_ZN8emstreamlsE15ser_manipulator+0x3e>
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
	switch (new_manip)
     c06:	68 30       	cpi	r22, 0x08	; 8
     c08:	a1 f0       	breq	.+40     	; 0xc32 <_ZN8emstreamlsE15ser_manipulator+0x88>
     c0a:	6a 30       	cpi	r22, 0x0A	; 10
     c0c:	69 f7       	brne	.-38     	; 0xbe8 <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
			break;
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
     c0e:	81 e0       	ldi	r24, 0x01	; 1
     c10:	8c 83       	std	Y+4, r24	; 0x04
			break;
     c12:	ea cf       	rjmp	.-44     	; 0xbe8 <_ZN8emstreamlsE15ser_manipulator+0x3e>
emstream& emstream::operator<< (ser_manipulator new_manip)
{
	switch (new_manip)
	{
		case (bin):                         // Print integers in binary
			base = 2;
     c14:	82 e0       	ldi	r24, 0x02	; 2
     c16:	8a 83       	std	Y+2, r24	; 0x02
			break;
     c18:	e7 cf       	rjmp	.-50     	; 0xbe8 <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
			break;
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
     c1a:	1b 82       	std	Y+3, r1	; 0x03
			break;
     c1c:	e5 cf       	rjmp	.-54     	; 0xbe8 <_ZN8emstreamlsE15ser_manipulator+0x3e>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
			break;
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
     c1e:	e8 81       	ld	r30, Y
     c20:	f9 81       	ldd	r31, Y+1	; 0x01
     c22:	02 84       	ldd	r0, Z+10	; 0x0a
     c24:	f3 85       	ldd	r31, Z+11	; 0x0b
     c26:	e0 2d       	mov	r30, r0
     c28:	09 95       	icall
			break;
     c2a:	de cf       	rjmp	.-68     	; 0xbe8 <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (oct):                         // Print integers in octal
			base = 8;
			break;
		case (dec):                         // Print integers in decimal
			base = 10;
     c2c:	8a e0       	ldi	r24, 0x0A	; 10
     c2e:	8a 83       	std	Y+2, r24	; 0x02
			break;
     c30:	db cf       	rjmp	.-74     	; 0xbe8 <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
			break;
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
     c32:	e8 81       	ld	r30, Y
     c34:	f9 81       	ldd	r31, Y+1	; 0x01
     c36:	00 84       	ldd	r0, Z+8	; 0x08
     c38:	f1 85       	ldd	r31, Z+9	; 0x09
     c3a:	e0 2d       	mov	r30, r0
     c3c:	09 95       	icall
			break;
     c3e:	d4 cf       	rjmp	.-88     	; 0xbe8 <_ZN8emstreamlsE15ser_manipulator+0x3e>
	{
		case (bin):                         // Print integers in binary
			base = 2;
			break;
		case (oct):                         // Print integers in octal
			base = 8;
     c40:	88 e0       	ldi	r24, 0x08	; 8
     c42:	8a 83       	std	Y+2, r24	; 0x02
			break;
     c44:	d1 cf       	rjmp	.-94     	; 0xbe8 <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (hex):                         // Print integers in hexadecimal
			base = 16;
			break;
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
     c46:	81 e0       	ldi	r24, 0x01	; 1
     c48:	8b 83       	std	Y+3, r24	; 0x03
			break;
     c4a:	ce cf       	rjmp	.-100    	; 0xbe8 <_ZN8emstreamlsE15ser_manipulator+0x3e>

00000c4c <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
     c4c:	ff 92       	push	r15
     c4e:	0f 93       	push	r16
     c50:	1f 93       	push	r17
     c52:	cf 93       	push	r28
     c54:	df 93       	push	r29
     c56:	cd b7       	in	r28, 0x3d	; 61
     c58:	de b7       	in	r29, 0x3e	; 62
     c5a:	61 97       	sbiw	r28, 0x11	; 17
     c5c:	0f b6       	in	r0, 0x3f	; 63
     c5e:	f8 94       	cli
     c60:	de bf       	out	0x3e, r29	; 62
     c62:	0f be       	out	0x3f, r0	; 63
     c64:	cd bf       	out	0x3d, r28	; 61
     c66:	8c 01       	movw	r16, r24
     c68:	f6 2e       	mov	r15, r22
	if (base == 16 || base == 8 || base == 2)
     c6a:	fc 01       	movw	r30, r24
     c6c:	42 81       	ldd	r20, Z+2	; 0x02
     c6e:	40 31       	cpi	r20, 0x10	; 16
     c70:	99 f0       	breq	.+38     	; 0xc98 <_ZN8emstreamlsEj+0x4c>
     c72:	48 30       	cpi	r20, 0x08	; 8
     c74:	89 f0       	breq	.+34     	; 0xc98 <_ZN8emstreamlsEj+0x4c>
     c76:	42 30       	cpi	r20, 0x02	; 2
     c78:	79 f0       	breq	.+30     	; 0xc98 <_ZN8emstreamlsEj+0x4c>
		*this << parts.bits[1] << parts.bits[0];
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
     c7a:	86 2f       	mov	r24, r22
     c7c:	97 2f       	mov	r25, r23
     c7e:	be 01       	movw	r22, r28
     c80:	6f 5f       	subi	r22, 0xFF	; 255
     c82:	7f 4f       	sbci	r23, 0xFF	; 255
     c84:	50 e0       	ldi	r21, 0x00	; 0
     c86:	0e 94 b7 16 	call	0x2d6e	; 0x2d6e <utoa>
		puts (out_str);
     c8a:	c8 01       	movw	r24, r16
     c8c:	be 01       	movw	r22, r28
     c8e:	6f 5f       	subi	r22, 0xFF	; 255
     c90:	7f 4f       	sbci	r23, 0xFF	; 255
     c92:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
     c96:	07 c0       	rjmp	.+14     	; 0xca6 <_ZN8emstreamlsEj+0x5a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
     c98:	c8 01       	movw	r24, r16
     c9a:	67 2f       	mov	r22, r23
     c9c:	0e 94 a6 06 	call	0xd4c	; 0xd4c <_ZN8emstreamlsEh>
     ca0:	6f 2d       	mov	r22, r15
     ca2:	0e 94 a6 06 	call	0xd4c	; 0xd4c <_ZN8emstreamlsEh>
		utoa (num, out_str, base);
		puts (out_str);
	}

	return (*this);
}
     ca6:	c8 01       	movw	r24, r16
     ca8:	61 96       	adiw	r28, 0x11	; 17
     caa:	0f b6       	in	r0, 0x3f	; 63
     cac:	f8 94       	cli
     cae:	de bf       	out	0x3e, r29	; 62
     cb0:	0f be       	out	0x3f, r0	; 63
     cb2:	cd bf       	out	0x3d, r28	; 61
     cb4:	df 91       	pop	r29
     cb6:	cf 91       	pop	r28
     cb8:	1f 91       	pop	r17
     cba:	0f 91       	pop	r16
     cbc:	ff 90       	pop	r15
     cbe:	08 95       	ret

00000cc0 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
     cc0:	ff 92       	push	r15
     cc2:	0f 93       	push	r16
     cc4:	1f 93       	push	r17
     cc6:	cf 93       	push	r28
     cc8:	df 93       	push	r29
     cca:	cd b7       	in	r28, 0x3d	; 61
     ccc:	de b7       	in	r29, 0x3e	; 62
     cce:	a3 97       	sbiw	r28, 0x23	; 35
     cd0:	0f b6       	in	r0, 0x3f	; 63
     cd2:	f8 94       	cli
     cd4:	de bf       	out	0x3e, r29	; 62
     cd6:	0f be       	out	0x3f, r0	; 63
     cd8:	cd bf       	out	0x3d, r28	; 61
     cda:	8c 01       	movw	r16, r24
     cdc:	f6 2e       	mov	r15, r22
     cde:	37 2f       	mov	r19, r23
	if (base == 16 || base == 8 || base == 2)
     ce0:	fc 01       	movw	r30, r24
     ce2:	22 81       	ldd	r18, Z+2	; 0x02
     ce4:	20 31       	cpi	r18, 0x10	; 16
     ce6:	a1 f0       	breq	.+40     	; 0xd10 <_ZN8emstreamlsEm+0x50>
     ce8:	28 30       	cpi	r18, 0x08	; 8
     cea:	91 f0       	breq	.+36     	; 0xd10 <_ZN8emstreamlsEm+0x50>
     cec:	22 30       	cpi	r18, 0x02	; 2
     cee:	81 f0       	breq	.+32     	; 0xd10 <_ZN8emstreamlsEm+0x50>
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
     cf0:	ba 01       	movw	r22, r20
     cf2:	8f 2d       	mov	r24, r15
     cf4:	93 2f       	mov	r25, r19
     cf6:	ae 01       	movw	r20, r28
     cf8:	4f 5f       	subi	r20, 0xFF	; 255
     cfa:	5f 4f       	sbci	r21, 0xFF	; 255
     cfc:	30 e0       	ldi	r19, 0x00	; 0
     cfe:	0e 94 92 16 	call	0x2d24	; 0x2d24 <ultoa>
		puts (out_str);
     d02:	c8 01       	movw	r24, r16
     d04:	be 01       	movw	r22, r28
     d06:	6f 5f       	subi	r22, 0xFF	; 255
     d08:	7f 4f       	sbci	r23, 0xFF	; 255
     d0a:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
     d0e:	11 c0       	rjmp	.+34     	; 0xd32 <_ZN8emstreamlsEm+0x72>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
     d10:	c8 01       	movw	r24, r16
     d12:	63 2f       	mov	r22, r19
     d14:	4b a3       	lds	r20, 0x5b
     d16:	5a a3       	lds	r21, 0x5a
     d18:	0e 94 a6 06 	call	0xd4c	; 0xd4c <_ZN8emstreamlsEh>
     d1c:	6f 2d       	mov	r22, r15
     d1e:	0e 94 a6 06 	call	0xd4c	; 0xd4c <_ZN8emstreamlsEh>
     d22:	5a a1       	lds	r21, 0x4a
     d24:	65 2f       	mov	r22, r21
     d26:	0e 94 a6 06 	call	0xd4c	; 0xd4c <_ZN8emstreamlsEh>
     d2a:	4b a1       	lds	r20, 0x4b
     d2c:	64 2f       	mov	r22, r20
     d2e:	0e 94 a6 06 	call	0xd4c	; 0xd4c <_ZN8emstreamlsEh>
		ultoa ((long)num, out_str, base);
		puts (out_str);
	}

	return (*this);
}
     d32:	c8 01       	movw	r24, r16
     d34:	a3 96       	adiw	r28, 0x23	; 35
     d36:	0f b6       	in	r0, 0x3f	; 63
     d38:	f8 94       	cli
     d3a:	de bf       	out	0x3e, r29	; 62
     d3c:	0f be       	out	0x3f, r0	; 63
     d3e:	cd bf       	out	0x3d, r28	; 61
     d40:	df 91       	pop	r29
     d42:	cf 91       	pop	r28
     d44:	1f 91       	pop	r17
     d46:	0f 91       	pop	r16
     d48:	ff 90       	pop	r15
     d4a:	08 95       	ret

00000d4c <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
     d4c:	cf 92       	push	r12
     d4e:	df 92       	push	r13
     d50:	ef 92       	push	r14
     d52:	ff 92       	push	r15
     d54:	0f 93       	push	r16
     d56:	1f 93       	push	r17
     d58:	cf 93       	push	r28
     d5a:	df 93       	push	r29
     d5c:	cd b7       	in	r28, 0x3d	; 61
     d5e:	de b7       	in	r29, 0x3e	; 62
     d60:	29 97       	sbiw	r28, 0x09	; 9
     d62:	0f b6       	in	r0, 0x3f	; 63
     d64:	f8 94       	cli
     d66:	de bf       	out	0x3e, r29	; 62
     d68:	0f be       	out	0x3f, r0	; 63
     d6a:	cd bf       	out	0x3d, r28	; 61
     d6c:	6c 01       	movw	r12, r24
     d6e:	06 2f       	mov	r16, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
     d70:	dc 01       	movw	r26, r24
     d72:	13 96       	adiw	r26, 0x03	; 3
     d74:	8c 91       	ld	r24, X
     d76:	13 97       	sbiw	r26, 0x03	; 3
     d78:	88 23       	and	r24, r24
     d7a:	09 f0       	breq	.+2      	; 0xd7e <_ZN8emstreamlsEh+0x32>
     d7c:	5e c0       	rjmp	.+188    	; 0xe3a <_ZN8emstreamlsEh+0xee>
	{
		putchar (num);
	}
	else if (base == 2)
     d7e:	f6 01       	movw	r30, r12
     d80:	42 81       	ldd	r20, Z+2	; 0x02
     d82:	42 30       	cpi	r20, 0x02	; 2
     d84:	e1 f1       	breq	.+120    	; 0xdfe <_ZN8emstreamlsEh+0xb2>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
     d86:	40 31       	cpi	r20, 0x10	; 16
     d88:	f1 f0       	breq	.+60     	; 0xdc6 <_ZN8emstreamlsEh+0x7a>
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
     d8a:	86 2f       	mov	r24, r22
     d8c:	90 e0       	ldi	r25, 0x00	; 0
     d8e:	be 01       	movw	r22, r28
     d90:	6f 5f       	subi	r22, 0xFF	; 255
     d92:	7f 4f       	sbci	r23, 0xFF	; 255
     d94:	50 e0       	ldi	r21, 0x00	; 0
     d96:	0e 94 b7 16 	call	0x2d6e	; 0x2d6e <utoa>
		puts (out_str);
     d9a:	c6 01       	movw	r24, r12
     d9c:	be 01       	movw	r22, r28
     d9e:	6f 5f       	subi	r22, 0xFF	; 255
     da0:	7f 4f       	sbci	r23, 0xFF	; 255
     da2:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
     da6:	c6 01       	movw	r24, r12
     da8:	29 96       	adiw	r28, 0x09	; 9
     daa:	0f b6       	in	r0, 0x3f	; 63
     dac:	f8 94       	cli
     dae:	de bf       	out	0x3e, r29	; 62
     db0:	0f be       	out	0x3f, r0	; 63
     db2:	cd bf       	out	0x3d, r28	; 61
     db4:	df 91       	pop	r29
     db6:	cf 91       	pop	r28
     db8:	1f 91       	pop	r17
     dba:	0f 91       	pop	r16
     dbc:	ff 90       	pop	r15
     dbe:	ef 90       	pop	r14
     dc0:	df 90       	pop	r13
     dc2:	cf 90       	pop	r12
     dc4:	08 95       	ret
			else             putchar ('0');
		}
	}
	else if (base == 16)
	{
		temp_char = (num >> 4) & 0x0F;
     dc6:	62 95       	swap	r22
     dc8:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
     dca:	01 90       	ld	r0, Z+
     dcc:	f0 81       	ld	r31, Z
     dce:	e0 2d       	mov	r30, r0
     dd0:	02 80       	ldd	r0, Z+2	; 0x02
     dd2:	f3 81       	ldd	r31, Z+3	; 0x03
     dd4:	e0 2d       	mov	r30, r0
     dd6:	6a 30       	cpi	r22, 0x0A	; 10
     dd8:	c0 f5       	brcc	.+112    	; 0xe4a <_ZN8emstreamlsEh+0xfe>
     dda:	60 5d       	subi	r22, 0xD0	; 208
     ddc:	c6 01       	movw	r24, r12
     dde:	09 95       	icall
		temp_char = num & 0x0F;
     de0:	0f 70       	andi	r16, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
     de2:	d6 01       	movw	r26, r12
     de4:	ed 91       	ld	r30, X+
     de6:	fc 91       	ld	r31, X
     de8:	11 97       	sbiw	r26, 0x01	; 1
     dea:	02 80       	ldd	r0, Z+2	; 0x02
     dec:	f3 81       	ldd	r31, Z+3	; 0x03
     dee:	e0 2d       	mov	r30, r0
     df0:	60 2f       	mov	r22, r16
     df2:	0a 30       	cpi	r16, 0x0A	; 10
     df4:	60 f1       	brcs	.+88     	; 0xe4e <_ZN8emstreamlsEh+0x102>
     df6:	69 5c       	subi	r22, 0xC9	; 201
     df8:	c6 01       	movw	r24, r12
     dfa:	09 95       	icall
     dfc:	d4 cf       	rjmp	.-88     	; 0xda6 <_ZN8emstreamlsEh+0x5a>

	if (print_ascii)
	{
		putchar (num);
	}
	else if (base == 2)
     dfe:	88 e0       	ldi	r24, 0x08	; 8
     e00:	e8 2e       	mov	r14, r24
     e02:	f1 2c       	mov	r15, r1
     e04:	10 e8       	ldi	r17, 0x80	; 128
     e06:	0a c0       	rjmp	.+20     	; 0xe1c <_ZN8emstreamlsEh+0xd0>
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
     e08:	c6 01       	movw	r24, r12
     e0a:	61 e3       	ldi	r22, 0x31	; 49
     e0c:	09 95       	icall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
     e0e:	16 95       	lsr	r17
     e10:	08 94       	sec
     e12:	e1 08       	sbc	r14, r1
     e14:	f1 08       	sbc	r15, r1
     e16:	e1 14       	cp	r14, r1
     e18:	f1 04       	cpc	r15, r1
     e1a:	29 f2       	breq	.-118    	; 0xda6 <_ZN8emstreamlsEh+0x5a>
		{
			if (num & bmask) putchar ('1');
     e1c:	81 2f       	mov	r24, r17
     e1e:	80 23       	and	r24, r16
     e20:	d6 01       	movw	r26, r12
     e22:	ed 91       	ld	r30, X+
     e24:	fc 91       	ld	r31, X
     e26:	11 97       	sbiw	r26, 0x01	; 1
     e28:	02 80       	ldd	r0, Z+2	; 0x02
     e2a:	f3 81       	ldd	r31, Z+3	; 0x03
     e2c:	e0 2d       	mov	r30, r0
     e2e:	88 23       	and	r24, r24
     e30:	59 f7       	brne	.-42     	; 0xe08 <_ZN8emstreamlsEh+0xbc>
			else             putchar ('0');
     e32:	c6 01       	movw	r24, r12
     e34:	60 e3       	ldi	r22, 0x30	; 48
     e36:	09 95       	icall
     e38:	ea cf       	rjmp	.-44     	; 0xe0e <_ZN8emstreamlsEh+0xc2>
{
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
	{
		putchar (num);
     e3a:	ed 91       	ld	r30, X+
     e3c:	fc 91       	ld	r31, X
     e3e:	02 80       	ldd	r0, Z+2	; 0x02
     e40:	f3 81       	ldd	r31, Z+3	; 0x03
     e42:	e0 2d       	mov	r30, r0
     e44:	c6 01       	movw	r24, r12
     e46:	09 95       	icall
     e48:	ae cf       	rjmp	.-164    	; 0xda6 <_ZN8emstreamlsEh+0x5a>
		}
	}
	else if (base == 16)
	{
		temp_char = (num >> 4) & 0x0F;
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
     e4a:	69 5c       	subi	r22, 0xC9	; 201
     e4c:	c7 cf       	rjmp	.-114    	; 0xddc <_ZN8emstreamlsEh+0x90>
		temp_char = num & 0x0F;
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
     e4e:	60 5d       	subi	r22, 0xD0	; 208
     e50:	d3 cf       	rjmp	.-90     	; 0xdf8 <_ZN8emstreamlsEh+0xac>

00000e52 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
     e52:	fc 01       	movw	r30, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
     e54:	a2 85       	ldd	r26, Z+10	; 0x0a
     e56:	b3 85       	ldd	r27, Z+11	; 0x0b
     e58:	8c 91       	ld	r24, X
     e5a:	36 85       	ldd	r19, Z+14	; 0x0e
     e5c:	83 23       	and	r24, r19
     e5e:	41 f4       	brne	.+16     	; 0xe70 <_ZN5rs2327putcharEc+0x1e>
     e60:	81 e2       	ldi	r24, 0x21	; 33
     e62:	9e e4       	ldi	r25, 0x4E	; 78
     e64:	02 c0       	rjmp	.+4      	; 0xe6a <_ZN5rs2327putcharEc+0x18>
     e66:	01 97       	sbiw	r24, 0x01	; 1
	{
		if (count > UART_TX_TOUT)
     e68:	69 f0       	breq	.+26     	; 0xe84 <_ZN5rs2327putcharEc+0x32>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
     e6a:	2c 91       	ld	r18, X
     e6c:	23 23       	and	r18, r19
     e6e:	d9 f3       	breq	.-10     	; 0xe66 <_ZN5rs2327putcharEc+0x14>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
     e70:	8c 91       	ld	r24, X
     e72:	90 89       	ldd	r25, Z+16	; 0x10
     e74:	89 2b       	or	r24, r25
     e76:	8c 93       	st	X, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
     e78:	00 84       	ldd	r0, Z+8	; 0x08
     e7a:	f1 85       	ldd	r31, Z+9	; 0x09
     e7c:	e0 2d       	mov	r30, r0
     e7e:	60 83       	st	Z, r22
	return (true);
     e80:	81 e0       	ldi	r24, 0x01	; 1
     e82:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
     e84:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
     e86:	08 95       	ret

00000e88 <_ZN5rs2327getcharEv>:
{
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	#ifdef UCSR0A  // If this is a dual-port chip
		if (port_num == 0)
     e88:	fc 01       	movw	r30, r24
     e8a:	81 89       	ldd	r24, Z+17	; 0x11
     e8c:	88 23       	and	r24, r24
     e8e:	09 f5       	brne	.+66     	; 0xed2 <_ZN5rs2327getcharEv+0x4a>
     e90:	20 91 b4 02 	lds	r18, 0x02B4
     e94:	30 91 b5 02 	lds	r19, 0x02B5
		{
			while (rcv0_read_index == rcv0_write_index);
     e98:	80 91 b2 02 	lds	r24, 0x02B2
     e9c:	90 91 b3 02 	lds	r25, 0x02B3
     ea0:	28 17       	cp	r18, r24
     ea2:	39 07       	cpc	r19, r25
     ea4:	c1 f1       	breq	.+112    	; 0xf16 <_ZN5rs2327getcharEv+0x8e>
			recv_char = rcv0_buffer[rcv0_read_index];
     ea6:	e0 91 b6 02 	lds	r30, 0x02B6
     eaa:	f0 91 b7 02 	lds	r31, 0x02B7
     eae:	e2 0f       	add	r30, r18
     eb0:	f3 1f       	adc	r31, r19
     eb2:	80 81       	ld	r24, Z
			if (++rcv0_read_index >= RSINT_BUF_SIZE)
     eb4:	2f 5f       	subi	r18, 0xFF	; 255
     eb6:	3f 4f       	sbci	r19, 0xFF	; 255
     eb8:	30 93 b5 02 	sts	0x02B5, r19
     ebc:	20 93 b4 02 	sts	0x02B4, r18
     ec0:	20 32       	cpi	r18, 0x20	; 32
     ec2:	31 05       	cpc	r19, r1
     ec4:	20 f0       	brcs	.+8      	; 0xece <_ZN5rs2327getcharEv+0x46>
				rcv0_read_index = 0;
     ec6:	10 92 b5 02 	sts	0x02B5, r1
     eca:	10 92 b4 02 	sts	0x02B4, r1
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
	#endif

	return (recv_char);
}
     ece:	90 e0       	ldi	r25, 0x00	; 0
     ed0:	08 95       	ret
		if (port_num == 0)
		{
			while (rcv0_read_index == rcv0_write_index);
			recv_char = rcv0_buffer[rcv0_read_index];
			if (++rcv0_read_index >= RSINT_BUF_SIZE)
				rcv0_read_index = 0;
     ed2:	20 91 ae 02 	lds	r18, 0x02AE
     ed6:	30 91 af 02 	lds	r19, 0x02AF
		}
		else  // This is port 1 of a dual-port chip
		{
		#if defined UCSR1A
			while (rcv1_read_index == rcv1_write_index);
     eda:	80 91 ac 02 	lds	r24, 0x02AC
     ede:	90 91 ad 02 	lds	r25, 0x02AD
     ee2:	82 17       	cp	r24, r18
     ee4:	93 07       	cpc	r25, r19
     ee6:	b1 f0       	breq	.+44     	; 0xf14 <_ZN5rs2327getcharEv+0x8c>
			recv_char = rcv1_buffer[rcv1_read_index];
     ee8:	e0 91 b0 02 	lds	r30, 0x02B0
     eec:	f0 91 b1 02 	lds	r31, 0x02B1
     ef0:	e2 0f       	add	r30, r18
     ef2:	f3 1f       	adc	r31, r19
     ef4:	80 81       	ld	r24, Z
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
     ef6:	2f 5f       	subi	r18, 0xFF	; 255
     ef8:	3f 4f       	sbci	r19, 0xFF	; 255
     efa:	30 93 af 02 	sts	0x02AF, r19
     efe:	20 93 ae 02 	sts	0x02AE, r18
     f02:	20 32       	cpi	r18, 0x20	; 32
     f04:	31 05       	cpc	r19, r1
     f06:	18 f3       	brcs	.-58     	; 0xece <_ZN5rs2327getcharEv+0x46>
				rcv1_read_index = 0;
     f08:	10 92 af 02 	sts	0x02AF, r1
     f0c:	10 92 ae 02 	sts	0x02AE, r1
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
	#endif

	return (recv_char);
}
     f10:	90 e0       	ldi	r25, 0x00	; 0
     f12:	08 95       	ret
     f14:	ff cf       	rjmp	.-2      	; 0xf14 <_ZN5rs2327getcharEv+0x8c>
     f16:	ff cf       	rjmp	.-2      	; 0xf16 <_ZN5rs2327getcharEv+0x8e>

00000f18 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
     f18:	dc 01       	movw	r26, r24
     f1a:	ed 91       	ld	r30, X+
     f1c:	fc 91       	ld	r31, X
     f1e:	02 80       	ldd	r0, Z+2	; 0x02
     f20:	f3 81       	ldd	r31, Z+3	; 0x03
     f22:	e0 2d       	mov	r30, r0
     f24:	6c e0       	ldi	r22, 0x0C	; 12
     f26:	09 95       	icall
}
     f28:	08 95       	ret

00000f2a <_ZN5rs23214check_for_charEv>:
 */

bool rs232::check_for_char (void)
{
	#ifdef UCSR1A							// If this is a dual-port chip
		if (port_num == 0)
     f2a:	fc 01       	movw	r30, r24
     f2c:	81 89       	ldd	r24, Z+17	; 0x11
     f2e:	88 23       	and	r24, r24
     f30:	69 f0       	breq	.+26     	; 0xf4c <_ZN5rs23214check_for_charEv+0x22>
			return (rcv0_read_index != rcv0_write_index);
		else
			return (rcv1_read_index != rcv1_write_index);
     f32:	81 e0       	ldi	r24, 0x01	; 1
     f34:	40 91 ae 02 	lds	r20, 0x02AE
     f38:	50 91 af 02 	lds	r21, 0x02AF
     f3c:	20 91 ac 02 	lds	r18, 0x02AC
     f40:	30 91 ad 02 	lds	r19, 0x02AD
     f44:	42 17       	cp	r20, r18
     f46:	53 07       	cpc	r21, r19
     f48:	79 f0       	breq	.+30     	; 0xf68 <_ZN5rs23214check_for_charEv+0x3e>
	#else									// This chip has only one serial port
		return (rcv0_read_index != rcv0_write_index);
	#endif
}
     f4a:	08 95       	ret

bool rs232::check_for_char (void)
{
	#ifdef UCSR1A							// If this is a dual-port chip
		if (port_num == 0)
			return (rcv0_read_index != rcv0_write_index);
     f4c:	81 e0       	ldi	r24, 0x01	; 1
     f4e:	40 91 b4 02 	lds	r20, 0x02B4
     f52:	50 91 b5 02 	lds	r21, 0x02B5
     f56:	20 91 b2 02 	lds	r18, 0x02B2
     f5a:	30 91 b3 02 	lds	r19, 0x02B3
     f5e:	42 17       	cp	r20, r18
     f60:	53 07       	cpc	r21, r19
     f62:	99 f7       	brne	.-26     	; 0xf4a <_ZN5rs23214check_for_charEv+0x20>
     f64:	80 e0       	ldi	r24, 0x00	; 0
     f66:	08 95       	ret
		else
			return (rcv1_read_index != rcv1_write_index);
     f68:	80 e0       	ldi	r24, 0x00	; 0
	#else									// This chip has only one serial port
		return (rcv0_read_index != rcv0_write_index);
	#endif
}
     f6a:	08 95       	ret

00000f6c <_ZN5rs232C1Ejh>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

rs232::rs232 (uint16_t baud_rate, uint8_t port_number)
     f6c:	ff 92       	push	r15
     f6e:	0f 93       	push	r16
     f70:	1f 93       	push	r17
     f72:	cf 93       	push	r28
     f74:	df 93       	push	r29
     f76:	ec 01       	movw	r28, r24
     f78:	8b 01       	movw	r16, r22
     f7a:	f4 2e       	mov	r15, r20
	: emstream (), base232 (baud_rate, port_number)
     f7c:	0e 94 86 05 	call	0xb0c	; 0xb0c <_ZN8emstreamC1Ev>
     f80:	ce 01       	movw	r24, r28
     f82:	08 96       	adiw	r24, 0x08	; 8
     f84:	b8 01       	movw	r22, r16
     f86:	4f 2d       	mov	r20, r15
     f88:	0e 94 8a 14 	call	0x2914	; 0x2914 <_ZN7base232C1Ejh>
     f8c:	84 e8       	ldi	r24, 0x84	; 132
     f8e:	92 e0       	ldi	r25, 0x02	; 2
     f90:	99 83       	std	Y+1, r25	; 0x01
     f92:	88 83       	st	Y, r24
{
	// Save the number of the serial port, 0 or 1
	port_num = port_number;
     f94:	f9 8a       	std	Y+17, r15	; 0x11

	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A // Serial port number 0
		if (port_number == 0)
     f96:	ff 20       	and	r15, r15
     f98:	d9 f0       	breq	.+54     	; 0xfd0 <_ZN5rs232C1Ejh+0x64>
			rcv0_write_index = 0;
		}
		else  // Serial port number 1
		{
		#if defined UCSR1A
			UCSR1B |= (1 << RXCIE1);		// Receive complete interrupt enable
     f9a:	80 91 c9 00 	lds	r24, 0x00C9
     f9e:	80 68       	ori	r24, 0x80	; 128
     fa0:	80 93 c9 00 	sts	0x00C9, r24

			// Allocate some memory for the receiver buffer and reset the indices
			rcv1_buffer = new uint8_t[RSINT_BUF_SIZE];
     fa4:	80 e2       	ldi	r24, 0x20	; 32
     fa6:	90 e0       	ldi	r25, 0x00	; 0
     fa8:	0e 94 65 05 	call	0xaca	; 0xaca <_Znaj>
     fac:	90 93 b1 02 	sts	0x02B1, r25
     fb0:	80 93 b0 02 	sts	0x02B0, r24
			rcv1_read_index = 0;
     fb4:	10 92 af 02 	sts	0x02AF, r1
     fb8:	10 92 ae 02 	sts	0x02AE, r1
			rcv1_write_index = 0;
     fbc:	10 92 ad 02 	sts	0x02AD, r1
     fc0:	10 92 ac 02 	sts	0x02AC, r1
	// use the XBee radio module
	#ifdef XIPHOS_HACKS
		if (port_number == 1)
			PORTD |= 0x04;
	#endif
}
     fc4:	df 91       	pop	r29
     fc6:	cf 91       	pop	r28
     fc8:	1f 91       	pop	r17
     fca:	0f 91       	pop	r16
     fcc:	ff 90       	pop	r15
     fce:	08 95       	ret
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A // Serial port number 0
		if (port_number == 0)
		{
			UCSR0B |= (1 << RXCIE0);		// Receive complete interrupt enable
     fd0:	80 91 c1 00 	lds	r24, 0x00C1
     fd4:	80 68       	ori	r24, 0x80	; 128
     fd6:	80 93 c1 00 	sts	0x00C1, r24

			// Allocate some memory for the receiver buffer and reset the indices
			rcv0_buffer = new uint8_t[RSINT_BUF_SIZE];
     fda:	80 e2       	ldi	r24, 0x20	; 32
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	0e 94 65 05 	call	0xaca	; 0xaca <_Znaj>
     fe2:	90 93 b7 02 	sts	0x02B7, r25
     fe6:	80 93 b6 02 	sts	0x02B6, r24
			rcv0_read_index = 0;
     fea:	10 92 b5 02 	sts	0x02B5, r1
     fee:	10 92 b4 02 	sts	0x02B4, r1
			rcv0_write_index = 0;
     ff2:	10 92 b3 02 	sts	0x02B3, r1
     ff6:	10 92 b2 02 	sts	0x02B2, r1
	// use the XBee radio module
	#ifdef XIPHOS_HACKS
		if (port_number == 1)
			PORTD |= 0x04;
	#endif
}
     ffa:	df 91       	pop	r29
     ffc:	cf 91       	pop	r28
     ffe:	1f 91       	pop	r17
    1000:	0f 91       	pop	r16
    1002:	ff 90       	pop	r15
    1004:	08 95       	ret

00001006 <__vector_25>:
 *  This interrupt service routine runs whenever a character has been received by the
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

ISR (RSI_CHAR_RECV_INT_0)
{
    1006:	1f 92       	push	r1
    1008:	0f 92       	push	r0
    100a:	0f b6       	in	r0, 0x3f	; 63
    100c:	0f 92       	push	r0
    100e:	0b b6       	in	r0, 0x3b	; 59
    1010:	0f 92       	push	r0
    1012:	11 24       	eor	r1, r1
    1014:	2f 93       	push	r18
    1016:	3f 93       	push	r19
    1018:	8f 93       	push	r24
    101a:	9f 93       	push	r25
    101c:	ef 93       	push	r30
    101e:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	#if defined UCSR0A  // If this is a dual-serial-port chip (ATmega324P, 128, etc.)
		rcv0_buffer[rcv0_write_index] = UDR0;
    1020:	20 91 c6 00 	lds	r18, 0x00C6
    1024:	e0 91 b6 02 	lds	r30, 0x02B6
    1028:	f0 91 b7 02 	lds	r31, 0x02B7
    102c:	80 91 b2 02 	lds	r24, 0x02B2
    1030:	90 91 b3 02 	lds	r25, 0x02B3
    1034:	e8 0f       	add	r30, r24
    1036:	f9 1f       	adc	r31, r25
    1038:	20 83       	st	Z, r18
	#else  // If this chip has only a single serial port (ATmega8, 32, etc.)
		rcv0_buffer[rcv0_write_index] = UDR;
	#endif

	// Increment the write pointer
	if (++rcv0_write_index >= RSINT_BUF_SIZE)
    103a:	80 91 b2 02 	lds	r24, 0x02B2
    103e:	90 91 b3 02 	lds	r25, 0x02B3
    1042:	01 96       	adiw	r24, 0x01	; 1
    1044:	90 93 b3 02 	sts	0x02B3, r25
    1048:	80 93 b2 02 	sts	0x02B2, r24
    104c:	80 32       	cpi	r24, 0x20	; 32
    104e:	91 05       	cpc	r25, r1
    1050:	30 f0       	brcs	.+12     	; 0x105e <__vector_25+0x58>
		rcv0_write_index = 0;
    1052:	10 92 b3 02 	sts	0x02B3, r1
    1056:	10 92 b2 02 	sts	0x02B2, r1
    105a:	80 e0       	ldi	r24, 0x00	; 0
    105c:	90 e0       	ldi	r25, 0x00	; 0

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
    105e:	20 91 b4 02 	lds	r18, 0x02B4
    1062:	30 91 b5 02 	lds	r19, 0x02B5
    1066:	28 17       	cp	r18, r24
    1068:	39 07       	cpc	r19, r25
    106a:	69 f0       	breq	.+26     	; 0x1086 <__vector_25+0x80>
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
}
    106c:	ff 91       	pop	r31
    106e:	ef 91       	pop	r30
    1070:	9f 91       	pop	r25
    1072:	8f 91       	pop	r24
    1074:	3f 91       	pop	r19
    1076:	2f 91       	pop	r18
    1078:	0f 90       	pop	r0
    107a:	0b be       	out	0x3b, r0	; 59
    107c:	0f 90       	pop	r0
    107e:	0f be       	out	0x3f, r0	; 63
    1080:	0f 90       	pop	r0
    1082:	1f 90       	pop	r1
    1084:	18 95       	reti

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
    1086:	01 96       	adiw	r24, 0x01	; 1
    1088:	90 93 b5 02 	sts	0x02B5, r25
    108c:	80 93 b4 02 	sts	0x02B4, r24
    1090:	80 32       	cpi	r24, 0x20	; 32
    1092:	91 05       	cpc	r25, r1
    1094:	58 f3       	brcs	.-42     	; 0x106c <__vector_25+0x66>
			rcv0_read_index = 0;
    1096:	10 92 b5 02 	sts	0x02B5, r1
    109a:	10 92 b4 02 	sts	0x02B4, r1
    109e:	e6 cf       	rjmp	.-52     	; 0x106c <__vector_25+0x66>

000010a0 <__vector_36>:
	/** This interrupt service routine runs whenever a character has been received by the
	*  first serial port (number 0).  It saves that character into the receiver buffer.
	*/

	ISR (RSI_CHAR_RECV_INT_1)
	{
    10a0:	1f 92       	push	r1
    10a2:	0f 92       	push	r0
    10a4:	0f b6       	in	r0, 0x3f	; 63
    10a6:	0f 92       	push	r0
    10a8:	0b b6       	in	r0, 0x3b	; 59
    10aa:	0f 92       	push	r0
    10ac:	11 24       	eor	r1, r1
    10ae:	2f 93       	push	r18
    10b0:	3f 93       	push	r19
    10b2:	8f 93       	push	r24
    10b4:	9f 93       	push	r25
    10b6:	ef 93       	push	r30
    10b8:	ff 93       	push	r31
		// Read the character from the serial port receiver buffer
		rcv1_buffer[rcv1_write_index] = UDR1;
    10ba:	20 91 ce 00 	lds	r18, 0x00CE
    10be:	e0 91 b0 02 	lds	r30, 0x02B0
    10c2:	f0 91 b1 02 	lds	r31, 0x02B1
    10c6:	80 91 ac 02 	lds	r24, 0x02AC
    10ca:	90 91 ad 02 	lds	r25, 0x02AD
    10ce:	e8 0f       	add	r30, r24
    10d0:	f9 1f       	adc	r31, r25
    10d2:	20 83       	st	Z, r18

		// Increment the write pointer
		if (++rcv1_write_index >= RSINT_BUF_SIZE)
    10d4:	80 91 ac 02 	lds	r24, 0x02AC
    10d8:	90 91 ad 02 	lds	r25, 0x02AD
    10dc:	01 96       	adiw	r24, 0x01	; 1
    10de:	90 93 ad 02 	sts	0x02AD, r25
    10e2:	80 93 ac 02 	sts	0x02AC, r24
    10e6:	80 32       	cpi	r24, 0x20	; 32
    10e8:	91 05       	cpc	r25, r1
    10ea:	30 f0       	brcs	.+12     	; 0x10f8 <__vector_36+0x58>
			rcv1_write_index = 0;
    10ec:	10 92 ad 02 	sts	0x02AD, r1
    10f0:	10 92 ac 02 	sts	0x02AC, r1
    10f4:	80 e0       	ldi	r24, 0x00	; 0
    10f6:	90 e0       	ldi	r25, 0x00	; 0

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
    10f8:	20 91 ae 02 	lds	r18, 0x02AE
    10fc:	30 91 af 02 	lds	r19, 0x02AF
    1100:	28 17       	cp	r18, r24
    1102:	39 07       	cpc	r19, r25
    1104:	69 f0       	breq	.+26     	; 0x1120 <__vector_36+0x80>
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
				rcv1_read_index = 0;
	}
    1106:	ff 91       	pop	r31
    1108:	ef 91       	pop	r30
    110a:	9f 91       	pop	r25
    110c:	8f 91       	pop	r24
    110e:	3f 91       	pop	r19
    1110:	2f 91       	pop	r18
    1112:	0f 90       	pop	r0
    1114:	0b be       	out	0x3b, r0	; 59
    1116:	0f 90       	pop	r0
    1118:	0f be       	out	0x3f, r0	; 63
    111a:	0f 90       	pop	r0
    111c:	1f 90       	pop	r1
    111e:	18 95       	reti

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
    1120:	01 96       	adiw	r24, 0x01	; 1
    1122:	90 93 af 02 	sts	0x02AF, r25
    1126:	80 93 ae 02 	sts	0x02AE, r24
    112a:	80 32       	cpi	r24, 0x20	; 32
    112c:	91 05       	cpc	r25, r1
    112e:	58 f3       	brcs	.-42     	; 0x1106 <__vector_36+0x66>
				rcv1_read_index = 0;
    1130:	10 92 af 02 	sts	0x02AF, r1
    1134:	10 92 ae 02 	sts	0x02AE, r1
    1138:	e6 cf       	rjmp	.-52     	; 0x1106 <__vector_36+0x66>

0000113a <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    113a:	0f 93       	push	r16
    113c:	1f 93       	push	r17
    113e:	cf 93       	push	r28
    1140:	df 93       	push	r29
    1142:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1144:	0e 94 39 10 	call	0x2072	; 0x2072 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    1148:	c0 91 b8 02 	lds	r28, 0x02B8
    114c:	d0 91 b9 02 	lds	r29, 0x02B9
    1150:	0c 0f       	add	r16, r28
    1152:	1d 1f       	adc	r17, r29
    1154:	87 e1       	ldi	r24, 0x17	; 23
    1156:	08 33       	cpi	r16, 0x38	; 56
    1158:	18 07       	cpc	r17, r24
    115a:	88 f4       	brcc	.+34     	; 0x117e <pvPortMalloc+0x44>
    115c:	c0 17       	cp	r28, r16
    115e:	d1 07       	cpc	r29, r17
    1160:	70 f4       	brcc	.+28     	; 0x117e <pvPortMalloc+0x44>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1162:	c6 54       	subi	r28, 0x46	; 70
    1164:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
    1166:	10 93 b9 02 	sts	0x02B9, r17
    116a:	00 93 b8 02 	sts	0x02B8, r16
		}	
	}
	xTaskResumeAll();
    116e:	0e 94 66 11 	call	0x22cc	; 0x22cc <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    1172:	ce 01       	movw	r24, r28
    1174:	df 91       	pop	r29
    1176:	cf 91       	pop	r28
    1178:	1f 91       	pop	r17
    117a:	0f 91       	pop	r16
    117c:	08 95       	ret
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    117e:	c0 e0       	ldi	r28, 0x00	; 0
    1180:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    1182:	0e 94 66 11 	call	0x22cc	; 0x22cc <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    1186:	ce 01       	movw	r24, r28
    1188:	df 91       	pop	r29
    118a:	cf 91       	pop	r28
    118c:	1f 91       	pop	r17
    118e:	0f 91       	pop	r16
    1190:	08 95       	ret

00001192 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    1192:	08 95       	ret

00001194 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1194:	10 92 b9 02 	sts	0x02B9, r1
    1198:	10 92 b8 02 	sts	0x02B8, r1
}
    119c:	08 95       	ret

0000119e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    119e:	88 e3       	ldi	r24, 0x38	; 56
    11a0:	97 e1       	ldi	r25, 0x17	; 23
    11a2:	20 91 b8 02 	lds	r18, 0x02B8
    11a6:	30 91 b9 02 	lds	r19, 0x02B9
    11aa:	82 1b       	sub	r24, r18
    11ac:	93 0b       	sbc	r25, r19
}
    11ae:	08 95       	ret

000011b0 <pxPortInitialiseStack>:
	// variable here which holds the address of the top of the stack. It will be
	// grabbed by the task's wrapper object just after xTaskCreate() is called so that
	// the task object knows where its stack is. The stack can then be dumped to a
	// serial port (as a hex printout) for debugging purposes. 
	#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
		portStackTopForTask = (size_t)pxTopOfStack;
    11b0:	90 93 55 1a 	sts	0x1A55, r25
    11b4:	80 93 54 1a 	sts	0x1A54, r24
	#endif

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    11b8:	21 e1       	ldi	r18, 0x11	; 17
    11ba:	fc 01       	movw	r30, r24
    11bc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    11be:	31 97       	sbiw	r30, 0x01	; 1
    11c0:	32 e2       	ldi	r19, 0x22	; 34
    11c2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    11c4:	fc 01       	movw	r30, r24
    11c6:	32 97       	sbiw	r30, 0x02	; 2
    11c8:	a3 e3       	ldi	r26, 0x33	; 51
    11ca:	a0 83       	st	Z, r26
	pxTopOfStack--;
#else
	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    11cc:	fc 01       	movw	r30, r24
    11ce:	33 97       	sbiw	r30, 0x03	; 3
    11d0:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    11d2:	fc 01       	movw	r30, r24
    11d4:	34 97       	sbiw	r30, 0x04	; 4
    11d6:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    11d8:	fc 01       	movw	r30, r24
    11da:	35 97       	sbiw	r30, 0x05	; 5
    11dc:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    11de:	fc 01       	movw	r30, r24
    11e0:	36 97       	sbiw	r30, 0x06	; 6
    11e2:	60 e8       	ldi	r22, 0x80	; 128
    11e4:	60 83       	st	Z, r22
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
	pxTopOfStack--;
#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    11e6:	fc 01       	movw	r30, r24
    11e8:	37 97       	sbiw	r30, 0x07	; 7
    11ea:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    11ec:	fc 01       	movw	r30, r24
    11ee:	38 97       	sbiw	r30, 0x08	; 8
    11f0:	62 e0       	ldi	r22, 0x02	; 2
    11f2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    11f4:	fc 01       	movw	r30, r24
    11f6:	39 97       	sbiw	r30, 0x09	; 9
    11f8:	63 e0       	ldi	r22, 0x03	; 3
    11fa:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    11fc:	fc 01       	movw	r30, r24
    11fe:	3a 97       	sbiw	r30, 0x0a	; 10
    1200:	64 e0       	ldi	r22, 0x04	; 4
    1202:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1204:	fc 01       	movw	r30, r24
    1206:	3b 97       	sbiw	r30, 0x0b	; 11
    1208:	65 e0       	ldi	r22, 0x05	; 5
    120a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    120c:	fc 01       	movw	r30, r24
    120e:	3c 97       	sbiw	r30, 0x0c	; 12
    1210:	66 e0       	ldi	r22, 0x06	; 6
    1212:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    1214:	fc 01       	movw	r30, r24
    1216:	3d 97       	sbiw	r30, 0x0d	; 13
    1218:	67 e0       	ldi	r22, 0x07	; 7
    121a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    121c:	fc 01       	movw	r30, r24
    121e:	3e 97       	sbiw	r30, 0x0e	; 14
    1220:	68 e0       	ldi	r22, 0x08	; 8
    1222:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1224:	fc 01       	movw	r30, r24
    1226:	3f 97       	sbiw	r30, 0x0f	; 15
    1228:	69 e0       	ldi	r22, 0x09	; 9
    122a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    122c:	fc 01       	movw	r30, r24
    122e:	70 97       	sbiw	r30, 0x10	; 16
    1230:	60 e1       	ldi	r22, 0x10	; 16
    1232:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1234:	fc 01       	movw	r30, r24
    1236:	71 97       	sbiw	r30, 0x11	; 17
    1238:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    123a:	fc 01       	movw	r30, r24
    123c:	72 97       	sbiw	r30, 0x12	; 18
    123e:	22 e1       	ldi	r18, 0x12	; 18
    1240:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1242:	fc 01       	movw	r30, r24
    1244:	73 97       	sbiw	r30, 0x13	; 19
    1246:	23 e1       	ldi	r18, 0x13	; 19
    1248:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    124a:	fc 01       	movw	r30, r24
    124c:	74 97       	sbiw	r30, 0x14	; 20
    124e:	24 e1       	ldi	r18, 0x14	; 20
    1250:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1252:	fc 01       	movw	r30, r24
    1254:	75 97       	sbiw	r30, 0x15	; 21
    1256:	25 e1       	ldi	r18, 0x15	; 21
    1258:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    125a:	fc 01       	movw	r30, r24
    125c:	76 97       	sbiw	r30, 0x16	; 22
    125e:	26 e1       	ldi	r18, 0x16	; 22
    1260:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1262:	fc 01       	movw	r30, r24
    1264:	77 97       	sbiw	r30, 0x17	; 23
    1266:	27 e1       	ldi	r18, 0x17	; 23
    1268:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    126a:	fc 01       	movw	r30, r24
    126c:	78 97       	sbiw	r30, 0x18	; 24
    126e:	28 e1       	ldi	r18, 0x18	; 24
    1270:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    1272:	fc 01       	movw	r30, r24
    1274:	79 97       	sbiw	r30, 0x19	; 25
    1276:	29 e1       	ldi	r18, 0x19	; 25
    1278:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    127a:	fc 01       	movw	r30, r24
    127c:	7a 97       	sbiw	r30, 0x1a	; 26
    127e:	20 e2       	ldi	r18, 0x20	; 32
    1280:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1282:	fc 01       	movw	r30, r24
    1284:	7b 97       	sbiw	r30, 0x1b	; 27
    1286:	21 e2       	ldi	r18, 0x21	; 33
    1288:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    128a:	fc 01       	movw	r30, r24
    128c:	7c 97       	sbiw	r30, 0x1c	; 28
    128e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1290:	fc 01       	movw	r30, r24
    1292:	7d 97       	sbiw	r30, 0x1d	; 29
    1294:	23 e2       	ldi	r18, 0x23	; 35
    1296:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1298:	fc 01       	movw	r30, r24
    129a:	7e 97       	sbiw	r30, 0x1e	; 30
    129c:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    129e:	fc 01       	movw	r30, r24
    12a0:	7f 97       	sbiw	r30, 0x1f	; 31
    12a2:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    12a4:	fc 01       	movw	r30, r24
    12a6:	b0 97       	sbiw	r30, 0x20	; 32
    12a8:	26 e2       	ldi	r18, 0x26	; 38
    12aa:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    12ac:	fc 01       	movw	r30, r24
    12ae:	b1 97       	sbiw	r30, 0x21	; 33
    12b0:	27 e2       	ldi	r18, 0x27	; 39
    12b2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    12b4:	fc 01       	movw	r30, r24
    12b6:	b2 97       	sbiw	r30, 0x22	; 34
    12b8:	28 e2       	ldi	r18, 0x28	; 40
    12ba:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    12bc:	fc 01       	movw	r30, r24
    12be:	b3 97       	sbiw	r30, 0x23	; 35
    12c0:	29 e2       	ldi	r18, 0x29	; 41
    12c2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    12c4:	fc 01       	movw	r30, r24
    12c6:	b4 97       	sbiw	r30, 0x24	; 36
    12c8:	20 e3       	ldi	r18, 0x30	; 48
    12ca:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    12cc:	fc 01       	movw	r30, r24
    12ce:	b5 97       	sbiw	r30, 0x25	; 37
    12d0:	21 e3       	ldi	r18, 0x31	; 49
    12d2:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    12d4:	86 97       	sbiw	r24, 0x26	; 38
}
    12d6:	08 95       	ret

000012d8 <xPortStartScheduler>:

	// Use the highest numbered timer available on a given AVR processor, because the
	// lower numbered timers are hooked up to useful things such as PWM's
	#if (defined TIMER5_COMPA_vect)             // Use Timer 5 on ATmega1280/1281
		#define RT_VECT TIMER5_COMPA_vect
		OCR5AH = compare_match.byte[1];         // Set high byte of compare match
    12d8:	87 e0       	ldi	r24, 0x07	; 7
    12da:	80 93 29 01 	sts	0x0129, r24
		OCR5AL = compare_match.byte[0];         // register, then low byte
    12de:	8f ec       	ldi	r24, 0xCF	; 207
    12e0:	80 93 28 01 	sts	0x0128, r24
		TCCR5B = (1 << CS51) | (1 << WGM52);    // Prescale F_CPU / 8, clear on match
    12e4:	8a e0       	ldi	r24, 0x0A	; 10
    12e6:	80 93 21 01 	sts	0x0121, r24
		TIMSK5 |= (1 << OCIE5A);                // Enable the timer interrupt
    12ea:	e3 e7       	ldi	r30, 0x73	; 115
    12ec:	f0 e0       	ldi	r31, 0x00	; 0
    12ee:	80 81       	ld	r24, Z
    12f0:	82 60       	ori	r24, 0x02	; 2
    12f2:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    12f4:	a0 91 f2 19 	lds	r26, 0x19F2
    12f8:	b0 91 f3 19 	lds	r27, 0x19F3
    12fc:	cd 91       	ld	r28, X+
    12fe:	cd bf       	out	0x3d, r28	; 61
    1300:	dd 91       	ld	r29, X+
    1302:	de bf       	out	0x3e, r29	; 62
    1304:	ff 91       	pop	r31
    1306:	ef 91       	pop	r30
    1308:	df 91       	pop	r29
    130a:	cf 91       	pop	r28
    130c:	bf 91       	pop	r27
    130e:	af 91       	pop	r26
    1310:	9f 91       	pop	r25
    1312:	8f 91       	pop	r24
    1314:	7f 91       	pop	r23
    1316:	6f 91       	pop	r22
    1318:	5f 91       	pop	r21
    131a:	4f 91       	pop	r20
    131c:	3f 91       	pop	r19
    131e:	2f 91       	pop	r18
    1320:	1f 91       	pop	r17
    1322:	0f 91       	pop	r16
    1324:	ff 90       	pop	r15
    1326:	ef 90       	pop	r14
    1328:	df 90       	pop	r13
    132a:	cf 90       	pop	r12
    132c:	bf 90       	pop	r11
    132e:	af 90       	pop	r10
    1330:	9f 90       	pop	r9
    1332:	8f 90       	pop	r8
    1334:	7f 90       	pop	r7
    1336:	6f 90       	pop	r6
    1338:	5f 90       	pop	r5
    133a:	4f 90       	pop	r4
    133c:	3f 90       	pop	r3
    133e:	2f 90       	pop	r2
    1340:	1f 90       	pop	r1
    1342:	0f 90       	pop	r0
    1344:	0f be       	out	0x3f, r0	; 63
    1346:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1348:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    134a:	81 e0       	ldi	r24, 0x01	; 1
    134c:	08 95       	ret

0000134e <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    134e:	08 95       	ret

00001350 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1350:	0f 92       	push	r0
    1352:	0f b6       	in	r0, 0x3f	; 63
    1354:	f8 94       	cli
    1356:	0f 92       	push	r0
    1358:	1f 92       	push	r1
    135a:	11 24       	eor	r1, r1
    135c:	2f 92       	push	r2
    135e:	3f 92       	push	r3
    1360:	4f 92       	push	r4
    1362:	5f 92       	push	r5
    1364:	6f 92       	push	r6
    1366:	7f 92       	push	r7
    1368:	8f 92       	push	r8
    136a:	9f 92       	push	r9
    136c:	af 92       	push	r10
    136e:	bf 92       	push	r11
    1370:	cf 92       	push	r12
    1372:	df 92       	push	r13
    1374:	ef 92       	push	r14
    1376:	ff 92       	push	r15
    1378:	0f 93       	push	r16
    137a:	1f 93       	push	r17
    137c:	2f 93       	push	r18
    137e:	3f 93       	push	r19
    1380:	4f 93       	push	r20
    1382:	5f 93       	push	r21
    1384:	6f 93       	push	r22
    1386:	7f 93       	push	r23
    1388:	8f 93       	push	r24
    138a:	9f 93       	push	r25
    138c:	af 93       	push	r26
    138e:	bf 93       	push	r27
    1390:	cf 93       	push	r28
    1392:	df 93       	push	r29
    1394:	ef 93       	push	r30
    1396:	ff 93       	push	r31
    1398:	a0 91 f2 19 	lds	r26, 0x19F2
    139c:	b0 91 f3 19 	lds	r27, 0x19F3
    13a0:	0d b6       	in	r0, 0x3d	; 61
    13a2:	0d 92       	st	X+, r0
    13a4:	0e b6       	in	r0, 0x3e	; 62
    13a6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    13a8:	0e 94 80 12 	call	0x2500	; 0x2500 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    13ac:	a0 91 f2 19 	lds	r26, 0x19F2
    13b0:	b0 91 f3 19 	lds	r27, 0x19F3
    13b4:	cd 91       	ld	r28, X+
    13b6:	cd bf       	out	0x3d, r28	; 61
    13b8:	dd 91       	ld	r29, X+
    13ba:	de bf       	out	0x3e, r29	; 62
    13bc:	ff 91       	pop	r31
    13be:	ef 91       	pop	r30
    13c0:	df 91       	pop	r29
    13c2:	cf 91       	pop	r28
    13c4:	bf 91       	pop	r27
    13c6:	af 91       	pop	r26
    13c8:	9f 91       	pop	r25
    13ca:	8f 91       	pop	r24
    13cc:	7f 91       	pop	r23
    13ce:	6f 91       	pop	r22
    13d0:	5f 91       	pop	r21
    13d2:	4f 91       	pop	r20
    13d4:	3f 91       	pop	r19
    13d6:	2f 91       	pop	r18
    13d8:	1f 91       	pop	r17
    13da:	0f 91       	pop	r16
    13dc:	ff 90       	pop	r15
    13de:	ef 90       	pop	r14
    13e0:	df 90       	pop	r13
    13e2:	cf 90       	pop	r12
    13e4:	bf 90       	pop	r11
    13e6:	af 90       	pop	r10
    13e8:	9f 90       	pop	r9
    13ea:	8f 90       	pop	r8
    13ec:	7f 90       	pop	r7
    13ee:	6f 90       	pop	r6
    13f0:	5f 90       	pop	r5
    13f2:	4f 90       	pop	r4
    13f4:	3f 90       	pop	r3
    13f6:	2f 90       	pop	r2
    13f8:	1f 90       	pop	r1
    13fa:	0f 90       	pop	r0
    13fc:	0f be       	out	0x3f, r0	; 63
    13fe:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1400:	08 95       	ret

00001402 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1402:	0f 92       	push	r0
    1404:	0f b6       	in	r0, 0x3f	; 63
    1406:	f8 94       	cli
    1408:	0f 92       	push	r0
    140a:	1f 92       	push	r1
    140c:	11 24       	eor	r1, r1
    140e:	2f 92       	push	r2
    1410:	3f 92       	push	r3
    1412:	4f 92       	push	r4
    1414:	5f 92       	push	r5
    1416:	6f 92       	push	r6
    1418:	7f 92       	push	r7
    141a:	8f 92       	push	r8
    141c:	9f 92       	push	r9
    141e:	af 92       	push	r10
    1420:	bf 92       	push	r11
    1422:	cf 92       	push	r12
    1424:	df 92       	push	r13
    1426:	ef 92       	push	r14
    1428:	ff 92       	push	r15
    142a:	0f 93       	push	r16
    142c:	1f 93       	push	r17
    142e:	2f 93       	push	r18
    1430:	3f 93       	push	r19
    1432:	4f 93       	push	r20
    1434:	5f 93       	push	r21
    1436:	6f 93       	push	r22
    1438:	7f 93       	push	r23
    143a:	8f 93       	push	r24
    143c:	9f 93       	push	r25
    143e:	af 93       	push	r26
    1440:	bf 93       	push	r27
    1442:	cf 93       	push	r28
    1444:	df 93       	push	r29
    1446:	ef 93       	push	r30
    1448:	ff 93       	push	r31
    144a:	a0 91 f2 19 	lds	r26, 0x19F2
    144e:	b0 91 f3 19 	lds	r27, 0x19F3
    1452:	0d b6       	in	r0, 0x3d	; 61
    1454:	0d 92       	st	X+, r0
    1456:	0e b6       	in	r0, 0x3e	; 62
    1458:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    145a:	0e 94 74 10 	call	0x20e8	; 0x20e8 <vTaskIncrementTick>
	vTaskSwitchContext();
    145e:	0e 94 80 12 	call	0x2500	; 0x2500 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1462:	a0 91 f2 19 	lds	r26, 0x19F2
    1466:	b0 91 f3 19 	lds	r27, 0x19F3
    146a:	cd 91       	ld	r28, X+
    146c:	cd bf       	out	0x3d, r28	; 61
    146e:	dd 91       	ld	r29, X+
    1470:	de bf       	out	0x3e, r29	; 62
    1472:	ff 91       	pop	r31
    1474:	ef 91       	pop	r30
    1476:	df 91       	pop	r29
    1478:	cf 91       	pop	r28
    147a:	bf 91       	pop	r27
    147c:	af 91       	pop	r26
    147e:	9f 91       	pop	r25
    1480:	8f 91       	pop	r24
    1482:	7f 91       	pop	r23
    1484:	6f 91       	pop	r22
    1486:	5f 91       	pop	r21
    1488:	4f 91       	pop	r20
    148a:	3f 91       	pop	r19
    148c:	2f 91       	pop	r18
    148e:	1f 91       	pop	r17
    1490:	0f 91       	pop	r16
    1492:	ff 90       	pop	r15
    1494:	ef 90       	pop	r14
    1496:	df 90       	pop	r13
    1498:	cf 90       	pop	r12
    149a:	bf 90       	pop	r11
    149c:	af 90       	pop	r10
    149e:	9f 90       	pop	r9
    14a0:	8f 90       	pop	r8
    14a2:	7f 90       	pop	r7
    14a4:	6f 90       	pop	r6
    14a6:	5f 90       	pop	r5
    14a8:	4f 90       	pop	r4
    14aa:	3f 90       	pop	r3
    14ac:	2f 90       	pop	r2
    14ae:	1f 90       	pop	r1
    14b0:	0f 90       	pop	r0
    14b2:	0f be       	out	0x3f, r0	; 63
    14b4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    14b6:	08 95       	ret

000014b8 <__vector_47>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    14b8:	0e 94 01 0a 	call	0x1402	; 0x1402 <vPortYieldFromTick>
		asm volatile ( "reti" );
    14bc:	18 95       	reti

000014be <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    14be:	cf 93       	push	r28
    14c0:	df 93       	push	r29
    14c2:	fc 01       	movw	r30, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    14c4:	a0 81       	ld	r26, Z
    14c6:	b1 81       	ldd	r27, Z+1	; 0x01
    14c8:	10 97       	sbiw	r26, 0x00	; 0
    14ca:	89 f0       	breq	.+34     	; 0x14ee <prvCopyDataFromQueue+0x30>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    14cc:	40 a1       	lds	r20, 0x40
    14ce:	26 81       	ldd	r18, Z+6	; 0x06
    14d0:	37 81       	ldd	r19, Z+7	; 0x07
    14d2:	24 0f       	add	r18, r20
    14d4:	31 1d       	adc	r19, r1
    14d6:	37 83       	std	Z+7, r19	; 0x07
    14d8:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    14da:	c2 81       	ldd	r28, Z+2	; 0x02
    14dc:	d3 81       	ldd	r29, Z+3	; 0x03
    14de:	2c 17       	cp	r18, r28
    14e0:	3d 07       	cpc	r19, r29
    14e2:	40 f4       	brcc	.+16     	; 0x14f4 <prvCopyDataFromQueue+0x36>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    14e4:	cb 01       	movw	r24, r22
    14e6:	b9 01       	movw	r22, r18
    14e8:	50 e0       	ldi	r21, 0x00	; 0
    14ea:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <memcpy>
	}
}
    14ee:	df 91       	pop	r29
    14f0:	cf 91       	pop	r28
    14f2:	08 95       	ret
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    14f4:	b7 83       	std	Z+7, r27	; 0x07
    14f6:	a6 83       	std	Z+6, r26	; 0x06
    14f8:	9d 01       	movw	r18, r26
    14fa:	f4 cf       	rjmp	.-24     	; 0x14e4 <prvCopyDataFromQueue+0x26>

000014fc <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    14fc:	0f 93       	push	r16
    14fe:	1f 93       	push	r17
    1500:	cf 93       	push	r28
    1502:	df 93       	push	r29
    1504:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1506:	0f b6       	in	r0, 0x3f	; 63
    1508:	f8 94       	cli
    150a:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    150c:	8a a1       	lds	r24, 0x4a
    150e:	18 16       	cp	r1, r24
    1510:	dc f4       	brge	.+54     	; 0x1548 <prvUnlockQueue+0x4c>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1512:	8b 89       	ldd	r24, Y+19	; 0x13
    1514:	88 23       	and	r24, r24
    1516:	c1 f0       	breq	.+48     	; 0x1548 <prvUnlockQueue+0x4c>
    1518:	8e 01       	movw	r16, r28
    151a:	0d 5e       	subi	r16, 0xED	; 237
    151c:	1f 4f       	sbci	r17, 0xFF	; 255
    151e:	08 c0       	rjmp	.+16     	; 0x1530 <prvUnlockQueue+0x34>
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
				}

				--( pxQueue->xTxLock );
    1520:	8a a1       	lds	r24, 0x4a
    1522:	81 50       	subi	r24, 0x01	; 1
    1524:	8a a3       	lds	r24, 0x5a
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1526:	18 16       	cp	r1, r24
    1528:	7c f4       	brge	.+30     	; 0x1548 <prvUnlockQueue+0x4c>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    152a:	8b 89       	ldd	r24, Y+19	; 0x13
    152c:	88 23       	and	r24, r24
    152e:	61 f0       	breq	.+24     	; 0x1548 <prvUnlockQueue+0x4c>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1530:	c8 01       	movw	r24, r16
    1532:	0e 94 fe 12 	call	0x25fc	; 0x25fc <xTaskRemoveFromEventList>
    1536:	88 23       	and	r24, r24
    1538:	99 f3       	breq	.-26     	; 0x1520 <prvUnlockQueue+0x24>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    153a:	0e 94 c4 13 	call	0x2788	; 0x2788 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    153e:	8a a1       	lds	r24, 0x4a
    1540:	81 50       	subi	r24, 0x01	; 1
    1542:	8a a3       	lds	r24, 0x5a
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1544:	18 16       	cp	r1, r24
    1546:	8c f3       	brlt	.-30     	; 0x152a <prvUnlockQueue+0x2e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1548:	8f ef       	ldi	r24, 0xFF	; 255
    154a:	8a a3       	lds	r24, 0x5a
	}
	taskEXIT_CRITICAL();
    154c:	0f 90       	pop	r0
    154e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1550:	0f b6       	in	r0, 0x3f	; 63
    1552:	f8 94       	cli
    1554:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1556:	89 a1       	lds	r24, 0x49
    1558:	18 16       	cp	r1, r24
    155a:	dc f4       	brge	.+54     	; 0x1592 <prvUnlockQueue+0x96>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    155c:	88 85       	ldd	r24, Y+8	; 0x08
    155e:	88 23       	and	r24, r24
    1560:	c1 f0       	breq	.+48     	; 0x1592 <prvUnlockQueue+0x96>
    1562:	8e 01       	movw	r16, r28
    1564:	08 5f       	subi	r16, 0xF8	; 248
    1566:	1f 4f       	sbci	r17, 0xFF	; 255
    1568:	08 c0       	rjmp	.+16     	; 0x157a <prvUnlockQueue+0x7e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					vTaskMissedYield();
				}

				--( pxQueue->xRxLock );
    156a:	89 a1       	lds	r24, 0x49
    156c:	81 50       	subi	r24, 0x01	; 1
    156e:	89 a3       	lds	r24, 0x59
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1570:	18 16       	cp	r1, r24
    1572:	7c f4       	brge	.+30     	; 0x1592 <prvUnlockQueue+0x96>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1574:	88 85       	ldd	r24, Y+8	; 0x08
    1576:	88 23       	and	r24, r24
    1578:	61 f0       	breq	.+24     	; 0x1592 <prvUnlockQueue+0x96>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    157a:	c8 01       	movw	r24, r16
    157c:	0e 94 fe 12 	call	0x25fc	; 0x25fc <xTaskRemoveFromEventList>
    1580:	88 23       	and	r24, r24
    1582:	99 f3       	breq	.-26     	; 0x156a <prvUnlockQueue+0x6e>
				{
					vTaskMissedYield();
    1584:	0e 94 c4 13 	call	0x2788	; 0x2788 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1588:	89 a1       	lds	r24, 0x49
    158a:	81 50       	subi	r24, 0x01	; 1
    158c:	89 a3       	lds	r24, 0x59
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    158e:	18 16       	cp	r1, r24
    1590:	8c f3       	brlt	.-30     	; 0x1574 <prvUnlockQueue+0x78>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1592:	8f ef       	ldi	r24, 0xFF	; 255
    1594:	89 a3       	lds	r24, 0x59
	}
	taskEXIT_CRITICAL();
    1596:	0f 90       	pop	r0
    1598:	0f be       	out	0x3f, r0	; 63
}
    159a:	df 91       	pop	r29
    159c:	cf 91       	pop	r28
    159e:	1f 91       	pop	r17
    15a0:	0f 91       	pop	r16
    15a2:	08 95       	ret

000015a4 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    15a4:	cf 93       	push	r28
    15a6:	df 93       	push	r29
    15a8:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    15aa:	28 a1       	lds	r18, 0x48
    15ac:	22 23       	and	r18, r18
    15ae:	59 f4       	brne	.+22     	; 0x15c6 <prvCopyDataToQueue+0x22>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    15b0:	88 81       	ld	r24, Y
    15b2:	99 81       	ldd	r25, Y+1	; 0x01
    15b4:	00 97       	sbiw	r24, 0x00	; 0
    15b6:	09 f4       	brne	.+2      	; 0x15ba <prvCopyDataToQueue+0x16>
    15b8:	46 c0       	rjmp	.+140    	; 0x1646 <prvCopyDataToQueue+0xa2>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
    15ba:	8e 8d       	ldd	r24, Y+30	; 0x1e
    15bc:	8f 5f       	subi	r24, 0xFF	; 255
    15be:	8e 8f       	std	Y+30, r24	; 0x1e
}
    15c0:	df 91       	pop	r29
    15c2:	cf 91       	pop	r28
    15c4:	08 95       	ret
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    15c6:	44 23       	and	r20, r20
    15c8:	e1 f4       	brne	.+56     	; 0x1602 <prvCopyDataToQueue+0x5e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    15ca:	8c 81       	ldd	r24, Y+4	; 0x04
    15cc:	9d 81       	ldd	r25, Y+5	; 0x05
    15ce:	42 2f       	mov	r20, r18
    15d0:	50 e0       	ldi	r21, 0x00	; 0
    15d2:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    15d6:	28 a1       	lds	r18, 0x48
    15d8:	8c 81       	ldd	r24, Y+4	; 0x04
    15da:	9d 81       	ldd	r25, Y+5	; 0x05
    15dc:	82 0f       	add	r24, r18
    15de:	91 1d       	adc	r25, r1
    15e0:	9d 83       	std	Y+5, r25	; 0x05
    15e2:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    15e4:	2a 81       	ldd	r18, Y+2	; 0x02
    15e6:	3b 81       	ldd	r19, Y+3	; 0x03
    15e8:	82 17       	cp	r24, r18
    15ea:	93 07       	cpc	r25, r19
    15ec:	30 f3       	brcs	.-52     	; 0x15ba <prvCopyDataToQueue+0x16>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    15ee:	88 81       	ld	r24, Y
    15f0:	99 81       	ldd	r25, Y+1	; 0x01
    15f2:	9d 83       	std	Y+5, r25	; 0x05
    15f4:	8c 83       	std	Y+4, r24	; 0x04
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
    15f6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    15f8:	8f 5f       	subi	r24, 0xFF	; 255
    15fa:	8e 8f       	std	Y+30, r24	; 0x1e
}
    15fc:	df 91       	pop	r29
    15fe:	cf 91       	pop	r28
    1600:	08 95       	ret
			pxQueue->pcWriteTo = pxQueue->pcHead;
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1602:	8e 81       	ldd	r24, Y+6	; 0x06
    1604:	9f 81       	ldd	r25, Y+7	; 0x07
    1606:	42 2f       	mov	r20, r18
    1608:	50 e0       	ldi	r21, 0x00	; 0
    160a:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    160e:	48 a1       	lds	r20, 0x48
    1610:	50 e0       	ldi	r21, 0x00	; 0
    1612:	50 95       	com	r21
    1614:	41 95       	neg	r20
    1616:	5f 4f       	sbci	r21, 0xFF	; 255
    1618:	8e 81       	ldd	r24, Y+6	; 0x06
    161a:	9f 81       	ldd	r25, Y+7	; 0x07
    161c:	84 0f       	add	r24, r20
    161e:	95 1f       	adc	r25, r21
    1620:	9f 83       	std	Y+7, r25	; 0x07
    1622:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1624:	28 81       	ld	r18, Y
    1626:	39 81       	ldd	r19, Y+1	; 0x01
    1628:	82 17       	cp	r24, r18
    162a:	93 07       	cpc	r25, r19
    162c:	30 f6       	brcc	.-116    	; 0x15ba <prvCopyDataToQueue+0x16>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    162e:	8a 81       	ldd	r24, Y+2	; 0x02
    1630:	9b 81       	ldd	r25, Y+3	; 0x03
    1632:	84 0f       	add	r24, r20
    1634:	95 1f       	adc	r25, r21
    1636:	9f 83       	std	Y+7, r25	; 0x07
    1638:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    163a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    163c:	8f 5f       	subi	r24, 0xFF	; 255
    163e:	8e 8f       	std	Y+30, r24	; 0x1e
}
    1640:	df 91       	pop	r29
    1642:	cf 91       	pop	r28
    1644:	08 95       	ret
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1646:	8a 81       	ldd	r24, Y+2	; 0x02
    1648:	9b 81       	ldd	r25, Y+3	; 0x03
    164a:	0e 94 4b 14 	call	0x2896	; 0x2896 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    164e:	1b 82       	std	Y+3, r1	; 0x03
    1650:	1a 82       	std	Y+2, r1	; 0x02
    1652:	b3 cf       	rjmp	.-154    	; 0x15ba <prvCopyDataToQueue+0x16>

00001654 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    1654:	cf 93       	push	r28
    1656:	df 93       	push	r29
    1658:	ec 01       	movw	r28, r24

	configASSERT( pxQueue );

	/* If the queue being reset has already been used (has not just been
	created), then only reset the queue if its event lists are empty. */
	if( xNewQueue != pdTRUE )
    165a:	61 30       	cpi	r22, 0x01	; 1
    165c:	51 f0       	breq	.+20     	; 0x1672 <xQueueGenericReset+0x1e>
	{
		if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    165e:	9b 89       	ldd	r25, Y+19	; 0x13
		{
			xReturn = pdFAIL;
		}

		if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1660:	88 85       	ldd	r24, Y+8	; 0x08
    1662:	88 23       	and	r24, r24
    1664:	21 f0       	breq	.+8      	; 0x166e <xQueueGenericReset+0x1a>
		{
			xReturn = pdFAIL;
		}
	}

	if( xReturn == pdPASS )
    1666:	80 e0       	ldi	r24, 0x00	; 0
		vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
		vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
	}

	return xReturn;
}
    1668:	df 91       	pop	r29
    166a:	cf 91       	pop	r28
    166c:	08 95       	ret
		{
			xReturn = pdFAIL;
		}
	}

	if( xReturn == pdPASS )
    166e:	99 23       	and	r25, r25
    1670:	d1 f7       	brne	.-12     	; 0x1666 <xQueueGenericReset+0x12>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1672:	48 81       	ld	r20, Y
    1674:	59 81       	ldd	r21, Y+1	; 0x01
    1676:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1678:	68 a1       	lds	r22, 0x48
    167a:	86 9f       	mul	r24, r22
    167c:	90 01       	movw	r18, r0
    167e:	11 24       	eor	r1, r1
    1680:	24 0f       	add	r18, r20
    1682:	35 1f       	adc	r19, r21
    1684:	3b 83       	std	Y+3, r19	; 0x03
    1686:	2a 83       	std	Y+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1688:	1e 8e       	std	Y+30, r1	; 0x1e
		pxQueue->pcWriteTo = pxQueue->pcHead;
    168a:	5d 83       	std	Y+5, r21	; 0x05
    168c:	4c 83       	std	Y+4, r20	; 0x04
		}
	}

	if( xReturn == pdPASS )
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    168e:	70 e0       	ldi	r23, 0x00	; 0
    1690:	90 e0       	ldi	r25, 0x00	; 0
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    1692:	01 97       	sbiw	r24, 0x01	; 1
    1694:	68 9f       	mul	r22, r24
    1696:	90 01       	movw	r18, r0
    1698:	69 9f       	mul	r22, r25
    169a:	30 0d       	add	r19, r0
    169c:	78 9f       	mul	r23, r24
    169e:	30 0d       	add	r19, r0
    16a0:	11 24       	eor	r1, r1
    16a2:	24 0f       	add	r18, r20
    16a4:	35 1f       	adc	r19, r21
    16a6:	3f 83       	std	Y+7, r19	; 0x07
    16a8:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    16aa:	8f ef       	ldi	r24, 0xFF	; 255
    16ac:	89 a3       	lds	r24, 0x59
		pxQueue->xTxLock = queueUNLOCKED;
    16ae:	8a a3       	lds	r24, 0x5a

		/* Ensure the event queues start with the correct state. */
		vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    16b0:	ce 01       	movw	r24, r28
    16b2:	08 96       	adiw	r24, 0x08	; 8
    16b4:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vListInitialise>
		vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    16b8:	ce 01       	movw	r24, r28
    16ba:	43 96       	adiw	r24, 0x13	; 19
    16bc:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vListInitialise>
    16c0:	81 e0       	ldi	r24, 0x01	; 1
	}

	return xReturn;
}
    16c2:	df 91       	pop	r29
    16c4:	cf 91       	pop	r28
    16c6:	08 95       	ret

000016c8 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    16c8:	0f 93       	push	r16
    16ca:	1f 93       	push	r17
    16cc:	cf 93       	push	r28
    16ce:	df 93       	push	r29
    16d0:	18 2f       	mov	r17, r24
    16d2:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    16d4:	88 23       	and	r24, r24
    16d6:	f1 f0       	breq	.+60     	; 0x1714 <xQueueGenericCreate+0x4c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    16d8:	83 e2       	ldi	r24, 0x23	; 35
    16da:	90 e0       	ldi	r25, 0x00	; 0
    16dc:	0e 94 9d 08 	call	0x113a	; 0x113a <pvPortMalloc>
    16e0:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    16e2:	00 97       	sbiw	r24, 0x00	; 0
    16e4:	b9 f0       	breq	.+46     	; 0x1714 <xQueueGenericCreate+0x4c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    16e6:	10 9f       	mul	r17, r16
    16e8:	90 01       	movw	r18, r0
    16ea:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    16ec:	c9 01       	movw	r24, r18
    16ee:	01 96       	adiw	r24, 0x01	; 1
    16f0:	0e 94 9d 08 	call	0x113a	; 0x113a <pvPortMalloc>
    16f4:	99 83       	std	Y+1, r25	; 0x01
    16f6:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    16f8:	00 97       	sbiw	r24, 0x00	; 0
    16fa:	99 f0       	breq	.+38     	; 0x1722 <xQueueGenericCreate+0x5a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    16fc:	1f 8f       	std	Y+31, r17	; 0x1f
				pxNewQueue->uxItemSize = uxItemSize;
    16fe:	08 a3       	lds	r16, 0x58
				xQueueGenericReset( pxNewQueue, pdTRUE );
    1700:	ce 01       	movw	r24, r28
    1702:	61 e0       	ldi	r22, 0x01	; 1
    1704:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xQueueGenericReset>
    1708:	ce 01       	movw	r24, r28
	}

	configASSERT( xReturn );

	return xReturn;
}
    170a:	df 91       	pop	r29
    170c:	cf 91       	pop	r28
    170e:	1f 91       	pop	r17
    1710:	0f 91       	pop	r16
    1712:	08 95       	ret

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1714:	80 e0       	ldi	r24, 0x00	; 0
    1716:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    1718:	df 91       	pop	r29
    171a:	cf 91       	pop	r28
    171c:	1f 91       	pop	r17
    171e:	0f 91       	pop	r16
    1720:	08 95       	ret
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1722:	ce 01       	movw	r24, r28
    1724:	0e 94 c9 08 	call	0x1192	; 0x1192 <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1728:	80 e0       	ldi	r24, 0x00	; 0
    172a:	90 e0       	ldi	r25, 0x00	; 0
    172c:	ee cf       	rjmp	.-36     	; 0x170a <xQueueGenericCreate+0x42>

0000172e <xQueueGetMutexHolder>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void* xQueueGetMutexHolder( xQueueHandle xSemaphore )
	{
    172e:	fc 01       	movw	r30, r24
		/* This function is called by xSemaphoreGetMutexHolder(), and should not
		be called directly.  Note:  This is is a good way of determining if the
		calling task is the mutex holder, but not a good way of determining the
		identity of the mutex holder, as the holder may change between the 
		following critical section exiting and the function returning. */
		taskENTER_CRITICAL();
    1730:	0f b6       	in	r0, 0x3f	; 63
    1732:	f8 94       	cli
    1734:	0f 92       	push	r0
		{
			if( xSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
    1736:	80 81       	ld	r24, Z
    1738:	91 81       	ldd	r25, Z+1	; 0x01
    173a:	00 97       	sbiw	r24, 0x00	; 0
    173c:	29 f4       	brne	.+10     	; 0x1748 <xQueueGetMutexHolder+0x1a>
			{
				pxReturn = ( void * ) xSemaphore->pxMutexHolder;
    173e:	82 81       	ldd	r24, Z+2	; 0x02
    1740:	93 81       	ldd	r25, Z+3	; 0x03
			else
			{
				pxReturn = NULL;
			}
		}
		taskEXIT_CRITICAL();
    1742:	0f 90       	pop	r0
    1744:	0f be       	out	0x3f, r0	; 63
		
		return pxReturn;
	}
    1746:	08 95       	ret
			{
				pxReturn = ( void * ) xSemaphore->pxMutexHolder;
			}
			else
			{
				pxReturn = NULL;
    1748:	80 e0       	ldi	r24, 0x00	; 0
    174a:	90 e0       	ldi	r25, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    174c:	0f 90       	pop	r0
    174e:	0f be       	out	0x3f, r0	; 63
		
		return pxReturn;
	}
    1750:	08 95       	ret

00001752 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1752:	af 92       	push	r10
    1754:	bf 92       	push	r11
    1756:	cf 92       	push	r12
    1758:	df 92       	push	r13
    175a:	ef 92       	push	r14
    175c:	ff 92       	push	r15
    175e:	0f 93       	push	r16
    1760:	cf 93       	push	r28
    1762:	df 93       	push	r29
    1764:	cd b7       	in	r28, 0x3d	; 61
    1766:	de b7       	in	r29, 0x3e	; 62
    1768:	29 97       	sbiw	r28, 0x09	; 9
    176a:	0f b6       	in	r0, 0x3f	; 63
    176c:	f8 94       	cli
    176e:	de bf       	out	0x3e, r29	; 62
    1770:	0f be       	out	0x3f, r0	; 63
    1772:	cd bf       	out	0x3d, r28	; 61
    1774:	7c 01       	movw	r14, r24
    1776:	5b 01       	movw	r10, r22
    1778:	2e 83       	std	Y+6, r18	; 0x06
    177a:	3f 83       	std	Y+7, r19	; 0x07
    177c:	48 87       	std	Y+8, r20	; 0x08
    177e:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1780:	20 e0       	ldi	r18, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1782:	e8 e0       	ldi	r30, 0x08	; 8
    1784:	ce 2e       	mov	r12, r30
    1786:	d1 2c       	mov	r13, r1
    1788:	c8 0e       	add	r12, r24
    178a:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    178c:	0f b6       	in	r0, 0x3f	; 63
    178e:	f8 94       	cli
    1790:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1792:	f7 01       	movw	r30, r14
    1794:	96 8d       	ldd	r25, Z+30	; 0x1e
    1796:	87 8d       	ldd	r24, Z+31	; 0x1f
    1798:	98 17       	cp	r25, r24
    179a:	08 f4       	brcc	.+2      	; 0x179e <xQueueGenericSend+0x4c>
    179c:	56 c0       	rjmp	.+172    	; 0x184a <xQueueGenericSend+0xf8>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    179e:	8e 81       	ldd	r24, Y+6	; 0x06
    17a0:	9f 81       	ldd	r25, Y+7	; 0x07
    17a2:	a8 85       	ldd	r26, Y+8	; 0x08
    17a4:	b9 85       	ldd	r27, Y+9	; 0x09
    17a6:	00 97       	sbiw	r24, 0x00	; 0
    17a8:	a1 05       	cpc	r26, r1
    17aa:	b1 05       	cpc	r27, r1
    17ac:	09 f4       	brne	.+2      	; 0x17b0 <xQueueGenericSend+0x5e>
    17ae:	69 c0       	rjmp	.+210    	; 0x1882 <xQueueGenericSend+0x130>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    17b0:	22 23       	and	r18, r18
    17b2:	69 f1       	breq	.+90     	; 0x180e <xQueueGenericSend+0xbc>
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    17b4:	0f 90       	pop	r0
    17b6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    17b8:	0e 94 39 10 	call	0x2072	; 0x2072 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    17bc:	0f b6       	in	r0, 0x3f	; 63
    17be:	f8 94       	cli
    17c0:	0f 92       	push	r0
    17c2:	f7 01       	movw	r30, r14
    17c4:	81 a1       	lds	r24, 0x41
    17c6:	8f 3f       	cpi	r24, 0xFF	; 255
    17c8:	39 f1       	breq	.+78     	; 0x1818 <xQueueGenericSend+0xc6>
    17ca:	f7 01       	movw	r30, r14
    17cc:	82 a1       	lds	r24, 0x42
    17ce:	8f 3f       	cpi	r24, 0xFF	; 255
    17d0:	41 f1       	breq	.+80     	; 0x1822 <xQueueGenericSend+0xd0>
    17d2:	0f 90       	pop	r0
    17d4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    17d6:	ce 01       	movw	r24, r28
    17d8:	01 96       	adiw	r24, 0x01	; 1
    17da:	be 01       	movw	r22, r28
    17dc:	6a 5f       	subi	r22, 0xFA	; 250
    17de:	7f 4f       	sbci	r23, 0xFF	; 255
    17e0:	0e 94 5d 13 	call	0x26ba	; 0x26ba <xTaskCheckForTimeOut>
    17e4:	88 23       	and	r24, r24
    17e6:	09 f0       	breq	.+2      	; 0x17ea <xQueueGenericSend+0x98>
    17e8:	50 c0       	rjmp	.+160    	; 0x188a <xQueueGenericSend+0x138>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    17ea:	0f b6       	in	r0, 0x3f	; 63
    17ec:	f8 94       	cli
    17ee:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    17f0:	f7 01       	movw	r30, r14
    17f2:	96 8d       	ldd	r25, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    17f4:	0f 90       	pop	r0
    17f6:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    17f8:	f7 01       	movw	r30, r14
    17fa:	87 8d       	ldd	r24, Z+31	; 0x1f
    17fc:	98 17       	cp	r25, r24
    17fe:	99 f0       	breq	.+38     	; 0x1826 <xQueueGenericSend+0xd4>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1800:	c7 01       	movw	r24, r14
    1802:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1806:	0e 94 66 11 	call	0x22cc	; 0x22cc <xTaskResumeAll>
			( void ) xTaskResumeAll();

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    180a:	21 e0       	ldi	r18, 0x01	; 1
    180c:	bf cf       	rjmp	.-130    	; 0x178c <xQueueGenericSend+0x3a>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    180e:	ce 01       	movw	r24, r28
    1810:	01 96       	adiw	r24, 0x01	; 1
    1812:	0e 94 4c 13 	call	0x2698	; 0x2698 <vTaskSetTimeOutState>
    1816:	ce cf       	rjmp	.-100    	; 0x17b4 <xQueueGenericSend+0x62>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    1818:	11 a2       	lds	r17, 0x91
    181a:	f7 01       	movw	r30, r14
    181c:	82 a1       	lds	r24, 0x42
    181e:	8f 3f       	cpi	r24, 0xFF	; 255
    1820:	c1 f6       	brne	.-80     	; 0x17d2 <xQueueGenericSend+0x80>
    1822:	12 a2       	lds	r17, 0x92
    1824:	d6 cf       	rjmp	.-84     	; 0x17d2 <xQueueGenericSend+0x80>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1826:	4e 81       	ldd	r20, Y+6	; 0x06
    1828:	5f 81       	ldd	r21, Y+7	; 0x07
    182a:	68 85       	ldd	r22, Y+8	; 0x08
    182c:	79 85       	ldd	r23, Y+9	; 0x09
    182e:	c6 01       	movw	r24, r12
    1830:	0e 94 d4 12 	call	0x25a8	; 0x25a8 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1834:	c7 01       	movw	r24, r14
    1836:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    183a:	0e 94 66 11 	call	0x22cc	; 0x22cc <xTaskResumeAll>
    183e:	88 23       	and	r24, r24
    1840:	21 f7       	brne	.-56     	; 0x180a <xQueueGenericSend+0xb8>
				{
					portYIELD_WITHIN_API();
    1842:	0e 94 a8 09 	call	0x1350	; 0x1350 <vPortYield>
			( void ) xTaskResumeAll();

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1846:	21 e0       	ldi	r18, 0x01	; 1
    1848:	a1 cf       	rjmp	.-190    	; 0x178c <xQueueGenericSend+0x3a>
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    184a:	c7 01       	movw	r24, r14
    184c:	b5 01       	movw	r22, r10
    184e:	40 2f       	mov	r20, r16
    1850:	0e 94 d2 0a 	call	0x15a4	; 0x15a4 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1854:	f7 01       	movw	r30, r14
    1856:	83 89       	ldd	r24, Z+19	; 0x13
    1858:	88 23       	and	r24, r24
    185a:	f1 f4       	brne	.+60     	; 0x1898 <xQueueGenericSend+0x146>
						takes care of that. */
						portYIELD_WITHIN_API();
					}
				}

				taskEXIT_CRITICAL();
    185c:	0f 90       	pop	r0
    185e:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1860:	81 e0       	ldi	r24, 0x01	; 1
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    1862:	29 96       	adiw	r28, 0x09	; 9
    1864:	0f b6       	in	r0, 0x3f	; 63
    1866:	f8 94       	cli
    1868:	de bf       	out	0x3e, r29	; 62
    186a:	0f be       	out	0x3f, r0	; 63
    186c:	cd bf       	out	0x3d, r28	; 61
    186e:	df 91       	pop	r29
    1870:	cf 91       	pop	r28
    1872:	0f 91       	pop	r16
    1874:	ff 90       	pop	r15
    1876:	ef 90       	pop	r14
    1878:	df 90       	pop	r13
    187a:	cf 90       	pop	r12
    187c:	bf 90       	pop	r11
    187e:	af 90       	pop	r10
    1880:	08 95       	ret
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1882:	0f 90       	pop	r0
    1884:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1886:	80 e0       	ldi	r24, 0x00	; 0
    1888:	ec cf       	rjmp	.-40     	; 0x1862 <xQueueGenericSend+0x110>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    188a:	c7 01       	movw	r24, r14
    188c:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1890:	0e 94 66 11 	call	0x22cc	; 0x22cc <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1894:	80 e0       	ldi	r24, 0x00	; 0
    1896:	e5 cf       	rjmp	.-54     	; 0x1862 <xQueueGenericSend+0x110>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1898:	c7 01       	movw	r24, r14
    189a:	43 96       	adiw	r24, 0x13	; 19
    189c:	0e 94 fe 12 	call	0x25fc	; 0x25fc <xTaskRemoveFromEventList>
    18a0:	81 30       	cpi	r24, 0x01	; 1
    18a2:	e1 f6       	brne	.-72     	; 0x185c <xQueueGenericSend+0x10a>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    18a4:	0e 94 a8 09 	call	0x1350	; 0x1350 <vPortYield>
    18a8:	d9 cf       	rjmp	.-78     	; 0x185c <xQueueGenericSend+0x10a>

000018aa <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    18aa:	0f 93       	push	r16
    18ac:	cf 93       	push	r28
    18ae:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    18b0:	83 e2       	ldi	r24, 0x23	; 35
    18b2:	90 e0       	ldi	r25, 0x00	; 0
    18b4:	0e 94 9d 08 	call	0x113a	; 0x113a <pvPortMalloc>
    18b8:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    18ba:	00 97       	sbiw	r24, 0x00	; 0
    18bc:	01 f1       	breq	.+64     	; 0x18fe <xQueueCreateMutex+0x54>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    18be:	1b 82       	std	Y+3, r1	; 0x03
    18c0:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    18c2:	19 82       	std	Y+1, r1	; 0x01
    18c4:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    18c6:	1d 82       	std	Y+5, r1	; 0x05
    18c8:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    18ca:	1f 82       	std	Y+7, r1	; 0x07
    18cc:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    18ce:	1e 8e       	std	Y+30, r1	; 0x1e
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    18d0:	81 e0       	ldi	r24, 0x01	; 1
    18d2:	8f 8f       	std	Y+31, r24	; 0x1f
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    18d4:	18 a2       	lds	r17, 0x98
			pxNewQueue->xRxLock = queueUNLOCKED;
    18d6:	8f ef       	ldi	r24, 0xFF	; 255
    18d8:	89 a3       	lds	r24, 0x59
			pxNewQueue->xTxLock = queueUNLOCKED;
    18da:	8a a3       	lds	r24, 0x5a
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    18dc:	ce 01       	movw	r24, r28
    18de:	08 96       	adiw	r24, 0x08	; 8
    18e0:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    18e4:	ce 01       	movw	r24, r28
    18e6:	43 96       	adiw	r24, 0x13	; 19
    18e8:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    18ec:	ce 01       	movw	r24, r28
    18ee:	60 e0       	ldi	r22, 0x00	; 0
    18f0:	70 e0       	ldi	r23, 0x00	; 0
    18f2:	20 e0       	ldi	r18, 0x00	; 0
    18f4:	30 e0       	ldi	r19, 0x00	; 0
    18f6:	a9 01       	movw	r20, r18
    18f8:	00 e0       	ldi	r16, 0x00	; 0
    18fa:	0e 94 a9 0b 	call	0x1752	; 0x1752 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    18fe:	ce 01       	movw	r24, r28
    1900:	df 91       	pop	r29
    1902:	cf 91       	pop	r28
    1904:	0f 91       	pop	r16
    1906:	08 95       	ret

00001908 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1908:	0f 93       	push	r16
    190a:	1f 93       	push	r17
    190c:	cf 93       	push	r28
    190e:	df 93       	push	r29
    1910:	ec 01       	movw	r28, r24
    1912:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1914:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1916:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1918:	98 17       	cp	r25, r24
    191a:	30 f0       	brcs	.+12     	; 0x1928 <xQueueGenericSendFromISR+0x20>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    191c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    191e:	df 91       	pop	r29
    1920:	cf 91       	pop	r28
    1922:	1f 91       	pop	r17
    1924:	0f 91       	pop	r16
    1926:	08 95       	ret
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1928:	ce 01       	movw	r24, r28
    192a:	42 2f       	mov	r20, r18
    192c:	0e 94 d2 0a 	call	0x15a4	; 0x15a4 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1930:	8a a1       	lds	r24, 0x4a
    1932:	8f 3f       	cpi	r24, 0xFF	; 255
    1934:	41 f0       	breq	.+16     	; 0x1946 <xQueueGenericSendFromISR+0x3e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1936:	8f 5f       	subi	r24, 0xFF	; 255
    1938:	8a a3       	lds	r24, 0x5a
			}

			xReturn = pdPASS;
    193a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    193c:	df 91       	pop	r29
    193e:	cf 91       	pop	r28
    1940:	1f 91       	pop	r17
    1942:	0f 91       	pop	r16
    1944:	08 95       	ret

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1946:	8b 89       	ldd	r24, Y+19	; 0x13
    1948:	88 23       	and	r24, r24
    194a:	11 f4       	brne	.+4      	; 0x1950 <xQueueGenericSendFromISR+0x48>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    194c:	81 e0       	ldi	r24, 0x01	; 1
    194e:	e7 cf       	rjmp	.-50     	; 0x191e <xQueueGenericSendFromISR+0x16>
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1950:	ce 01       	movw	r24, r28
    1952:	43 96       	adiw	r24, 0x13	; 19
    1954:	0e 94 fe 12 	call	0x25fc	; 0x25fc <xTaskRemoveFromEventList>
    1958:	88 23       	and	r24, r24
    195a:	c1 f3       	breq	.-16     	; 0x194c <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    195c:	81 e0       	ldi	r24, 0x01	; 1
    195e:	f8 01       	movw	r30, r16
    1960:	80 83       	st	Z, r24
    1962:	dd cf       	rjmp	.-70     	; 0x191e <xQueueGenericSendFromISR+0x16>

00001964 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1964:	af 92       	push	r10
    1966:	bf 92       	push	r11
    1968:	df 92       	push	r13
    196a:	ef 92       	push	r14
    196c:	ff 92       	push	r15
    196e:	0f 93       	push	r16
    1970:	1f 93       	push	r17
    1972:	cf 93       	push	r28
    1974:	df 93       	push	r29
    1976:	cd b7       	in	r28, 0x3d	; 61
    1978:	de b7       	in	r29, 0x3e	; 62
    197a:	29 97       	sbiw	r28, 0x09	; 9
    197c:	0f b6       	in	r0, 0x3f	; 63
    197e:	f8 94       	cli
    1980:	de bf       	out	0x3e, r29	; 62
    1982:	0f be       	out	0x3f, r0	; 63
    1984:	cd bf       	out	0x3d, r28	; 61
    1986:	7c 01       	movw	r14, r24
    1988:	5b 01       	movw	r10, r22
    198a:	2e 83       	std	Y+6, r18	; 0x06
    198c:	3f 83       	std	Y+7, r19	; 0x07
    198e:	48 87       	std	Y+8, r20	; 0x08
    1990:	59 87       	std	Y+9, r21	; 0x09
    1992:	d0 2e       	mov	r13, r16
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1994:	20 e0       	ldi	r18, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1996:	8c 01       	movw	r16, r24
    1998:	0d 5e       	subi	r16, 0xED	; 237
    199a:	1f 4f       	sbci	r17, 0xFF	; 255
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    199c:	0f b6       	in	r0, 0x3f	; 63
    199e:	f8 94       	cli
    19a0:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    19a2:	f7 01       	movw	r30, r14
    19a4:	86 8d       	ldd	r24, Z+30	; 0x1e
    19a6:	88 23       	and	r24, r24
    19a8:	09 f0       	breq	.+2      	; 0x19ac <xQueueGenericReceive+0x48>
    19aa:	6a c0       	rjmp	.+212    	; 0x1a80 <xQueueGenericReceive+0x11c>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    19ac:	8e 81       	ldd	r24, Y+6	; 0x06
    19ae:	9f 81       	ldd	r25, Y+7	; 0x07
    19b0:	a8 85       	ldd	r26, Y+8	; 0x08
    19b2:	b9 85       	ldd	r27, Y+9	; 0x09
    19b4:	00 97       	sbiw	r24, 0x00	; 0
    19b6:	a1 05       	cpc	r26, r1
    19b8:	b1 05       	cpc	r27, r1
    19ba:	09 f4       	brne	.+2      	; 0x19be <xQueueGenericReceive+0x5a>
    19bc:	7e c0       	rjmp	.+252    	; 0x1aba <xQueueGenericReceive+0x156>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    19be:	22 23       	and	r18, r18
    19c0:	09 f4       	brne	.+2      	; 0x19c4 <xQueueGenericReceive+0x60>
    19c2:	3f c0       	rjmp	.+126    	; 0x1a42 <xQueueGenericReceive+0xde>
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    19c4:	0f 90       	pop	r0
    19c6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    19c8:	0e 94 39 10 	call	0x2072	; 0x2072 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    19cc:	0f b6       	in	r0, 0x3f	; 63
    19ce:	f8 94       	cli
    19d0:	0f 92       	push	r0
    19d2:	f7 01       	movw	r30, r14
    19d4:	81 a1       	lds	r24, 0x41
    19d6:	8f 3f       	cpi	r24, 0xFF	; 255
    19d8:	09 f4       	brne	.+2      	; 0x19dc <xQueueGenericReceive+0x78>
    19da:	3f c0       	rjmp	.+126    	; 0x1a5a <xQueueGenericReceive+0xf6>
    19dc:	f7 01       	movw	r30, r14
    19de:	82 a1       	lds	r24, 0x42
    19e0:	8f 3f       	cpi	r24, 0xFF	; 255
    19e2:	09 f4       	brne	.+2      	; 0x19e6 <xQueueGenericReceive+0x82>
    19e4:	40 c0       	rjmp	.+128    	; 0x1a66 <xQueueGenericReceive+0x102>
    19e6:	0f 90       	pop	r0
    19e8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    19ea:	ce 01       	movw	r24, r28
    19ec:	01 96       	adiw	r24, 0x01	; 1
    19ee:	be 01       	movw	r22, r28
    19f0:	6a 5f       	subi	r22, 0xFA	; 250
    19f2:	7f 4f       	sbci	r23, 0xFF	; 255
    19f4:	0e 94 5d 13 	call	0x26ba	; 0x26ba <xTaskCheckForTimeOut>
    19f8:	88 23       	and	r24, r24
    19fa:	09 f0       	breq	.+2      	; 0x19fe <xQueueGenericReceive+0x9a>
    19fc:	71 c0       	rjmp	.+226    	; 0x1ae0 <xQueueGenericReceive+0x17c>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    19fe:	0f b6       	in	r0, 0x3f	; 63
    1a00:	f8 94       	cli
    1a02:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1a04:	f7 01       	movw	r30, r14
    1a06:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1a08:	0f 90       	pop	r0
    1a0a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1a0c:	88 23       	and	r24, r24
    1a0e:	f1 f4       	brne	.+60     	; 0x1a4c <xQueueGenericReceive+0xe8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1a10:	f7 01       	movw	r30, r14
    1a12:	80 81       	ld	r24, Z
    1a14:	91 81       	ldd	r25, Z+1	; 0x01
    1a16:	00 97       	sbiw	r24, 0x00	; 0
    1a18:	41 f1       	breq	.+80     	; 0x1a6a <xQueueGenericReceive+0x106>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1a1a:	4e 81       	ldd	r20, Y+6	; 0x06
    1a1c:	5f 81       	ldd	r21, Y+7	; 0x07
    1a1e:	68 85       	ldd	r22, Y+8	; 0x08
    1a20:	79 85       	ldd	r23, Y+9	; 0x09
    1a22:	c8 01       	movw	r24, r16
    1a24:	0e 94 d4 12 	call	0x25a8	; 0x25a8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1a28:	c7 01       	movw	r24, r14
    1a2a:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1a2e:	0e 94 66 11 	call	0x22cc	; 0x22cc <xTaskResumeAll>
    1a32:	88 23       	and	r24, r24
    1a34:	11 f0       	breq	.+4      	; 0x1a3a <xQueueGenericReceive+0xd6>
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1a36:	21 e0       	ldi	r18, 0x01	; 1
    1a38:	b1 cf       	rjmp	.-158    	; 0x199c <xQueueGenericReceive+0x38>

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
				{
					portYIELD_WITHIN_API();
    1a3a:	0e 94 a8 09 	call	0x1350	; 0x1350 <vPortYield>
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1a3e:	21 e0       	ldi	r18, 0x01	; 1
    1a40:	ad cf       	rjmp	.-166    	; 0x199c <xQueueGenericReceive+0x38>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1a42:	ce 01       	movw	r24, r28
    1a44:	01 96       	adiw	r24, 0x01	; 1
    1a46:	0e 94 4c 13 	call	0x2698	; 0x2698 <vTaskSetTimeOutState>
    1a4a:	bc cf       	rjmp	.-136    	; 0x19c4 <xQueueGenericReceive+0x60>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1a4c:	c7 01       	movw	r24, r14
    1a4e:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1a52:	0e 94 66 11 	call	0x22cc	; 0x22cc <xTaskResumeAll>
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1a56:	21 e0       	ldi	r18, 0x01	; 1
    1a58:	a1 cf       	rjmp	.-190    	; 0x199c <xQueueGenericReceive+0x38>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    1a5a:	11 a2       	lds	r17, 0x91
    1a5c:	f7 01       	movw	r30, r14
    1a5e:	82 a1       	lds	r24, 0x42
    1a60:	8f 3f       	cpi	r24, 0xFF	; 255
    1a62:	09 f0       	breq	.+2      	; 0x1a66 <xQueueGenericReceive+0x102>
    1a64:	c0 cf       	rjmp	.-128    	; 0x19e6 <xQueueGenericReceive+0x82>
    1a66:	12 a2       	lds	r17, 0x92
    1a68:	be cf       	rjmp	.-132    	; 0x19e6 <xQueueGenericReceive+0x82>

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
					{
						portENTER_CRITICAL();
    1a6a:	0f b6       	in	r0, 0x3f	; 63
    1a6c:	f8 94       	cli
    1a6e:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1a70:	f7 01       	movw	r30, r14
    1a72:	82 81       	ldd	r24, Z+2	; 0x02
    1a74:	93 81       	ldd	r25, Z+3	; 0x03
    1a76:	0e 94 e5 13 	call	0x27ca	; 0x27ca <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1a7a:	0f 90       	pop	r0
    1a7c:	0f be       	out	0x3f, r0	; 63
    1a7e:	cd cf       	rjmp	.-102    	; 0x1a1a <xQueueGenericReceive+0xb6>
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1a80:	06 81       	ldd	r16, Z+6	; 0x06
    1a82:	17 81       	ldd	r17, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a84:	c7 01       	movw	r24, r14
    1a86:	b5 01       	movw	r22, r10
    1a88:	0e 94 5f 0a 	call	0x14be	; 0x14be <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1a8c:	f7 01       	movw	r30, r14
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    1a8e:	dd 20       	and	r13, r13
    1a90:	71 f5       	brne	.+92     	; 0x1aee <xQueueGenericReceive+0x18a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1a92:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a94:	81 50       	subi	r24, 0x01	; 1
    1a96:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1a98:	80 81       	ld	r24, Z
    1a9a:	91 81       	ldd	r25, Z+1	; 0x01
    1a9c:	00 97       	sbiw	r24, 0x00	; 0
    1a9e:	b9 f1       	breq	.+110    	; 0x1b0e <xQueueGenericReceive+0x1aa>
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1aa0:	f7 01       	movw	r30, r14
    1aa2:	80 85       	ldd	r24, Z+8	; 0x08
    1aa4:	88 23       	and	r24, r24
    1aa6:	41 f1       	breq	.+80     	; 0x1af8 <xQueueGenericReceive+0x194>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1aa8:	c7 01       	movw	r24, r14
    1aaa:	08 96       	adiw	r24, 0x08	; 8
    1aac:	0e 94 fe 12 	call	0x25fc	; 0x25fc <xTaskRemoveFromEventList>
    1ab0:	81 30       	cpi	r24, 0x01	; 1
    1ab2:	11 f5       	brne	.+68     	; 0x1af8 <xQueueGenericReceive+0x194>
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1ab4:	0e 94 a8 09 	call	0x1350	; 0x1350 <vPortYield>
    1ab8:	1f c0       	rjmp	.+62     	; 0x1af8 <xQueueGenericReceive+0x194>
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1aba:	0f 90       	pop	r0
    1abc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1abe:	80 e0       	ldi	r24, 0x00	; 0
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    1ac0:	29 96       	adiw	r28, 0x09	; 9
    1ac2:	0f b6       	in	r0, 0x3f	; 63
    1ac4:	f8 94       	cli
    1ac6:	de bf       	out	0x3e, r29	; 62
    1ac8:	0f be       	out	0x3f, r0	; 63
    1aca:	cd bf       	out	0x3d, r28	; 61
    1acc:	df 91       	pop	r29
    1ace:	cf 91       	pop	r28
    1ad0:	1f 91       	pop	r17
    1ad2:	0f 91       	pop	r16
    1ad4:	ff 90       	pop	r15
    1ad6:	ef 90       	pop	r14
    1ad8:	df 90       	pop	r13
    1ada:	bf 90       	pop	r11
    1adc:	af 90       	pop	r10
    1ade:	08 95       	ret
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1ae0:	c7 01       	movw	r24, r14
    1ae2:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ae6:	0e 94 66 11 	call	0x22cc	; 0x22cc <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1aea:	80 e0       	ldi	r24, 0x00	; 0
    1aec:	e9 cf       	rjmp	.-46     	; 0x1ac0 <xQueueGenericReceive+0x15c>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1aee:	17 83       	std	Z+7, r17	; 0x07
    1af0:	06 83       	std	Z+6, r16	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1af2:	83 89       	ldd	r24, Z+19	; 0x13
    1af4:	88 23       	and	r24, r24
    1af6:	21 f4       	brne	.+8      	; 0x1b00 <xQueueGenericReceive+0x19c>
						}
					}

				}

				taskEXIT_CRITICAL();
    1af8:	0f 90       	pop	r0
    1afa:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1afc:	81 e0       	ldi	r24, 0x01	; 1
    1afe:	e0 cf       	rjmp	.-64     	; 0x1ac0 <xQueueGenericReceive+0x15c>
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b00:	c7 01       	movw	r24, r14
    1b02:	43 96       	adiw	r24, 0x13	; 19
    1b04:	0e 94 fe 12 	call	0x25fc	; 0x25fc <xTaskRemoveFromEventList>
    1b08:	88 23       	and	r24, r24
    1b0a:	b1 f3       	breq	.-20     	; 0x1af8 <xQueueGenericReceive+0x194>
    1b0c:	d3 cf       	rjmp	.-90     	; 0x1ab4 <xQueueGenericReceive+0x150>
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1b0e:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <xTaskGetCurrentTaskHandle>
    1b12:	f7 01       	movw	r30, r14
    1b14:	93 83       	std	Z+3, r25	; 0x03
    1b16:	82 83       	std	Z+2, r24	; 0x02
    1b18:	c3 cf       	rjmp	.-122    	; 0x1aa0 <xQueueGenericReceive+0x13c>

00001b1a <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1b1a:	0f 93       	push	r16
    1b1c:	1f 93       	push	r17
    1b1e:	cf 93       	push	r28
    1b20:	df 93       	push	r29
    1b22:	ec 01       	movw	r28, r24
    1b24:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1b26:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1b28:	88 23       	and	r24, r24
    1b2a:	31 f4       	brne	.+12     	; 0x1b38 <xQueueReceiveFromISR+0x1e>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1b2c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1b2e:	df 91       	pop	r29
    1b30:	cf 91       	pop	r28
    1b32:	1f 91       	pop	r17
    1b34:	0f 91       	pop	r16
    1b36:	08 95       	ret
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b38:	ce 01       	movw	r24, r28
    1b3a:	0e 94 5f 0a 	call	0x14be	; 0x14be <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1b3e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1b40:	81 50       	subi	r24, 0x01	; 1
    1b42:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1b44:	89 a1       	lds	r24, 0x49
    1b46:	8f 3f       	cpi	r24, 0xFF	; 255
    1b48:	41 f0       	breq	.+16     	; 0x1b5a <xQueueReceiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1b4a:	8f 5f       	subi	r24, 0xFF	; 255
    1b4c:	89 a3       	lds	r24, 0x59
			}

			xReturn = pdPASS;
    1b4e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1b50:	df 91       	pop	r29
    1b52:	cf 91       	pop	r28
    1b54:	1f 91       	pop	r17
    1b56:	0f 91       	pop	r16
    1b58:	08 95       	ret
			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b5a:	88 85       	ldd	r24, Y+8	; 0x08
    1b5c:	88 23       	and	r24, r24
    1b5e:	11 f4       	brne	.+4      	; 0x1b64 <xQueueReceiveFromISR+0x4a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1b60:	81 e0       	ldi	r24, 0x01	; 1
    1b62:	e5 cf       	rjmp	.-54     	; 0x1b2e <xQueueReceiveFromISR+0x14>
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b64:	ce 01       	movw	r24, r28
    1b66:	08 96       	adiw	r24, 0x08	; 8
    1b68:	0e 94 fe 12 	call	0x25fc	; 0x25fc <xTaskRemoveFromEventList>
    1b6c:	88 23       	and	r24, r24
    1b6e:	c1 f3       	breq	.-16     	; 0x1b60 <xQueueReceiveFromISR+0x46>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1b70:	81 e0       	ldi	r24, 0x01	; 1
    1b72:	f8 01       	movw	r30, r16
    1b74:	80 83       	st	Z, r24
    1b76:	db cf       	rjmp	.-74     	; 0x1b2e <xQueueReceiveFromISR+0x14>

00001b78 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1b78:	0f b6       	in	r0, 0x3f	; 63
    1b7a:	f8 94       	cli
    1b7c:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1b7e:	fc 01       	movw	r30, r24
    1b80:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1b82:	0f 90       	pop	r0
    1b84:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1b86:	08 95       	ret

00001b88 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1b88:	fc 01       	movw	r30, r24
    1b8a:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    1b8c:	08 95       	ret

00001b8e <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1b8e:	cf 93       	push	r28
    1b90:	df 93       	push	r29
    1b92:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1b94:	88 81       	ld	r24, Y
    1b96:	99 81       	ldd	r25, Y+1	; 0x01
    1b98:	0e 94 c9 08 	call	0x1192	; 0x1192 <vPortFree>
	vPortFree( pxQueue );
    1b9c:	ce 01       	movw	r24, r28
    1b9e:	0e 94 c9 08 	call	0x1192	; 0x1192 <vPortFree>
}
    1ba2:	df 91       	pop	r29
    1ba4:	cf 91       	pop	r28
    1ba6:	08 95       	ret

00001ba8 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1ba8:	fc 01       	movw	r30, r24
    1baa:	96 8d       	ldd	r25, Z+30	; 0x1e
    1bac:	81 e0       	ldi	r24, 0x01	; 1
    1bae:	91 11       	cpse	r25, r1
    1bb0:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1bb2:	08 95       	ret

00001bb4 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1bb4:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1bb6:	26 8d       	ldd	r18, Z+30	; 0x1e
    1bb8:	81 e0       	ldi	r24, 0x01	; 1
    1bba:	97 8d       	ldd	r25, Z+31	; 0x1f
    1bbc:	29 13       	cpse	r18, r25
    1bbe:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1bc0:	08 95       	ret

00001bc2 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1bc2:	80 91 03 1a 	lds	r24, 0x1A03
    1bc6:	82 30       	cpi	r24, 0x02	; 2
    1bc8:	e0 f3       	brcs	.-8      	; 0x1bc2 <prvIdleTask>
			{
				taskYIELD();
    1bca:	0e 94 a8 09 	call	0x1350	; 0x1350 <vPortYield>
    1bce:	f9 cf       	rjmp	.-14     	; 0x1bc2 <prvIdleTask>

00001bd0 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1bd0:	cf 92       	push	r12
    1bd2:	df 92       	push	r13
    1bd4:	ef 92       	push	r14
    1bd6:	ff 92       	push	r15
    1bd8:	6b 01       	movw	r12, r22
    1bda:	7c 01       	movw	r14, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1bdc:	e0 91 f2 19 	lds	r30, 0x19F2
    1be0:	f0 91 f3 19 	lds	r31, 0x19F3
    1be4:	62 83       	std	Z+2, r22	; 0x02
    1be6:	73 83       	std	Z+3, r23	; 0x03
    1be8:	84 83       	std	Z+4, r24	; 0x04
    1bea:	95 83       	std	Z+5, r25	; 0x05

	if( xTimeToWake < xTickCount )
    1bec:	80 91 fa 19 	lds	r24, 0x19FA
    1bf0:	90 91 fb 19 	lds	r25, 0x19FB
    1bf4:	a0 91 fc 19 	lds	r26, 0x19FC
    1bf8:	b0 91 fd 19 	lds	r27, 0x19FD
    1bfc:	c8 16       	cp	r12, r24
    1bfe:	d9 06       	cpc	r13, r25
    1c00:	ea 06       	cpc	r14, r26
    1c02:	fb 06       	cpc	r15, r27
    1c04:	30 f1       	brcs	.+76     	; 0x1c52 <prvAddCurrentTaskToDelayedList+0x82>
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1c06:	80 91 01 1a 	lds	r24, 0x1A01
    1c0a:	90 91 02 1a 	lds	r25, 0x1A02
    1c0e:	60 91 f2 19 	lds	r22, 0x19F2
    1c12:	70 91 f3 19 	lds	r23, 0x19F3
    1c16:	6e 5f       	subi	r22, 0xFE	; 254
    1c18:	7f 4f       	sbci	r23, 0xFF	; 255
    1c1a:	0e 94 5e 15 	call	0x2abc	; 0x2abc <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1c1e:	80 91 95 02 	lds	r24, 0x0295
    1c22:	90 91 96 02 	lds	r25, 0x0296
    1c26:	a0 91 97 02 	lds	r26, 0x0297
    1c2a:	b0 91 98 02 	lds	r27, 0x0298
    1c2e:	c8 16       	cp	r12, r24
    1c30:	d9 06       	cpc	r13, r25
    1c32:	ea 06       	cpc	r14, r26
    1c34:	fb 06       	cpc	r15, r27
    1c36:	40 f4       	brcc	.+16     	; 0x1c48 <prvAddCurrentTaskToDelayedList+0x78>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1c38:	c0 92 95 02 	sts	0x0295, r12
    1c3c:	d0 92 96 02 	sts	0x0296, r13
    1c40:	e0 92 97 02 	sts	0x0297, r14
    1c44:	f0 92 98 02 	sts	0x0298, r15
		}
	}
}
    1c48:	ff 90       	pop	r15
    1c4a:	ef 90       	pop	r14
    1c4c:	df 90       	pop	r13
    1c4e:	cf 90       	pop	r12
    1c50:	08 95       	ret
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1c52:	80 91 ff 19 	lds	r24, 0x19FF
    1c56:	90 91 00 1a 	lds	r25, 0x1A00
    1c5a:	60 91 f2 19 	lds	r22, 0x19F2
    1c5e:	70 91 f3 19 	lds	r23, 0x19F3
    1c62:	6e 5f       	subi	r22, 0xFE	; 254
    1c64:	7f 4f       	sbci	r23, 0xFF	; 255
    1c66:	0e 94 5e 15 	call	0x2abc	; 0x2abc <vListInsert>
		if( xTimeToWake < xNextTaskUnblockTime )
		{
			xNextTaskUnblockTime = xTimeToWake;
		}
	}
}
    1c6a:	ff 90       	pop	r15
    1c6c:	ef 90       	pop	r14
    1c6e:	df 90       	pop	r13
    1c70:	cf 90       	pop	r12
    1c72:	08 95       	ret

00001c74 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1c74:	4f 92       	push	r4
    1c76:	5f 92       	push	r5
    1c78:	6f 92       	push	r6
    1c7a:	7f 92       	push	r7
    1c7c:	8f 92       	push	r8
    1c7e:	9f 92       	push	r9
    1c80:	af 92       	push	r10
    1c82:	bf 92       	push	r11
    1c84:	cf 92       	push	r12
    1c86:	df 92       	push	r13
    1c88:	ef 92       	push	r14
    1c8a:	ff 92       	push	r15
    1c8c:	0f 93       	push	r16
    1c8e:	1f 93       	push	r17
    1c90:	cf 93       	push	r28
    1c92:	df 93       	push	r29
    1c94:	2c 01       	movw	r4, r24
    1c96:	4b 01       	movw	r8, r22
    1c98:	5a 01       	movw	r10, r20
    1c9a:	39 01       	movw	r6, r18
    1c9c:	d0 2f       	mov	r29, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1c9e:	88 e2       	ldi	r24, 0x28	; 40
    1ca0:	90 e0       	ldi	r25, 0x00	; 0
    1ca2:	0e 94 9d 08 	call	0x113a	; 0x113a <pvPortMalloc>
    1ca6:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    1ca8:	00 97       	sbiw	r24, 0x00	; 0
    1caa:	09 f4       	brne	.+2      	; 0x1cae <xTaskGenericCreate+0x3a>
    1cac:	ba c0       	rjmp	.+372    	; 0x1e22 <xTaskGenericCreate+0x1ae>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1cae:	c1 14       	cp	r12, r1
    1cb0:	d1 04       	cpc	r13, r1
    1cb2:	09 f4       	brne	.+2      	; 0x1cb6 <xTaskGenericCreate+0x42>
    1cb4:	f7 c0       	rjmp	.+494    	; 0x1ea4 <xTaskGenericCreate+0x230>
    1cb6:	fc 01       	movw	r30, r24
    1cb8:	d4 8e       	std	Z+28, r13	; 0x1c
    1cba:	c3 8e       	std	Z+27, r12	; 0x1b
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    1cbc:	c6 01       	movw	r24, r12
    1cbe:	61 e1       	ldi	r22, 0x11	; 17
    1cc0:	70 e0       	ldi	r23, 0x00	; 0
    1cc2:	a5 01       	movw	r20, r10
    1cc4:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1cc8:	c5 01       	movw	r24, r10
    1cca:	01 97       	sbiw	r24, 0x01	; 1
    1ccc:	f8 01       	movw	r30, r16
    1cce:	c3 8c       	ldd	r12, Z+27	; 0x1b
    1cd0:	d4 8c       	ldd	r13, Z+28	; 0x1c
    1cd2:	c8 0e       	add	r12, r24
    1cd4:	d9 1e       	adc	r13, r25
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1cd6:	c8 01       	movw	r24, r16
    1cd8:	4d 96       	adiw	r24, 0x1d	; 29
    1cda:	b4 01       	movw	r22, r8
    1cdc:	4a e0       	ldi	r20, 0x0A	; 10
    1cde:	50 e0       	ldi	r21, 0x00	; 0
    1ce0:	0e 94 83 16 	call	0x2d06	; 0x2d06 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1ce4:	f8 01       	movw	r30, r16
    1ce6:	16 a2       	lds	r17, 0x96
    1ce8:	cd 2f       	mov	r28, r29
    1cea:	d4 30       	cpi	r29, 0x04	; 4
    1cec:	08 f0       	brcs	.+2      	; 0x1cf0 <xTaskGenericCreate+0x7c>
    1cee:	93 c0       	rjmp	.+294    	; 0x1e16 <xTaskGenericCreate+0x1a2>
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    1cf0:	f8 01       	movw	r30, r16
    1cf2:	c2 8f       	std	Z+26, r28	; 0x1a
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    1cf4:	c7 a3       	lds	r28, 0x57
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1cf6:	b2 e0       	ldi	r27, 0x02	; 2
    1cf8:	ab 2e       	mov	r10, r27
    1cfa:	b1 2c       	mov	r11, r1
    1cfc:	a0 0e       	add	r10, r16
    1cfe:	b1 1e       	adc	r11, r17
    1d00:	c5 01       	movw	r24, r10
    1d02:	0e 94 33 15 	call	0x2a66	; 0x2a66 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1d06:	c8 01       	movw	r24, r16
    1d08:	0e 96       	adiw	r24, 0x0e	; 14
    1d0a:	0e 94 33 15 	call	0x2a66	; 0x2a66 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1d0e:	f8 01       	movw	r30, r16
    1d10:	13 87       	std	Z+11, r17	; 0x0b
    1d12:	02 87       	std	Z+10, r16	; 0x0a

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1d14:	84 e0       	ldi	r24, 0x04	; 4
    1d16:	90 e0       	ldi	r25, 0x00	; 0
    1d18:	a0 e0       	ldi	r26, 0x00	; 0
    1d1a:	b0 e0       	ldi	r27, 0x00	; 0
    1d1c:	8c 1b       	sub	r24, r28
    1d1e:	91 09       	sbc	r25, r1
    1d20:	a1 09       	sbc	r26, r1
    1d22:	b1 09       	sbc	r27, r1
    1d24:	86 87       	std	Z+14, r24	; 0x0e
    1d26:	97 87       	std	Z+15, r25	; 0x0f
    1d28:	a0 8b       	std	Z+16, r26	; 0x10
    1d2a:	b1 8b       	std	Z+17, r27	; 0x11
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1d2c:	17 8b       	std	Z+23, r17	; 0x17
    1d2e:	06 8b       	std	Z+22, r16	; 0x16
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1d30:	c6 01       	movw	r24, r12
    1d32:	b2 01       	movw	r22, r4
    1d34:	a3 01       	movw	r20, r6
    1d36:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <pxPortInitialiseStack>
    1d3a:	f8 01       	movw	r30, r16
    1d3c:	91 83       	std	Z+1, r25	; 0x01
    1d3e:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    1d40:	e1 14       	cp	r14, r1
    1d42:	f1 04       	cpc	r15, r1
    1d44:	19 f0       	breq	.+6      	; 0x1d4c <xTaskGenericCreate+0xd8>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1d46:	f7 01       	movw	r30, r14
    1d48:	11 83       	std	Z+1, r17	; 0x01
    1d4a:	00 83       	st	Z, r16
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1d4c:	0f b6       	in	r0, 0x3f	; 63
    1d4e:	f8 94       	cli
    1d50:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1d52:	80 91 fe 19 	lds	r24, 0x19FE
    1d56:	8f 5f       	subi	r24, 0xFF	; 255
    1d58:	80 93 fe 19 	sts	0x19FE, r24
			if( pxCurrentTCB == NULL )
    1d5c:	80 91 f2 19 	lds	r24, 0x19F2
    1d60:	90 91 f3 19 	lds	r25, 0x19F3
    1d64:	00 97       	sbiw	r24, 0x00	; 0
    1d66:	09 f4       	brne	.+2      	; 0x1d6a <xTaskGenericCreate+0xf6>
    1d68:	5e c0       	rjmp	.+188    	; 0x1e26 <xTaskGenericCreate+0x1b2>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1d6a:	80 91 f8 19 	lds	r24, 0x19F8
    1d6e:	88 23       	and	r24, r24
    1d70:	59 f4       	brne	.+22     	; 0x1d88 <xTaskGenericCreate+0x114>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1d72:	e0 91 f2 19 	lds	r30, 0x19F2
    1d76:	f0 91 f3 19 	lds	r31, 0x19F3
    1d7a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d7c:	d8 17       	cp	r29, r24
    1d7e:	20 f0       	brcs	.+8      	; 0x1d88 <xTaskGenericCreate+0x114>
					{
						pxCurrentTCB = pxNewTCB;
    1d80:	10 93 f3 19 	sts	0x19F3, r17
    1d84:	00 93 f2 19 	sts	0x19F2, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1d88:	f8 01       	movw	r30, r16
    1d8a:	22 8d       	ldd	r18, Z+26	; 0x1a
    1d8c:	80 91 50 1a 	lds	r24, 0x1A50
    1d90:	82 17       	cp	r24, r18
    1d92:	10 f4       	brcc	.+4      	; 0x1d98 <xTaskGenericCreate+0x124>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1d94:	20 93 50 1a 	sts	0x1A50, r18
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1d98:	80 91 51 1a 	lds	r24, 0x1A51
    1d9c:	8f 5f       	subi	r24, 0xFF	; 255
    1d9e:	80 93 51 1a 	sts	0x1A51, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1da2:	80 91 f9 19 	lds	r24, 0x19F9
    1da6:	82 17       	cp	r24, r18
    1da8:	98 f1       	brcs	.+102    	; 0x1e10 <xTaskGenericCreate+0x19c>
    1daa:	30 e0       	ldi	r19, 0x00	; 0
    1dac:	c9 01       	movw	r24, r18
    1dae:	88 0f       	add	r24, r24
    1db0:	99 1f       	adc	r25, r25
    1db2:	a9 01       	movw	r20, r18
    1db4:	44 0f       	add	r20, r20
    1db6:	55 1f       	adc	r21, r21
    1db8:	44 0f       	add	r20, r20
    1dba:	55 1f       	adc	r21, r21
    1dbc:	44 0f       	add	r20, r20
    1dbe:	55 1f       	adc	r21, r21
    1dc0:	84 0f       	add	r24, r20
    1dc2:	95 1f       	adc	r25, r21
    1dc4:	82 0f       	add	r24, r18
    1dc6:	93 1f       	adc	r25, r19
    1dc8:	8d 5f       	subi	r24, 0xFD	; 253
    1dca:	95 4e       	sbci	r25, 0xE5	; 229
    1dcc:	b5 01       	movw	r22, r10
    1dce:	0e 94 37 15 	call	0x2a6e	; 0x2a6e <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1dd2:	0f 90       	pop	r0
    1dd4:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1dd6:	80 91 f8 19 	lds	r24, 0x19F8
    1dda:	88 23       	and	r24, r24
    1ddc:	39 f0       	breq	.+14     	; 0x1dec <xTaskGenericCreate+0x178>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1dde:	e0 91 f2 19 	lds	r30, 0x19F2
    1de2:	f0 91 f3 19 	lds	r31, 0x19F3
    1de6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1de8:	8d 17       	cp	r24, r29
    1dea:	b8 f0       	brcs	.+46     	; 0x1e1a <xTaskGenericCreate+0x1a6>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1dec:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    1dee:	df 91       	pop	r29
    1df0:	cf 91       	pop	r28
    1df2:	1f 91       	pop	r17
    1df4:	0f 91       	pop	r16
    1df6:	ff 90       	pop	r15
    1df8:	ef 90       	pop	r14
    1dfa:	df 90       	pop	r13
    1dfc:	cf 90       	pop	r12
    1dfe:	bf 90       	pop	r11
    1e00:	af 90       	pop	r10
    1e02:	9f 90       	pop	r9
    1e04:	8f 90       	pop	r8
    1e06:	7f 90       	pop	r7
    1e08:	6f 90       	pop	r6
    1e0a:	5f 90       	pop	r5
    1e0c:	4f 90       	pop	r4
    1e0e:	08 95       	ret
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );
    1e10:	20 93 f9 19 	sts	0x19F9, r18
    1e14:	ca cf       	rjmp	.-108    	; 0x1daa <xTaskGenericCreate+0x136>
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1e16:	c3 e0       	ldi	r28, 0x03	; 3
    1e18:	6b cf       	rjmp	.-298    	; 0x1cf0 <xTaskGenericCreate+0x7c>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
			{
				portYIELD_WITHIN_API();
    1e1a:	0e 94 a8 09 	call	0x1350	; 0x1350 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1e1e:	81 e0       	ldi	r24, 0x01	; 1
    1e20:	e6 cf       	rjmp	.-52     	; 0x1dee <xTaskGenericCreate+0x17a>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1e22:	8f ef       	ldi	r24, 0xFF	; 255
    1e24:	e4 cf       	rjmp	.-56     	; 0x1dee <xTaskGenericCreate+0x17a>
			uxCurrentNumberOfTasks++;
			if( pxCurrentTCB == NULL )
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1e26:	10 93 f3 19 	sts	0x19F3, r17
    1e2a:	00 93 f2 19 	sts	0x19F2, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1e2e:	80 91 fe 19 	lds	r24, 0x19FE
    1e32:	81 30       	cpi	r24, 0x01	; 1
    1e34:	09 f0       	breq	.+2      	; 0x1e38 <xTaskGenericCreate+0x1c4>
    1e36:	a8 cf       	rjmp	.-176    	; 0x1d88 <xTaskGenericCreate+0x114>
    1e38:	cc 24       	eor	r12, r12
    1e3a:	dd 24       	eor	r13, r13
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    1e3c:	c6 01       	movw	r24, r12
    1e3e:	88 0f       	add	r24, r24
    1e40:	99 1f       	adc	r25, r25
    1e42:	96 01       	movw	r18, r12
    1e44:	22 0f       	add	r18, r18
    1e46:	33 1f       	adc	r19, r19
    1e48:	22 0f       	add	r18, r18
    1e4a:	33 1f       	adc	r19, r19
    1e4c:	22 0f       	add	r18, r18
    1e4e:	33 1f       	adc	r19, r19
    1e50:	82 0f       	add	r24, r18
    1e52:	93 1f       	adc	r25, r19
    1e54:	8c 0d       	add	r24, r12
    1e56:	9d 1d       	adc	r25, r13
    1e58:	8d 5f       	subi	r24, 0xFD	; 253
    1e5a:	95 4e       	sbci	r25, 0xE5	; 229
    1e5c:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vListInitialise>
    1e60:	08 94       	sec
    1e62:	c1 1c       	adc	r12, r1
    1e64:	d1 1c       	adc	r13, r1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    1e66:	f4 e0       	ldi	r31, 0x04	; 4
    1e68:	cf 16       	cp	r12, r31
    1e6a:	d1 04       	cpc	r13, r1
    1e6c:	39 f7       	brne	.-50     	; 0x1e3c <xTaskGenericCreate+0x1c8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    1e6e:	7f e2       	ldi	r23, 0x2F	; 47
    1e70:	e7 2e       	mov	r14, r23
    1e72:	7a e1       	ldi	r23, 0x1A	; 26
    1e74:	f7 2e       	mov	r15, r23
    1e76:	c7 01       	movw	r24, r14
    1e78:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1e7c:	ea e3       	ldi	r30, 0x3A	; 58
    1e7e:	ce 2e       	mov	r12, r30
    1e80:	ea e1       	ldi	r30, 0x1A	; 26
    1e82:	de 2e       	mov	r13, r30
    1e84:	c6 01       	movw	r24, r12
    1e86:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    1e8a:	85 e4       	ldi	r24, 0x45	; 69
    1e8c:	9a e1       	ldi	r25, 0x1A	; 26
    1e8e:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1e92:	f0 92 02 1a 	sts	0x1A02, r15
    1e96:	e0 92 01 1a 	sts	0x1A01, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1e9a:	d0 92 00 1a 	sts	0x1A00, r13
    1e9e:	c0 92 ff 19 	sts	0x19FF, r12
    1ea2:	72 cf       	rjmp	.-284    	; 0x1d88 <xTaskGenericCreate+0x114>
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1ea4:	c5 01       	movw	r24, r10
    1ea6:	0e 94 9d 08 	call	0x113a	; 0x113a <pvPortMalloc>
    1eaa:	6c 01       	movw	r12, r24
    1eac:	f8 01       	movw	r30, r16
    1eae:	94 8f       	std	Z+28, r25	; 0x1c
    1eb0:	83 8f       	std	Z+27, r24	; 0x1b

		if( pxNewTCB->pxStack == NULL )
    1eb2:	00 97       	sbiw	r24, 0x00	; 0
    1eb4:	09 f0       	breq	.+2      	; 0x1eb8 <xTaskGenericCreate+0x244>
    1eb6:	02 cf       	rjmp	.-508    	; 0x1cbc <xTaskGenericCreate+0x48>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1eb8:	c8 01       	movw	r24, r16
    1eba:	0e 94 c9 08 	call	0x1192	; 0x1192 <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1ebe:	8f ef       	ldi	r24, 0xFF	; 255
    1ec0:	96 cf       	rjmp	.-212    	; 0x1dee <xTaskGenericCreate+0x17a>

00001ec2 <uxTaskPriorityGet>:
	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
    1ec2:	0f b6       	in	r0, 0x3f	; 63
    1ec4:	f8 94       	cli
    1ec6:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1ec8:	00 97       	sbiw	r24, 0x00	; 0
    1eca:	29 f0       	breq	.+10     	; 0x1ed6 <uxTaskPriorityGet+0x14>
    1ecc:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    1ece:	0f 90       	pop	r0
    1ed0:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    1ed2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ed4:	08 95       	ret

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1ed6:	e0 91 f2 19 	lds	r30, 0x19F2
    1eda:	f0 91 f3 19 	lds	r31, 0x19F3
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    1ede:	0f 90       	pop	r0
    1ee0:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    1ee2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ee4:	08 95       	ret

00001ee6 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    1ee6:	ef 92       	push	r14
    1ee8:	ff 92       	push	r15
    1eea:	1f 93       	push	r17
    1eec:	cf 93       	push	r28
    1eee:	df 93       	push	r29
    1ef0:	e6 2f       	mov	r30, r22
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1ef2:	64 30       	cpi	r22, 0x04	; 4
    1ef4:	08 f0       	brcs	.+2      	; 0x1ef8 <vTaskPrioritySet+0x12>
    1ef6:	e3 e0       	ldi	r30, 0x03	; 3
		if( uxNewPriority >= configMAX_PRIORITIES )
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
		}

		taskENTER_CRITICAL();
    1ef8:	0f b6       	in	r0, 0x3f	; 63
    1efa:	f8 94       	cli
    1efc:	0f 92       	push	r0
		{
			if( pxTask == pxCurrentTCB )
    1efe:	20 91 f2 19 	lds	r18, 0x19F2
    1f02:	30 91 f3 19 	lds	r19, 0x19F3
    1f06:	82 17       	cp	r24, r18
    1f08:	93 07       	cpc	r25, r19
    1f0a:	09 f4       	brne	.+2      	; 0x1f0e <vTaskPrioritySet+0x28>
    1f0c:	48 c0       	rjmp	.+144    	; 0x1f9e <vTaskPrioritySet+0xb8>
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1f0e:	00 97       	sbiw	r24, 0x00	; 0
    1f10:	09 f4       	brne	.+2      	; 0x1f14 <vTaskPrioritySet+0x2e>
    1f12:	45 c0       	rjmp	.+138    	; 0x1f9e <vTaskPrioritySet+0xb8>
    1f14:	ec 01       	movw	r28, r24

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
    1f16:	2f a1       	lds	r18, 0x4f
			{
				uxCurrentPriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    1f18:	2e 17       	cp	r18, r30
    1f1a:	71 f1       	breq	.+92     	; 0x1f78 <vTaskPrioritySet+0x92>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    1f1c:	11 e0       	ldi	r17, 0x01	; 1

			if( uxCurrentPriority != uxNewPriority )
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    1f1e:	2e 17       	cp	r18, r30
    1f20:	98 f5       	brcc	.+102    	; 0x1f88 <vTaskPrioritySet+0xa2>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    1f22:	00 97       	sbiw	r24, 0x00	; 0
    1f24:	99 f1       	breq	.+102    	; 0x1f8c <vTaskPrioritySet+0xa6>

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    1f26:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f28:	28 17       	cp	r18, r24
    1f2a:	a1 f1       	breq	.+104    	; 0x1f94 <vTaskPrioritySet+0xae>
					{
						pxTCB->uxPriority = uxNewPriority;
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    1f2c:	ef a3       	lds	r30, 0x5f
				{
					pxTCB->uxPriority = uxNewPriority;
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    1f2e:	44 e0       	ldi	r20, 0x04	; 4
    1f30:	50 e0       	ldi	r21, 0x00	; 0
    1f32:	60 e0       	ldi	r22, 0x00	; 0
    1f34:	70 e0       	ldi	r23, 0x00	; 0
    1f36:	4e 1b       	sub	r20, r30
    1f38:	51 09       	sbc	r21, r1
    1f3a:	61 09       	sbc	r22, r1
    1f3c:	71 09       	sbc	r23, r1
    1f3e:	4e 87       	std	Y+14, r20	; 0x0e
    1f40:	5f 87       	std	Y+15, r21	; 0x0f
    1f42:	68 8b       	std	Y+16, r22	; 0x10
    1f44:	79 8b       	std	Y+17, r23	; 0x11

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    1f46:	82 2f       	mov	r24, r18
    1f48:	90 e0       	ldi	r25, 0x00	; 0
    1f4a:	ac 01       	movw	r20, r24
    1f4c:	44 0f       	add	r20, r20
    1f4e:	55 1f       	adc	r21, r21
    1f50:	9c 01       	movw	r18, r24
    1f52:	22 0f       	add	r18, r18
    1f54:	33 1f       	adc	r19, r19
    1f56:	22 0f       	add	r18, r18
    1f58:	33 1f       	adc	r19, r19
    1f5a:	22 0f       	add	r18, r18
    1f5c:	33 1f       	adc	r19, r19
    1f5e:	42 0f       	add	r20, r18
    1f60:	53 1f       	adc	r21, r19
    1f62:	48 0f       	add	r20, r24
    1f64:	59 1f       	adc	r21, r25
    1f66:	4d 5f       	subi	r20, 0xFD	; 253
    1f68:	55 4e       	sbci	r21, 0xE5	; 229
    1f6a:	8c 85       	ldd	r24, Y+12	; 0x0c
    1f6c:	9d 85       	ldd	r25, Y+13	; 0x0d
    1f6e:	84 17       	cp	r24, r20
    1f70:	95 07       	cpc	r25, r21
    1f72:	e1 f0       	breq	.+56     	; 0x1fac <vTaskPrioritySet+0xc6>
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
				}

				if( xYieldRequired == pdTRUE )
    1f74:	11 30       	cpi	r17, 0x01	; 1
    1f76:	81 f0       	breq	.+32     	; 0x1f98 <vTaskPrioritySet+0xb2>
				{
					portYIELD_WITHIN_API();
				}
			}
		}
		taskEXIT_CRITICAL();
    1f78:	0f 90       	pop	r0
    1f7a:	0f be       	out	0x3f, r0	; 63
	}
    1f7c:	df 91       	pop	r29
    1f7e:	cf 91       	pop	r28
    1f80:	1f 91       	pop	r17
    1f82:	ff 90       	pop	r15
    1f84:	ef 90       	pop	r14
    1f86:	08 95       	ret
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    1f88:	00 97       	sbiw	r24, 0x00	; 0
    1f8a:	69 f2       	breq	.-102    	; 0x1f26 <vTaskPrioritySet+0x40>
    1f8c:	10 e0       	ldi	r17, 0x00	; 0

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    1f8e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f90:	28 17       	cp	r18, r24
    1f92:	61 f6       	brne	.-104    	; 0x1f2c <vTaskPrioritySet+0x46>
					{
						pxTCB->uxPriority = uxNewPriority;
    1f94:	ea 8f       	std	Y+26, r30	; 0x1a
    1f96:	ca cf       	rjmp	.-108    	; 0x1f2c <vTaskPrioritySet+0x46>
					prvAddTaskToReadyQueue( pxTCB );
				}

				if( xYieldRequired == pdTRUE )
				{
					portYIELD_WITHIN_API();
    1f98:	0e 94 a8 09 	call	0x1350	; 0x1350 <vPortYield>
    1f9c:	ed cf       	rjmp	.-38     	; 0x1f78 <vTaskPrioritySet+0x92>
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    1f9e:	c0 91 f2 19 	lds	r28, 0x19F2
    1fa2:	d0 91 f3 19 	lds	r29, 0x19F3
    1fa6:	80 e0       	ldi	r24, 0x00	; 0
    1fa8:	90 e0       	ldi	r25, 0x00	; 0
    1faa:	b5 cf       	rjmp	.-150    	; 0x1f16 <vTaskPrioritySet+0x30>
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    1fac:	82 e0       	ldi	r24, 0x02	; 2
    1fae:	e8 2e       	mov	r14, r24
    1fb0:	f1 2c       	mov	r15, r1
    1fb2:	ec 0e       	add	r14, r28
    1fb4:	fd 1e       	adc	r15, r29
    1fb6:	c7 01       	movw	r24, r14
    1fb8:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1fbc:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1fbe:	80 91 f9 19 	lds	r24, 0x19F9
    1fc2:	82 17       	cp	r24, r18
    1fc4:	10 f4       	brcc	.+4      	; 0x1fca <vTaskPrioritySet+0xe4>
    1fc6:	20 93 f9 19 	sts	0x19F9, r18
    1fca:	30 e0       	ldi	r19, 0x00	; 0
    1fcc:	c9 01       	movw	r24, r18
    1fce:	88 0f       	add	r24, r24
    1fd0:	99 1f       	adc	r25, r25
    1fd2:	a9 01       	movw	r20, r18
    1fd4:	44 0f       	add	r20, r20
    1fd6:	55 1f       	adc	r21, r21
    1fd8:	44 0f       	add	r20, r20
    1fda:	55 1f       	adc	r21, r21
    1fdc:	44 0f       	add	r20, r20
    1fde:	55 1f       	adc	r21, r21
    1fe0:	84 0f       	add	r24, r20
    1fe2:	95 1f       	adc	r25, r21
    1fe4:	82 0f       	add	r24, r18
    1fe6:	93 1f       	adc	r25, r19
    1fe8:	8d 5f       	subi	r24, 0xFD	; 253
    1fea:	95 4e       	sbci	r25, 0xE5	; 229
    1fec:	b7 01       	movw	r22, r14
    1fee:	0e 94 37 15 	call	0x2a6e	; 0x2a6e <vListInsertEnd>
    1ff2:	c0 cf       	rjmp	.-128    	; 0x1f74 <vTaskPrioritySet+0x8e>

00001ff4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1ff4:	af 92       	push	r10
    1ff6:	bf 92       	push	r11
    1ff8:	cf 92       	push	r12
    1ffa:	df 92       	push	r13
    1ffc:	ef 92       	push	r14
    1ffe:	ff 92       	push	r15
    2000:	0f 93       	push	r16
	/* Add the idle task at the lowest priority. */
	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
	{
		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
		be returned by the xTaskGetIdleTaskHandle() function. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
    2002:	81 ee       	ldi	r24, 0xE1	; 225
    2004:	9d e0       	ldi	r25, 0x0D	; 13
    2006:	60 e9       	ldi	r22, 0x90	; 144
    2008:	72 e0       	ldi	r23, 0x02	; 2
    200a:	44 e6       	ldi	r20, 0x64	; 100
    200c:	50 e0       	ldi	r21, 0x00	; 0
    200e:	20 e0       	ldi	r18, 0x00	; 0
    2010:	30 e0       	ldi	r19, 0x00	; 0
    2012:	00 e0       	ldi	r16, 0x00	; 0
    2014:	f2 e5       	ldi	r31, 0x52	; 82
    2016:	ef 2e       	mov	r14, r31
    2018:	fa e1       	ldi	r31, 0x1A	; 26
    201a:	ff 2e       	mov	r15, r31
    201c:	cc 24       	eor	r12, r12
    201e:	dd 24       	eor	r13, r13
    2020:	aa 24       	eor	r10, r10
    2022:	bb 24       	eor	r11, r11
    2024:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    2028:	81 30       	cpi	r24, 0x01	; 1
    202a:	41 f0       	breq	.+16     	; 0x203c <vTaskStartScheduler+0x48>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    202c:	0f 91       	pop	r16
    202e:	ff 90       	pop	r15
    2030:	ef 90       	pop	r14
    2032:	df 90       	pop	r13
    2034:	cf 90       	pop	r12
    2036:	bf 90       	pop	r11
    2038:	af 90       	pop	r10
    203a:	08 95       	ret
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    203c:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    203e:	80 93 f8 19 	sts	0x19F8, r24
		xTickCount = ( portTickType ) 0U;
    2042:	10 92 fa 19 	sts	0x19FA, r1
    2046:	10 92 fb 19 	sts	0x19FB, r1
    204a:	10 92 fc 19 	sts	0x19FC, r1
    204e:	10 92 fd 19 	sts	0x19FD, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2052:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    2056:	0f 91       	pop	r16
    2058:	ff 90       	pop	r15
    205a:	ef 90       	pop	r14
    205c:	df 90       	pop	r13
    205e:	cf 90       	pop	r12
    2060:	bf 90       	pop	r11
    2062:	af 90       	pop	r10
    2064:	08 95       	ret

00002066 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2066:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2068:	10 92 f8 19 	sts	0x19F8, r1
	vPortEndScheduler();
    206c:	0e 94 a7 09 	call	0x134e	; 0x134e <vPortEndScheduler>
}
    2070:	08 95       	ret

00002072 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2072:	80 91 f7 19 	lds	r24, 0x19F7
    2076:	8f 5f       	subi	r24, 0xFF	; 255
    2078:	80 93 f7 19 	sts	0x19F7, r24
}
    207c:	08 95       	ret

0000207e <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    207e:	0f 93       	push	r16
    2080:	1f 93       	push	r17
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2082:	0f b6       	in	r0, 0x3f	; 63
    2084:	f8 94       	cli
    2086:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2088:	00 91 fa 19 	lds	r16, 0x19FA
    208c:	10 91 fb 19 	lds	r17, 0x19FB
    2090:	20 91 fc 19 	lds	r18, 0x19FC
    2094:	30 91 fd 19 	lds	r19, 0x19FD
	}
	taskEXIT_CRITICAL();
    2098:	0f 90       	pop	r0
    209a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    209c:	b8 01       	movw	r22, r16
    209e:	c9 01       	movw	r24, r18
    20a0:	1f 91       	pop	r17
    20a2:	0f 91       	pop	r16
    20a4:	08 95       	ret

000020a6 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    20a6:	0f 93       	push	r16
    20a8:	1f 93       	push	r17
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    20aa:	00 91 fa 19 	lds	r16, 0x19FA
    20ae:	10 91 fb 19 	lds	r17, 0x19FB
    20b2:	20 91 fc 19 	lds	r18, 0x19FC
    20b6:	30 91 fd 19 	lds	r19, 0x19FD
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    20ba:	b8 01       	movw	r22, r16
    20bc:	c9 01       	movw	r24, r18
    20be:	1f 91       	pop	r17
    20c0:	0f 91       	pop	r16
    20c2:	08 95       	ret

000020c4 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    20c4:	80 91 fe 19 	lds	r24, 0x19FE
}
    20c8:	08 95       	ret

000020ca <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    20ca:	00 97       	sbiw	r24, 0x00	; 0
    20cc:	11 f0       	breq	.+4      	; 0x20d2 <pcTaskGetTaskName+0x8>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
    20ce:	4d 96       	adiw	r24, 0x1d	; 29
	}
    20d0:	08 95       	ret
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    20d2:	80 91 f2 19 	lds	r24, 0x19F2
    20d6:	90 91 f3 19 	lds	r25, 0x19F3
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
    20da:	4d 96       	adiw	r24, 0x1d	; 29
	}
    20dc:	08 95       	ret

000020de <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    20de:	80 91 52 1a 	lds	r24, 0x1A52
    20e2:	90 91 53 1a 	lds	r25, 0x1A53
    20e6:	08 95       	ret

000020e8 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    20e8:	0f 93       	push	r16
    20ea:	1f 93       	push	r17
    20ec:	cf 93       	push	r28
    20ee:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    20f0:	80 91 f7 19 	lds	r24, 0x19F7
    20f4:	88 23       	and	r24, r24
    20f6:	09 f0       	breq	.+2      	; 0x20fa <vTaskIncrementTick+0x12>
    20f8:	93 c0       	rjmp	.+294    	; 0x2220 <__stack+0x21>
	{
		++xTickCount;
    20fa:	80 91 fa 19 	lds	r24, 0x19FA
    20fe:	90 91 fb 19 	lds	r25, 0x19FB
    2102:	a0 91 fc 19 	lds	r26, 0x19FC
    2106:	b0 91 fd 19 	lds	r27, 0x19FD
    210a:	01 96       	adiw	r24, 0x01	; 1
    210c:	a1 1d       	adc	r26, r1
    210e:	b1 1d       	adc	r27, r1
    2110:	80 93 fa 19 	sts	0x19FA, r24
    2114:	90 93 fb 19 	sts	0x19FB, r25
    2118:	a0 93 fc 19 	sts	0x19FC, r26
    211c:	b0 93 fd 19 	sts	0x19FD, r27
		if( xTickCount == ( portTickType ) 0U )
    2120:	80 91 fa 19 	lds	r24, 0x19FA
    2124:	90 91 fb 19 	lds	r25, 0x19FB
    2128:	a0 91 fc 19 	lds	r26, 0x19FC
    212c:	b0 91 fd 19 	lds	r27, 0x19FD
    2130:	00 97       	sbiw	r24, 0x00	; 0
    2132:	a1 05       	cpc	r26, r1
    2134:	b1 05       	cpc	r27, r1
    2136:	09 f4       	brne	.+2      	; 0x213a <vTaskIncrementTick+0x52>
    2138:	7d c0       	rjmp	.+250    	; 0x2234 <__stack+0x35>
    213a:	80 91 95 02 	lds	r24, 0x0295
    213e:	90 91 96 02 	lds	r25, 0x0296
    2142:	a0 91 97 02 	lds	r26, 0x0297
    2146:	b0 91 98 02 	lds	r27, 0x0298
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    214a:	40 91 fa 19 	lds	r20, 0x19FA
    214e:	50 91 fb 19 	lds	r21, 0x19FB
    2152:	60 91 fc 19 	lds	r22, 0x19FC
    2156:	70 91 fd 19 	lds	r23, 0x19FD
    215a:	48 17       	cp	r20, r24
    215c:	59 07       	cpc	r21, r25
    215e:	6a 07       	cpc	r22, r26
    2160:	7b 07       	cpc	r23, r27
    2162:	08 f0       	brcs	.+2      	; 0x2166 <vTaskIncrementTick+0x7e>
    2164:	45 c0       	rjmp	.+138    	; 0x21f0 <vTaskIncrementTick+0x108>
    2166:	61 c0       	rjmp	.+194    	; 0x222a <__stack+0x2b>
    2168:	e0 91 01 1a 	lds	r30, 0x1A01
    216c:	f0 91 02 1a 	lds	r31, 0x1A02
    2170:	07 80       	ldd	r0, Z+7	; 0x07
    2172:	f0 85       	ldd	r31, Z+8	; 0x08
    2174:	e0 2d       	mov	r30, r0
    2176:	c0 85       	ldd	r28, Z+8	; 0x08
    2178:	d1 85       	ldd	r29, Z+9	; 0x09
    217a:	8a 81       	ldd	r24, Y+2	; 0x02
    217c:	9b 81       	ldd	r25, Y+3	; 0x03
    217e:	ac 81       	ldd	r26, Y+4	; 0x04
    2180:	bd 81       	ldd	r27, Y+5	; 0x05
    2182:	40 91 fa 19 	lds	r20, 0x19FA
    2186:	50 91 fb 19 	lds	r21, 0x19FB
    218a:	60 91 fc 19 	lds	r22, 0x19FC
    218e:	70 91 fd 19 	lds	r23, 0x19FD
    2192:	48 17       	cp	r20, r24
    2194:	59 07       	cpc	r21, r25
    2196:	6a 07       	cpc	r22, r26
    2198:	7b 07       	cpc	r23, r27
    219a:	08 f4       	brcc	.+2      	; 0x219e <vTaskIncrementTick+0xb6>
    219c:	8a c0       	rjmp	.+276    	; 0x22b2 <__stack+0xb3>
    219e:	8e 01       	movw	r16, r28
    21a0:	0e 5f       	subi	r16, 0xFE	; 254
    21a2:	1f 4f       	sbci	r17, 0xFF	; 255
    21a4:	c8 01       	movw	r24, r16
    21a6:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <vListRemove>
    21aa:	88 8d       	ldd	r24, Y+24	; 0x18
    21ac:	99 8d       	ldd	r25, Y+25	; 0x19
    21ae:	00 97       	sbiw	r24, 0x00	; 0
    21b0:	21 f0       	breq	.+8      	; 0x21ba <vTaskIncrementTick+0xd2>
    21b2:	ce 01       	movw	r24, r28
    21b4:	0e 96       	adiw	r24, 0x0e	; 14
    21b6:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <vListRemove>
    21ba:	2a 8d       	ldd	r18, Y+26	; 0x1a
    21bc:	80 91 f9 19 	lds	r24, 0x19F9
    21c0:	82 17       	cp	r24, r18
    21c2:	10 f4       	brcc	.+4      	; 0x21c8 <vTaskIncrementTick+0xe0>
    21c4:	20 93 f9 19 	sts	0x19F9, r18
    21c8:	30 e0       	ldi	r19, 0x00	; 0
    21ca:	c9 01       	movw	r24, r18
    21cc:	88 0f       	add	r24, r24
    21ce:	99 1f       	adc	r25, r25
    21d0:	a9 01       	movw	r20, r18
    21d2:	44 0f       	add	r20, r20
    21d4:	55 1f       	adc	r21, r21
    21d6:	44 0f       	add	r20, r20
    21d8:	55 1f       	adc	r21, r21
    21da:	44 0f       	add	r20, r20
    21dc:	55 1f       	adc	r21, r21
    21de:	84 0f       	add	r24, r20
    21e0:	95 1f       	adc	r25, r21
    21e2:	82 0f       	add	r24, r18
    21e4:	93 1f       	adc	r25, r19
    21e6:	8d 5f       	subi	r24, 0xFD	; 253
    21e8:	95 4e       	sbci	r25, 0xE5	; 229
    21ea:	b8 01       	movw	r22, r16
    21ec:	0e 94 37 15 	call	0x2a6e	; 0x2a6e <vListInsertEnd>
    21f0:	e0 91 01 1a 	lds	r30, 0x1A01
    21f4:	f0 91 02 1a 	lds	r31, 0x1A02
    21f8:	80 81       	ld	r24, Z
    21fa:	88 23       	and	r24, r24
    21fc:	09 f0       	breq	.+2      	; 0x2200 <__stack+0x1>
    21fe:	b4 cf       	rjmp	.-152    	; 0x2168 <vTaskIncrementTick+0x80>
    2200:	8f ef       	ldi	r24, 0xFF	; 255
    2202:	9f ef       	ldi	r25, 0xFF	; 255
    2204:	dc 01       	movw	r26, r24
    2206:	80 93 95 02 	sts	0x0295, r24
    220a:	90 93 96 02 	sts	0x0296, r25
    220e:	a0 93 97 02 	sts	0x0297, r26
    2212:	b0 93 98 02 	sts	0x0298, r27
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2216:	df 91       	pop	r29
    2218:	cf 91       	pop	r28
    221a:	1f 91       	pop	r17
    221c:	0f 91       	pop	r16
    221e:	08 95       	ret
		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
	}
	else
	{
		++uxMissedTicks;
    2220:	80 91 f6 19 	lds	r24, 0x19F6
    2224:	8f 5f       	subi	r24, 0xFF	; 255
    2226:	80 93 f6 19 	sts	0x19F6, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    222a:	df 91       	pop	r29
    222c:	cf 91       	pop	r28
    222e:	1f 91       	pop	r17
    2230:	0f 91       	pop	r16
    2232:	08 95       	ret
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2234:	80 91 01 1a 	lds	r24, 0x1A01
    2238:	90 91 02 1a 	lds	r25, 0x1A02
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    223c:	20 91 ff 19 	lds	r18, 0x19FF
    2240:	30 91 00 1a 	lds	r19, 0x1A00
    2244:	30 93 02 1a 	sts	0x1A02, r19
    2248:	20 93 01 1a 	sts	0x1A01, r18
			pxOverflowDelayedTaskList = pxTemp;
    224c:	90 93 00 1a 	sts	0x1A00, r25
    2250:	80 93 ff 19 	sts	0x19FF, r24
			xNumOfOverflows++;
    2254:	80 91 f4 19 	lds	r24, 0x19F4
    2258:	8f 5f       	subi	r24, 0xFF	; 255
    225a:	80 93 f4 19 	sts	0x19F4, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    225e:	e0 91 01 1a 	lds	r30, 0x1A01
    2262:	f0 91 02 1a 	lds	r31, 0x1A02
    2266:	80 81       	ld	r24, Z
    2268:	88 23       	and	r24, r24
    226a:	61 f4       	brne	.+24     	; 0x2284 <__stack+0x85>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    226c:	8f ef       	ldi	r24, 0xFF	; 255
    226e:	9f ef       	ldi	r25, 0xFF	; 255
    2270:	dc 01       	movw	r26, r24
    2272:	80 93 95 02 	sts	0x0295, r24
    2276:	90 93 96 02 	sts	0x0296, r25
    227a:	a0 93 97 02 	sts	0x0297, r26
    227e:	b0 93 98 02 	sts	0x0298, r27
    2282:	63 cf       	rjmp	.-314    	; 0x214a <vTaskIncrementTick+0x62>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2284:	e0 91 01 1a 	lds	r30, 0x1A01
    2288:	f0 91 02 1a 	lds	r31, 0x1A02
    228c:	07 80       	ldd	r0, Z+7	; 0x07
    228e:	f0 85       	ldd	r31, Z+8	; 0x08
    2290:	e0 2d       	mov	r30, r0
    2292:	00 84       	ldd	r0, Z+8	; 0x08
    2294:	f1 85       	ldd	r31, Z+9	; 0x09
    2296:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2298:	82 81       	ldd	r24, Z+2	; 0x02
    229a:	93 81       	ldd	r25, Z+3	; 0x03
    229c:	a4 81       	ldd	r26, Z+4	; 0x04
    229e:	b5 81       	ldd	r27, Z+5	; 0x05
    22a0:	80 93 95 02 	sts	0x0295, r24
    22a4:	90 93 96 02 	sts	0x0296, r25
    22a8:	a0 93 97 02 	sts	0x0297, r26
    22ac:	b0 93 98 02 	sts	0x0298, r27
    22b0:	4c cf       	rjmp	.-360    	; 0x214a <vTaskIncrementTick+0x62>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    22b2:	80 93 95 02 	sts	0x0295, r24
    22b6:	90 93 96 02 	sts	0x0296, r25
    22ba:	a0 93 97 02 	sts	0x0297, r26
    22be:	b0 93 98 02 	sts	0x0298, r27
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    22c2:	df 91       	pop	r29
    22c4:	cf 91       	pop	r28
    22c6:	1f 91       	pop	r17
    22c8:	0f 91       	pop	r16
    22ca:	08 95       	ret

000022cc <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    22cc:	ef 92       	push	r14
    22ce:	ff 92       	push	r15
    22d0:	0f 93       	push	r16
    22d2:	1f 93       	push	r17
    22d4:	cf 93       	push	r28
    22d6:	df 93       	push	r29
    22d8:	0f 92       	push	r0
    22da:	cd b7       	in	r28, 0x3d	; 61
    22dc:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    22de:	0f b6       	in	r0, 0x3f	; 63
    22e0:	f8 94       	cli
    22e2:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    22e4:	80 91 f7 19 	lds	r24, 0x19F7
    22e8:	81 50       	subi	r24, 0x01	; 1
    22ea:	80 93 f7 19 	sts	0x19F7, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    22ee:	80 91 f7 19 	lds	r24, 0x19F7
    22f2:	88 23       	and	r24, r24
    22f4:	09 f0       	breq	.+2      	; 0x22f8 <xTaskResumeAll+0x2c>
    22f6:	64 c0       	rjmp	.+200    	; 0x23c0 <xTaskResumeAll+0xf4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    22f8:	80 91 fe 19 	lds	r24, 0x19FE
    22fc:	88 23       	and	r24, r24
    22fe:	09 f4       	brne	.+2      	; 0x2302 <xTaskResumeAll+0x36>
    2300:	55 c0       	rjmp	.+170    	; 0x23ac <xTaskResumeAll+0xe0>
    2302:	19 82       	std	Y+1, r1	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2304:	80 91 45 1a 	lds	r24, 0x1A45
    2308:	88 23       	and	r24, r24
    230a:	09 f4       	brne	.+2      	; 0x230e <xTaskResumeAll+0x42>
    230c:	3f c0       	rjmp	.+126    	; 0x238c <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    230e:	e0 91 4c 1a 	lds	r30, 0x1A4C
    2312:	f0 91 4d 1a 	lds	r31, 0x1A4D
    2316:	e0 84       	ldd	r14, Z+8	; 0x08
    2318:	f1 84       	ldd	r15, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    231a:	c7 01       	movw	r24, r14
    231c:	0e 96       	adiw	r24, 0x0e	; 14
    231e:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2322:	87 01       	movw	r16, r14
    2324:	0e 5f       	subi	r16, 0xFE	; 254
    2326:	1f 4f       	sbci	r17, 0xFF	; 255
    2328:	c8 01       	movw	r24, r16
    232a:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    232e:	d7 01       	movw	r26, r14
    2330:	5a 96       	adiw	r26, 0x1a	; 26
    2332:	2c 91       	ld	r18, X
    2334:	5a 97       	sbiw	r26, 0x1a	; 26
    2336:	80 91 f9 19 	lds	r24, 0x19F9
    233a:	82 17       	cp	r24, r18
    233c:	10 f4       	brcc	.+4      	; 0x2342 <xTaskResumeAll+0x76>
    233e:	20 93 f9 19 	sts	0x19F9, r18
    2342:	30 e0       	ldi	r19, 0x00	; 0
    2344:	c9 01       	movw	r24, r18
    2346:	88 0f       	add	r24, r24
    2348:	99 1f       	adc	r25, r25
    234a:	a9 01       	movw	r20, r18
    234c:	44 0f       	add	r20, r20
    234e:	55 1f       	adc	r21, r21
    2350:	44 0f       	add	r20, r20
    2352:	55 1f       	adc	r21, r21
    2354:	44 0f       	add	r20, r20
    2356:	55 1f       	adc	r21, r21
    2358:	84 0f       	add	r24, r20
    235a:	95 1f       	adc	r25, r21
    235c:	82 0f       	add	r24, r18
    235e:	93 1f       	adc	r25, r19
    2360:	8d 5f       	subi	r24, 0xFD	; 253
    2362:	95 4e       	sbci	r25, 0xE5	; 229
    2364:	b8 01       	movw	r22, r16
    2366:	0e 94 37 15 	call	0x2a6e	; 0x2a6e <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    236a:	e0 91 f2 19 	lds	r30, 0x19F2
    236e:	f0 91 f3 19 	lds	r31, 0x19F3
    2372:	d7 01       	movw	r26, r14
    2374:	5a 96       	adiw	r26, 0x1a	; 26
    2376:	9c 91       	ld	r25, X
    2378:	5a 97       	sbiw	r26, 0x1a	; 26
    237a:	82 8d       	ldd	r24, Z+26	; 0x1a
    237c:	98 17       	cp	r25, r24
    237e:	10 f2       	brcs	.-124    	; 0x2304 <xTaskResumeAll+0x38>
					{
						xYieldRequired = pdTRUE;
    2380:	b1 e0       	ldi	r27, 0x01	; 1
    2382:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2384:	80 91 45 1a 	lds	r24, 0x1A45
    2388:	88 23       	and	r24, r24
    238a:	09 f6       	brne	.-126    	; 0x230e <xTaskResumeAll+0x42>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    238c:	80 91 f6 19 	lds	r24, 0x19F6
    2390:	88 23       	and	r24, r24
    2392:	c1 f4       	brne	.+48     	; 0x23c4 <xTaskResumeAll+0xf8>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2394:	e9 81       	ldd	r30, Y+1	; 0x01
    2396:	e1 30       	cpi	r30, 0x01	; 1
    2398:	21 f0       	breq	.+8      	; 0x23a2 <xTaskResumeAll+0xd6>
    239a:	80 91 f5 19 	lds	r24, 0x19F5
    239e:	81 30       	cpi	r24, 0x01	; 1
    23a0:	79 f4       	brne	.+30     	; 0x23c0 <xTaskResumeAll+0xf4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    23a2:	10 92 f5 19 	sts	0x19F5, r1
					portYIELD_WITHIN_API();
    23a6:	0e 94 a8 09 	call	0x1350	; 0x1350 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    23aa:	81 e0       	ldi	r24, 0x01	; 1
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    23ac:	0f 90       	pop	r0
    23ae:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    23b0:	0f 90       	pop	r0
    23b2:	df 91       	pop	r29
    23b4:	cf 91       	pop	r28
    23b6:	1f 91       	pop	r17
    23b8:	0f 91       	pop	r16
    23ba:	ff 90       	pop	r15
    23bc:	ef 90       	pop	r14
    23be:	08 95       	ret
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    23c0:	80 e0       	ldi	r24, 0x00	; 0
    23c2:	f4 cf       	rjmp	.-24     	; 0x23ac <xTaskResumeAll+0xe0>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    23c4:	80 91 f6 19 	lds	r24, 0x19F6
    23c8:	88 23       	and	r24, r24
    23ca:	59 f3       	breq	.-42     	; 0x23a2 <xTaskResumeAll+0xd6>
					{
						vTaskIncrementTick();
    23cc:	0e 94 74 10 	call	0x20e8	; 0x20e8 <vTaskIncrementTick>
						--uxMissedTicks;
    23d0:	80 91 f6 19 	lds	r24, 0x19F6
    23d4:	81 50       	subi	r24, 0x01	; 1
    23d6:	80 93 f6 19 	sts	0x19F6, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    23da:	80 91 f6 19 	lds	r24, 0x19F6
    23de:	88 23       	and	r24, r24
    23e0:	a9 f7       	brne	.-22     	; 0x23cc <xTaskResumeAll+0x100>
    23e2:	df cf       	rjmp	.-66     	; 0x23a2 <xTaskResumeAll+0xd6>

000023e4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    23e4:	cf 92       	push	r12
    23e6:	df 92       	push	r13
    23e8:	ef 92       	push	r14
    23ea:	ff 92       	push	r15
    23ec:	dc 01       	movw	r26, r24
    23ee:	cb 01       	movw	r24, r22
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    23f0:	00 97       	sbiw	r24, 0x00	; 0
    23f2:	a1 05       	cpc	r26, r1
    23f4:	b1 05       	cpc	r27, r1
    23f6:	39 f4       	brne	.+14     	; 0x2406 <vTaskDelay+0x22>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
    23f8:	0e 94 a8 09 	call	0x1350	; 0x1350 <vPortYield>
		}
	}
    23fc:	ff 90       	pop	r15
    23fe:	ef 90       	pop	r14
    2400:	df 90       	pop	r13
    2402:	cf 90       	pop	r12
    2404:	08 95       	ret

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2406:	20 91 f7 19 	lds	r18, 0x19F7
    240a:	2f 5f       	subi	r18, 0xFF	; 255
    240c:	20 93 f7 19 	sts	0x19F7, r18
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2410:	c0 90 fa 19 	lds	r12, 0x19FA
    2414:	d0 90 fb 19 	lds	r13, 0x19FB
    2418:	e0 90 fc 19 	lds	r14, 0x19FC
    241c:	f0 90 fd 19 	lds	r15, 0x19FD
    2420:	c8 0e       	add	r12, r24
    2422:	d9 1e       	adc	r13, r25
    2424:	ea 1e       	adc	r14, r26
    2426:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2428:	80 91 f2 19 	lds	r24, 0x19F2
    242c:	90 91 f3 19 	lds	r25, 0x19F3
    2430:	02 96       	adiw	r24, 0x02	; 2
    2432:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2436:	c7 01       	movw	r24, r14
    2438:	b6 01       	movw	r22, r12
    243a:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    243e:	0e 94 66 11 	call	0x22cc	; 0x22cc <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2442:	88 23       	and	r24, r24
    2444:	c9 f2       	breq	.-78     	; 0x23f8 <vTaskDelay+0x14>
		{
			portYIELD_WITHIN_API();
		}
	}
    2446:	ff 90       	pop	r15
    2448:	ef 90       	pop	r14
    244a:	df 90       	pop	r13
    244c:	cf 90       	pop	r12
    244e:	08 95       	ret

00002450 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2450:	cf 92       	push	r12
    2452:	df 92       	push	r13
    2454:	ef 92       	push	r14
    2456:	ff 92       	push	r15
    2458:	fc 01       	movw	r30, r24
    245a:	6a 01       	movw	r12, r20
    245c:	7b 01       	movw	r14, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    245e:	80 91 f7 19 	lds	r24, 0x19F7
    2462:	8f 5f       	subi	r24, 0xFF	; 255
    2464:	80 93 f7 19 	sts	0x19F7, r24
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2468:	80 81       	ld	r24, Z
    246a:	91 81       	ldd	r25, Z+1	; 0x01
    246c:	a2 81       	ldd	r26, Z+2	; 0x02
    246e:	b3 81       	ldd	r27, Z+3	; 0x03
    2470:	c8 0e       	add	r12, r24
    2472:	d9 1e       	adc	r13, r25
    2474:	ea 1e       	adc	r14, r26
    2476:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2478:	40 91 fa 19 	lds	r20, 0x19FA
    247c:	50 91 fb 19 	lds	r21, 0x19FB
    2480:	60 91 fc 19 	lds	r22, 0x19FC
    2484:	70 91 fd 19 	lds	r23, 0x19FD
    2488:	48 17       	cp	r20, r24
    248a:	59 07       	cpc	r21, r25
    248c:	6a 07       	cpc	r22, r26
    248e:	7b 07       	cpc	r23, r27
    2490:	60 f5       	brcc	.+88     	; 0x24ea <vTaskDelayUntil+0x9a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2492:	c8 16       	cp	r12, r24
    2494:	d9 06       	cpc	r13, r25
    2496:	ea 06       	cpc	r14, r26
    2498:	fb 06       	cpc	r15, r27
    249a:	68 f5       	brcc	.+90     	; 0x24f6 <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    249c:	80 91 fa 19 	lds	r24, 0x19FA
    24a0:	90 91 fb 19 	lds	r25, 0x19FB
    24a4:	a0 91 fc 19 	lds	r26, 0x19FC
    24a8:	b0 91 fd 19 	lds	r27, 0x19FD
    24ac:	8c 15       	cp	r24, r12
    24ae:	9d 05       	cpc	r25, r13
    24b0:	ae 05       	cpc	r26, r14
    24b2:	bf 05       	cpc	r27, r15
    24b4:	00 f5       	brcc	.+64     	; 0x24f6 <vTaskDelayUntil+0xa6>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    24b6:	c0 82       	st	Z, r12
    24b8:	d1 82       	std	Z+1, r13	; 0x01
    24ba:	e2 82       	std	Z+2, r14	; 0x02
    24bc:	f3 82       	std	Z+3, r15	; 0x03
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24be:	80 91 f2 19 	lds	r24, 0x19F2
    24c2:	90 91 f3 19 	lds	r25, 0x19F3
    24c6:	02 96       	adiw	r24, 0x02	; 2
    24c8:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    24cc:	c7 01       	movw	r24, r14
    24ce:	b6 01       	movw	r22, r12
    24d0:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    24d4:	0e 94 66 11 	call	0x22cc	; 0x22cc <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    24d8:	88 23       	and	r24, r24
    24da:	11 f4       	brne	.+4      	; 0x24e0 <vTaskDelayUntil+0x90>
		{
			portYIELD_WITHIN_API();
    24dc:	0e 94 a8 09 	call	0x1350	; 0x1350 <vPortYield>
		}
	}
    24e0:	ff 90       	pop	r15
    24e2:	ef 90       	pop	r14
    24e4:	df 90       	pop	r13
    24e6:	cf 90       	pop	r12
    24e8:	08 95       	ret
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    24ea:	c8 16       	cp	r12, r24
    24ec:	d9 06       	cpc	r13, r25
    24ee:	ea 06       	cpc	r14, r26
    24f0:	fb 06       	cpc	r15, r27
    24f2:	08 f3       	brcs	.-62     	; 0x24b6 <vTaskDelayUntil+0x66>
    24f4:	d3 cf       	rjmp	.-90     	; 0x249c <vTaskDelayUntil+0x4c>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    24f6:	c0 82       	st	Z, r12
    24f8:	d1 82       	std	Z+1, r13	; 0x01
    24fa:	e2 82       	std	Z+2, r14	; 0x02
    24fc:	f3 82       	std	Z+3, r15	; 0x03
    24fe:	ea cf       	rjmp	.-44     	; 0x24d4 <vTaskDelayUntil+0x84>

00002500 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2500:	80 91 f7 19 	lds	r24, 0x19F7
    2504:	88 23       	and	r24, r24
    2506:	31 f0       	breq	.+12     	; 0x2514 <vTaskSwitchContext+0x14>
    2508:	44 c0       	rjmp	.+136    	; 0x2592 <vTaskSwitchContext+0x92>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    250a:	80 91 f9 19 	lds	r24, 0x19F9
    250e:	81 50       	subi	r24, 0x01	; 1
    2510:	80 93 f9 19 	sts	0x19F9, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2514:	80 91 f9 19 	lds	r24, 0x19F9
    2518:	90 e0       	ldi	r25, 0x00	; 0
    251a:	fc 01       	movw	r30, r24
    251c:	ee 0f       	add	r30, r30
    251e:	ff 1f       	adc	r31, r31
    2520:	9c 01       	movw	r18, r24
    2522:	22 0f       	add	r18, r18
    2524:	33 1f       	adc	r19, r19
    2526:	22 0f       	add	r18, r18
    2528:	33 1f       	adc	r19, r19
    252a:	22 0f       	add	r18, r18
    252c:	33 1f       	adc	r19, r19
    252e:	e2 0f       	add	r30, r18
    2530:	f3 1f       	adc	r31, r19
    2532:	e8 0f       	add	r30, r24
    2534:	f9 1f       	adc	r31, r25
    2536:	ed 5f       	subi	r30, 0xFD	; 253
    2538:	f5 4e       	sbci	r31, 0xE5	; 229
    253a:	80 81       	ld	r24, Z
    253c:	88 23       	and	r24, r24
    253e:	29 f3       	breq	.-54     	; 0x250a <vTaskSwitchContext+0xa>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2540:	80 91 f9 19 	lds	r24, 0x19F9
    2544:	90 e0       	ldi	r25, 0x00	; 0
    2546:	fc 01       	movw	r30, r24
    2548:	ee 0f       	add	r30, r30
    254a:	ff 1f       	adc	r31, r31
    254c:	9c 01       	movw	r18, r24
    254e:	22 0f       	add	r18, r18
    2550:	33 1f       	adc	r19, r19
    2552:	22 0f       	add	r18, r18
    2554:	33 1f       	adc	r19, r19
    2556:	22 0f       	add	r18, r18
    2558:	33 1f       	adc	r19, r19
    255a:	e2 0f       	add	r30, r18
    255c:	f3 1f       	adc	r31, r19
    255e:	e8 0f       	add	r30, r24
    2560:	f9 1f       	adc	r31, r25
    2562:	ed 5f       	subi	r30, 0xFD	; 253
    2564:	f5 4e       	sbci	r31, 0xE5	; 229
    2566:	a1 81       	ldd	r26, Z+1	; 0x01
    2568:	b2 81       	ldd	r27, Z+2	; 0x02
    256a:	14 96       	adiw	r26, 0x04	; 4
    256c:	0d 90       	ld	r0, X+
    256e:	bc 91       	ld	r27, X
    2570:	a0 2d       	mov	r26, r0
    2572:	b2 83       	std	Z+2, r27	; 0x02
    2574:	a1 83       	std	Z+1, r26	; 0x01
    2576:	cf 01       	movw	r24, r30
    2578:	03 96       	adiw	r24, 0x03	; 3
    257a:	a8 17       	cp	r26, r24
    257c:	b9 07       	cpc	r27, r25
    257e:	69 f0       	breq	.+26     	; 0x259a <vTaskSwitchContext+0x9a>
    2580:	18 96       	adiw	r26, 0x08	; 8
    2582:	8d 91       	ld	r24, X+
    2584:	9c 91       	ld	r25, X
    2586:	19 97       	sbiw	r26, 0x09	; 9
    2588:	90 93 f3 19 	sts	0x19F3, r25
    258c:	80 93 f2 19 	sts	0x19F2, r24
    2590:	08 95       	ret
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2592:	81 e0       	ldi	r24, 0x01	; 1
    2594:	80 93 f5 19 	sts	0x19F5, r24
    2598:	08 95       	ret
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    259a:	14 96       	adiw	r26, 0x04	; 4
    259c:	0d 90       	ld	r0, X+
    259e:	bc 91       	ld	r27, X
    25a0:	a0 2d       	mov	r26, r0
    25a2:	b2 83       	std	Z+2, r27	; 0x02
    25a4:	a1 83       	std	Z+1, r26	; 0x01
    25a6:	ec cf       	rjmp	.-40     	; 0x2580 <vTaskSwitchContext+0x80>

000025a8 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    25a8:	cf 92       	push	r12
    25aa:	df 92       	push	r13
    25ac:	ef 92       	push	r14
    25ae:	ff 92       	push	r15
    25b0:	6a 01       	movw	r12, r20
    25b2:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    25b4:	60 91 f2 19 	lds	r22, 0x19F2
    25b8:	70 91 f3 19 	lds	r23, 0x19F3
    25bc:	62 5f       	subi	r22, 0xF2	; 242
    25be:	7f 4f       	sbci	r23, 0xFF	; 255
    25c0:	0e 94 5e 15 	call	0x2abc	; 0x2abc <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25c4:	80 91 f2 19 	lds	r24, 0x19F2
    25c8:	90 91 f3 19 	lds	r25, 0x19F3
    25cc:	02 96       	adiw	r24, 0x02	; 2
    25ce:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    25d2:	80 91 fa 19 	lds	r24, 0x19FA
    25d6:	90 91 fb 19 	lds	r25, 0x19FB
    25da:	a0 91 fc 19 	lds	r26, 0x19FC
    25de:	b0 91 fd 19 	lds	r27, 0x19FD
    25e2:	8c 0d       	add	r24, r12
    25e4:	9d 1d       	adc	r25, r13
    25e6:	ae 1d       	adc	r26, r14
    25e8:	bf 1d       	adc	r27, r15
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    25ea:	bc 01       	movw	r22, r24
    25ec:	cd 01       	movw	r24, r26
    25ee:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    25f2:	ff 90       	pop	r15
    25f4:	ef 90       	pop	r14
    25f6:	df 90       	pop	r13
    25f8:	cf 90       	pop	r12
    25fa:	08 95       	ret

000025fc <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    25fc:	0f 93       	push	r16
    25fe:	1f 93       	push	r17
    2600:	cf 93       	push	r28
    2602:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2604:	dc 01       	movw	r26, r24
    2606:	17 96       	adiw	r26, 0x07	; 7
    2608:	ed 91       	ld	r30, X+
    260a:	fc 91       	ld	r31, X
    260c:	18 97       	sbiw	r26, 0x08	; 8
    260e:	00 85       	ldd	r16, Z+8	; 0x08
    2610:	11 85       	ldd	r17, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2612:	e8 01       	movw	r28, r16
    2614:	2e 96       	adiw	r28, 0x0e	; 14
    2616:	ce 01       	movw	r24, r28
    2618:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    261c:	80 91 f7 19 	lds	r24, 0x19F7
    2620:	88 23       	and	r24, r24
    2622:	89 f5       	brne	.+98     	; 0x2686 <xTaskRemoveFromEventList+0x8a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2624:	e8 01       	movw	r28, r16
    2626:	22 96       	adiw	r28, 0x02	; 2
    2628:	ce 01       	movw	r24, r28
    262a:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    262e:	f8 01       	movw	r30, r16
    2630:	22 8d       	ldd	r18, Z+26	; 0x1a
    2632:	80 91 f9 19 	lds	r24, 0x19F9
    2636:	82 17       	cp	r24, r18
    2638:	60 f1       	brcs	.+88     	; 0x2692 <xTaskRemoveFromEventList+0x96>
    263a:	30 e0       	ldi	r19, 0x00	; 0
    263c:	c9 01       	movw	r24, r18
    263e:	88 0f       	add	r24, r24
    2640:	99 1f       	adc	r25, r25
    2642:	a9 01       	movw	r20, r18
    2644:	44 0f       	add	r20, r20
    2646:	55 1f       	adc	r21, r21
    2648:	44 0f       	add	r20, r20
    264a:	55 1f       	adc	r21, r21
    264c:	44 0f       	add	r20, r20
    264e:	55 1f       	adc	r21, r21
    2650:	84 0f       	add	r24, r20
    2652:	95 1f       	adc	r25, r21
    2654:	82 0f       	add	r24, r18
    2656:	93 1f       	adc	r25, r19
    2658:	8d 5f       	subi	r24, 0xFD	; 253
    265a:	95 4e       	sbci	r25, 0xE5	; 229
    265c:	be 01       	movw	r22, r28
    265e:	0e 94 37 15 	call	0x2a6e	; 0x2a6e <vListInsertEnd>
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2662:	e0 91 f2 19 	lds	r30, 0x19F2
    2666:	f0 91 f3 19 	lds	r31, 0x19F3
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    266a:	81 e0       	ldi	r24, 0x01	; 1
    266c:	d8 01       	movw	r26, r16
    266e:	5a 96       	adiw	r26, 0x1a	; 26
    2670:	2c 91       	ld	r18, X
    2672:	5a 97       	sbiw	r26, 0x1a	; 26
    2674:	92 8d       	ldd	r25, Z+26	; 0x1a
    2676:	29 17       	cp	r18, r25
    2678:	08 f4       	brcc	.+2      	; 0x267c <xTaskRemoveFromEventList+0x80>
    267a:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    267c:	df 91       	pop	r29
    267e:	cf 91       	pop	r28
    2680:	1f 91       	pop	r17
    2682:	0f 91       	pop	r16
    2684:	08 95       	ret
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2686:	85 e4       	ldi	r24, 0x45	; 69
    2688:	9a e1       	ldi	r25, 0x1A	; 26
    268a:	be 01       	movw	r22, r28
    268c:	0e 94 37 15 	call	0x2a6e	; 0x2a6e <vListInsertEnd>
    2690:	e8 cf       	rjmp	.-48     	; 0x2662 <xTaskRemoveFromEventList+0x66>
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2692:	20 93 f9 19 	sts	0x19F9, r18
    2696:	d1 cf       	rjmp	.-94     	; 0x263a <xTaskRemoveFromEventList+0x3e>

00002698 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2698:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    269a:	80 91 f4 19 	lds	r24, 0x19F4
    269e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    26a0:	40 91 fa 19 	lds	r20, 0x19FA
    26a4:	50 91 fb 19 	lds	r21, 0x19FB
    26a8:	60 91 fc 19 	lds	r22, 0x19FC
    26ac:	70 91 fd 19 	lds	r23, 0x19FD
    26b0:	41 83       	std	Z+1, r20	; 0x01
    26b2:	52 83       	std	Z+2, r21	; 0x02
    26b4:	63 83       	std	Z+3, r22	; 0x03
    26b6:	74 83       	std	Z+4, r23	; 0x04
}
    26b8:	08 95       	ret

000026ba <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    26ba:	0f 93       	push	r16
    26bc:	1f 93       	push	r17
    26be:	cf 93       	push	r28
    26c0:	df 93       	push	r29
    26c2:	fc 01       	movw	r30, r24
    26c4:	eb 01       	movw	r28, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    26c6:	0f b6       	in	r0, 0x3f	; 63
    26c8:	f8 94       	cli
    26ca:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    26cc:	80 91 f4 19 	lds	r24, 0x19F4
    26d0:	90 81       	ld	r25, Z
    26d2:	98 17       	cp	r25, r24
    26d4:	09 f4       	brne	.+2      	; 0x26d8 <xTaskCheckForTimeOut+0x1e>
    26d6:	53 c0       	rjmp	.+166    	; 0x277e <xTaskCheckForTimeOut+0xc4>
    26d8:	81 81       	ldd	r24, Z+1	; 0x01
    26da:	92 81       	ldd	r25, Z+2	; 0x02
    26dc:	a3 81       	ldd	r26, Z+3	; 0x03
    26de:	b4 81       	ldd	r27, Z+4	; 0x04
    26e0:	40 91 fa 19 	lds	r20, 0x19FA
    26e4:	50 91 fb 19 	lds	r21, 0x19FB
    26e8:	60 91 fc 19 	lds	r22, 0x19FC
    26ec:	70 91 fd 19 	lds	r23, 0x19FD
    26f0:	48 17       	cp	r20, r24
    26f2:	59 07       	cpc	r21, r25
    26f4:	6a 07       	cpc	r22, r26
    26f6:	7b 07       	cpc	r23, r27
    26f8:	d0 f5       	brcc	.+116    	; 0x276e <xTaskCheckForTimeOut+0xb4>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    26fa:	40 91 fa 19 	lds	r20, 0x19FA
    26fe:	50 91 fb 19 	lds	r21, 0x19FB
    2702:	60 91 fc 19 	lds	r22, 0x19FC
    2706:	70 91 fd 19 	lds	r23, 0x19FD
    270a:	08 81       	ld	r16, Y
    270c:	19 81       	ldd	r17, Y+1	; 0x01
    270e:	2a 81       	ldd	r18, Y+2	; 0x02
    2710:	3b 81       	ldd	r19, Y+3	; 0x03
    2712:	48 1b       	sub	r20, r24
    2714:	59 0b       	sbc	r21, r25
    2716:	6a 0b       	sbc	r22, r26
    2718:	7b 0b       	sbc	r23, r27
    271a:	40 17       	cp	r20, r16
    271c:	51 07       	cpc	r21, r17
    271e:	62 07       	cpc	r22, r18
    2720:	73 07       	cpc	r23, r19
    2722:	28 f5       	brcc	.+74     	; 0x276e <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2724:	40 91 fa 19 	lds	r20, 0x19FA
    2728:	50 91 fb 19 	lds	r21, 0x19FB
    272c:	60 91 fc 19 	lds	r22, 0x19FC
    2730:	70 91 fd 19 	lds	r23, 0x19FD
    2734:	04 1b       	sub	r16, r20
    2736:	15 0b       	sbc	r17, r21
    2738:	26 0b       	sbc	r18, r22
    273a:	37 0b       	sbc	r19, r23
    273c:	08 0f       	add	r16, r24
    273e:	19 1f       	adc	r17, r25
    2740:	2a 1f       	adc	r18, r26
    2742:	3b 1f       	adc	r19, r27
    2744:	08 83       	st	Y, r16
    2746:	19 83       	std	Y+1, r17	; 0x01
    2748:	2a 83       	std	Y+2, r18	; 0x02
    274a:	3b 83       	std	Y+3, r19	; 0x03
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    274c:	80 91 f4 19 	lds	r24, 0x19F4
    2750:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2752:	80 91 fa 19 	lds	r24, 0x19FA
    2756:	90 91 fb 19 	lds	r25, 0x19FB
    275a:	a0 91 fc 19 	lds	r26, 0x19FC
    275e:	b0 91 fd 19 	lds	r27, 0x19FD
    2762:	81 83       	std	Z+1, r24	; 0x01
    2764:	92 83       	std	Z+2, r25	; 0x02
    2766:	a3 83       	std	Z+3, r26	; 0x03
    2768:	b4 83       	std	Z+4, r27	; 0x04
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
    276a:	80 e0       	ldi	r24, 0x00	; 0
    276c:	01 c0       	rjmp	.+2      	; 0x2770 <xTaskCheckForTimeOut+0xb6>
		}
		else
		{
			xReturn = pdTRUE;
    276e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2770:	0f 90       	pop	r0
    2772:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2774:	df 91       	pop	r29
    2776:	cf 91       	pop	r28
    2778:	1f 91       	pop	r17
    277a:	0f 91       	pop	r16
    277c:	08 95       	ret
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    277e:	81 81       	ldd	r24, Z+1	; 0x01
    2780:	92 81       	ldd	r25, Z+2	; 0x02
    2782:	a3 81       	ldd	r26, Z+3	; 0x03
    2784:	b4 81       	ldd	r27, Z+4	; 0x04
    2786:	b9 cf       	rjmp	.-142    	; 0x26fa <xTaskCheckForTimeOut+0x40>

00002788 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2788:	81 e0       	ldi	r24, 0x01	; 1
    278a:	80 93 f5 19 	sts	0x19F5, r24
}
    278e:	08 95       	ret

00002790 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2790:	00 97       	sbiw	r24, 0x00	; 0
    2792:	79 f0       	breq	.+30     	; 0x27b2 <uxTaskGetStackHighWaterMark+0x22>
    2794:	fc 01       	movw	r30, r24

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2796:	03 8c       	ldd	r0, Z+27	; 0x1b
    2798:	f4 8d       	ldd	r31, Z+28	; 0x1c
    279a:	e0 2d       	mov	r30, r0

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    279c:	80 81       	ld	r24, Z
    279e:	81 31       	cpi	r24, 0x11	; 17
    27a0:	69 f4       	brne	.+26     	; 0x27bc <uxTaskGetStackHighWaterMark+0x2c>
#endif
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
    27a2:	31 96       	adiw	r30, 0x01	; 1

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    27a4:	80 e0       	ldi	r24, 0x00	; 0
    27a6:	90 e0       	ldi	r25, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    27a8:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27aa:	21 91       	ld	r18, Z+
    27ac:	21 31       	cpi	r18, 0x11	; 17
    27ae:	e1 f3       	breq	.-8      	; 0x27a8 <uxTaskGetStackHighWaterMark+0x18>
    27b0:	08 95       	ret
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    27b2:	e0 91 f2 19 	lds	r30, 0x19F2
    27b6:	f0 91 f3 19 	lds	r31, 0x19F3
    27ba:	ed cf       	rjmp	.-38     	; 0x2796 <uxTaskGetStackHighWaterMark+0x6>

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    27bc:	80 e0       	ldi	r24, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    27be:	08 95       	ret

000027c0 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    27c0:	80 91 f2 19 	lds	r24, 0x19F2
    27c4:	90 91 f3 19 	lds	r25, 0x19F3

		return xReturn;
	}
    27c8:	08 95       	ret

000027ca <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    27ca:	0f 93       	push	r16
    27cc:	1f 93       	push	r17
    27ce:	cf 93       	push	r28
    27d0:	df 93       	push	r29
    27d2:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    27d4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    27d6:	e0 91 f2 19 	lds	r30, 0x19F2
    27da:	f0 91 f3 19 	lds	r31, 0x19F3
    27de:	92 8d       	ldd	r25, Z+26	; 0x1a
    27e0:	89 17       	cp	r24, r25
    27e2:	68 f5       	brcc	.+90     	; 0x283e <vTaskPriorityInherit+0x74>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    27e4:	e0 91 f2 19 	lds	r30, 0x19F2
    27e8:	f0 91 f3 19 	lds	r31, 0x19F3
    27ec:	92 8d       	ldd	r25, Z+26	; 0x1a
    27ee:	44 e0       	ldi	r20, 0x04	; 4
    27f0:	50 e0       	ldi	r21, 0x00	; 0
    27f2:	60 e0       	ldi	r22, 0x00	; 0
    27f4:	70 e0       	ldi	r23, 0x00	; 0
    27f6:	49 1b       	sub	r20, r25
    27f8:	51 09       	sbc	r21, r1
    27fa:	61 09       	sbc	r22, r1
    27fc:	71 09       	sbc	r23, r1
    27fe:	4e 87       	std	Y+14, r20	; 0x0e
    2800:	5f 87       	std	Y+15, r21	; 0x0f
    2802:	68 8b       	std	Y+16, r22	; 0x10
    2804:	79 8b       	std	Y+17, r23	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2806:	90 e0       	ldi	r25, 0x00	; 0
    2808:	ac 01       	movw	r20, r24
    280a:	44 0f       	add	r20, r20
    280c:	55 1f       	adc	r21, r21
    280e:	9c 01       	movw	r18, r24
    2810:	22 0f       	add	r18, r18
    2812:	33 1f       	adc	r19, r19
    2814:	22 0f       	add	r18, r18
    2816:	33 1f       	adc	r19, r19
    2818:	22 0f       	add	r18, r18
    281a:	33 1f       	adc	r19, r19
    281c:	42 0f       	add	r20, r18
    281e:	53 1f       	adc	r21, r19
    2820:	48 0f       	add	r20, r24
    2822:	59 1f       	adc	r21, r25
    2824:	4d 5f       	subi	r20, 0xFD	; 253
    2826:	55 4e       	sbci	r21, 0xE5	; 229
    2828:	8c 85       	ldd	r24, Y+12	; 0x0c
    282a:	9d 85       	ldd	r25, Y+13	; 0x0d
    282c:	84 17       	cp	r24, r20
    282e:	95 07       	cpc	r25, r21
    2830:	59 f0       	breq	.+22     	; 0x2848 <vTaskPriorityInherit+0x7e>
				prvAddTaskToReadyQueue( pxTCB );
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2832:	e0 91 f2 19 	lds	r30, 0x19F2
    2836:	f0 91 f3 19 	lds	r31, 0x19F3
    283a:	82 8d       	ldd	r24, Z+26	; 0x1a
    283c:	8a 8f       	std	Y+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    283e:	df 91       	pop	r29
    2840:	cf 91       	pop	r28
    2842:	1f 91       	pop	r17
    2844:	0f 91       	pop	r16
    2846:	08 95       	ret

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2848:	8e 01       	movw	r16, r28
    284a:	0e 5f       	subi	r16, 0xFE	; 254
    284c:	1f 4f       	sbci	r17, 0xFF	; 255
    284e:	c8 01       	movw	r24, r16
    2850:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2854:	e0 91 f2 19 	lds	r30, 0x19F2
    2858:	f0 91 f3 19 	lds	r31, 0x19F3
    285c:	22 8d       	ldd	r18, Z+26	; 0x1a
    285e:	2a 8f       	std	Y+26, r18	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2860:	80 91 f9 19 	lds	r24, 0x19F9
    2864:	82 17       	cp	r24, r18
    2866:	10 f4       	brcc	.+4      	; 0x286c <vTaskPriorityInherit+0xa2>
    2868:	20 93 f9 19 	sts	0x19F9, r18
    286c:	30 e0       	ldi	r19, 0x00	; 0
    286e:	c9 01       	movw	r24, r18
    2870:	88 0f       	add	r24, r24
    2872:	99 1f       	adc	r25, r25
    2874:	a9 01       	movw	r20, r18
    2876:	44 0f       	add	r20, r20
    2878:	55 1f       	adc	r21, r21
    287a:	44 0f       	add	r20, r20
    287c:	55 1f       	adc	r21, r21
    287e:	44 0f       	add	r20, r20
    2880:	55 1f       	adc	r21, r21
    2882:	84 0f       	add	r24, r20
    2884:	95 1f       	adc	r25, r21
    2886:	82 0f       	add	r24, r18
    2888:	93 1f       	adc	r25, r19
    288a:	8d 5f       	subi	r24, 0xFD	; 253
    288c:	95 4e       	sbci	r25, 0xE5	; 229
    288e:	b8 01       	movw	r22, r16
    2890:	0e 94 37 15 	call	0x2a6e	; 0x2a6e <vListInsertEnd>
    2894:	d4 cf       	rjmp	.-88     	; 0x283e <vTaskPriorityInherit+0x74>

00002896 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2896:	0f 93       	push	r16
    2898:	1f 93       	push	r17
    289a:	cf 93       	push	r28
    289c:	df 93       	push	r29
    289e:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    28a0:	00 97       	sbiw	r24, 0x00	; 0
    28a2:	81 f1       	breq	.+96     	; 0x2904 <vTaskPriorityDisinherit+0x6e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    28a4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    28a6:	8f a1       	lds	r24, 0x4f
    28a8:	98 17       	cp	r25, r24
    28aa:	61 f1       	breq	.+88     	; 0x2904 <vTaskPriorityDisinherit+0x6e>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    28ac:	8e 01       	movw	r16, r28
    28ae:	0e 5f       	subi	r16, 0xFE	; 254
    28b0:	1f 4f       	sbci	r17, 0xFF	; 255
    28b2:	c8 01       	movw	r24, r16
    28b4:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    28b8:	2f a1       	lds	r18, 0x4f
    28ba:	2a 8f       	std	Y+26, r18	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    28bc:	84 e0       	ldi	r24, 0x04	; 4
    28be:	90 e0       	ldi	r25, 0x00	; 0
    28c0:	a0 e0       	ldi	r26, 0x00	; 0
    28c2:	b0 e0       	ldi	r27, 0x00	; 0
    28c4:	82 1b       	sub	r24, r18
    28c6:	91 09       	sbc	r25, r1
    28c8:	a1 09       	sbc	r26, r1
    28ca:	b1 09       	sbc	r27, r1
    28cc:	8e 87       	std	Y+14, r24	; 0x0e
    28ce:	9f 87       	std	Y+15, r25	; 0x0f
    28d0:	a8 8b       	std	Y+16, r26	; 0x10
    28d2:	b9 8b       	std	Y+17, r27	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    28d4:	80 91 f9 19 	lds	r24, 0x19F9
    28d8:	82 17       	cp	r24, r18
    28da:	c8 f0       	brcs	.+50     	; 0x290e <vTaskPriorityDisinherit+0x78>
    28dc:	30 e0       	ldi	r19, 0x00	; 0
    28de:	c9 01       	movw	r24, r18
    28e0:	88 0f       	add	r24, r24
    28e2:	99 1f       	adc	r25, r25
    28e4:	a9 01       	movw	r20, r18
    28e6:	44 0f       	add	r20, r20
    28e8:	55 1f       	adc	r21, r21
    28ea:	44 0f       	add	r20, r20
    28ec:	55 1f       	adc	r21, r21
    28ee:	44 0f       	add	r20, r20
    28f0:	55 1f       	adc	r21, r21
    28f2:	84 0f       	add	r24, r20
    28f4:	95 1f       	adc	r25, r21
    28f6:	82 0f       	add	r24, r18
    28f8:	93 1f       	adc	r25, r19
    28fa:	8d 5f       	subi	r24, 0xFD	; 253
    28fc:	95 4e       	sbci	r25, 0xE5	; 229
    28fe:	b8 01       	movw	r22, r16
    2900:	0e 94 37 15 	call	0x2a6e	; 0x2a6e <vListInsertEnd>
			}
		}
	}
    2904:	df 91       	pop	r29
    2906:	cf 91       	pop	r28
    2908:	1f 91       	pop	r17
    290a:	0f 91       	pop	r16
    290c:	08 95       	ret
				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
    290e:	20 93 f9 19 	sts	0x19F9, r18
    2912:	e4 cf       	rjmp	.-56     	; 0x28dc <vTaskPriorityDisinherit+0x46>

00002914 <_ZN7base232C1Ejh>:
 *                     1 only exists on some processors). The default is port 0 
 */

// This section compiles for the AVR microcontroller
#ifdef __AVR
base232::base232 (unsigned int baud_rate, unsigned char port_number)
    2914:	0f 93       	push	r16
    2916:	1f 93       	push	r17
    2918:	cf 93       	push	r28
    291a:	df 93       	push	r29
    291c:	ec 01       	movw	r28, r24
{
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A
		if (port_number == 0)
    291e:	44 23       	and	r20, r20
    2920:	09 f4       	brne	.+2      	; 0x2924 <_ZN7base232C1Ejh+0x10>
    2922:	45 c0       	rjmp	.+138    	; 0x29ae <_ZN7base232C1Ejh+0x9a>
			mask_TXC = (1 << TXC0);
		}
		else	// The port number isn't 0, so it presumably must be serial port 1
		{
		#if defined UCSR1A
			p_UDR = &UDR1;
    2924:	8e ec       	ldi	r24, 0xCE	; 206
    2926:	90 e0       	ldi	r25, 0x00	; 0
    2928:	99 83       	std	Y+1, r25	; 0x01
    292a:	88 83       	st	Y, r24
			p_USR = &UCSR1A;
    292c:	88 ec       	ldi	r24, 0xC8	; 200
    292e:	90 e0       	ldi	r25, 0x00	; 0
    2930:	9b 83       	std	Y+3, r25	; 0x03
    2932:	8a 83       	std	Y+2, r24	; 0x02
			p_UCR = &UCSR1B;
    2934:	89 ec       	ldi	r24, 0xC9	; 201
    2936:	90 e0       	ldi	r25, 0x00	; 0
    2938:	9d 83       	std	Y+5, r25	; 0x05
    293a:	8c 83       	std	Y+4, r24	; 0x04
			UCSR1B = (1 << RXEN1) | (1 << TXEN1);
    293c:	88 e1       	ldi	r24, 0x18	; 24
    293e:	80 93 c9 00 	sts	0x00C9, r24
			UCSR1C = (1 << UCSZ11) | (1 << UCSZ10); // | (1 << USBS1);
    2942:	86 e0       	ldi	r24, 0x06	; 6
    2944:	80 93 ca 00 	sts	0x00CA, r24
			UBRR1H = 0x00;
    2948:	10 92 cd 00 	sts	0x00CD, r1
			UBRR1L = calc_baud_div (baud_rate);
    294c:	8b 01       	movw	r16, r22
    294e:	20 e0       	ldi	r18, 0x00	; 0
    2950:	30 e0       	ldi	r19, 0x00	; 0
    2952:	00 0f       	add	r16, r16
    2954:	11 1f       	adc	r17, r17
    2956:	22 1f       	adc	r18, r18
    2958:	33 1f       	adc	r19, r19
    295a:	00 0f       	add	r16, r16
    295c:	11 1f       	adc	r17, r17
    295e:	22 1f       	adc	r18, r18
    2960:	33 1f       	adc	r19, r19
    2962:	00 0f       	add	r16, r16
    2964:	11 1f       	adc	r17, r17
    2966:	22 1f       	adc	r18, r18
    2968:	33 1f       	adc	r19, r19
    296a:	00 0f       	add	r16, r16
    296c:	11 1f       	adc	r17, r17
    296e:	22 1f       	adc	r18, r18
    2970:	33 1f       	adc	r19, r19
    2972:	60 e0       	ldi	r22, 0x00	; 0
    2974:	74 e2       	ldi	r23, 0x24	; 36
    2976:	84 ef       	ldi	r24, 0xF4	; 244
    2978:	90 e0       	ldi	r25, 0x00	; 0
    297a:	a9 01       	movw	r20, r18
    297c:	98 01       	movw	r18, r16
    297e:	0e 94 4d 16 	call	0x2c9a	; 0x2c9a <__udivmodsi4>
    2982:	20 93 cc 00 	sts	0x00CC, r18
			#ifdef UART_DOUBLE_SPEED		// If double-speed macro has been defined,
				UCSR1A |= U2X1;				// turn on double-speed operation
    2986:	80 91 c8 00 	lds	r24, 0x00C8
    298a:	81 60       	ori	r24, 0x01	; 1
    298c:	80 93 c8 00 	sts	0x00C8, r24
			#endif
			mask_UDRE = (1 << UDRE1);
    2990:	80 e2       	ldi	r24, 0x20	; 32
    2992:	8e 83       	std	Y+6, r24	; 0x06
			mask_RXC = (1 << RXC1);
    2994:	80 e8       	ldi	r24, 0x80	; 128
    2996:	8f 83       	std	Y+7, r24	; 0x07
			mask_TXC = (1 << TXC1);
    2998:	80 e4       	ldi	r24, 0x40	; 64
    299a:	88 87       	std	Y+8, r24	; 0x08
			mask_TXC = (1 << TXC);
		#endif // UCSRA
	#endif // UCSR0A

	// Read the data register to ensure that it's empty
	port_number = *p_UDR;
    299c:	e8 81       	ld	r30, Y
    299e:	f9 81       	ldd	r31, Y+1	; 0x01
    29a0:	80 81       	ld	r24, Z
	port_number = *p_UDR;
    29a2:	80 81       	ld	r24, Z
}
    29a4:	df 91       	pop	r29
    29a6:	cf 91       	pop	r28
    29a8:	1f 91       	pop	r17
    29aa:	0f 91       	pop	r16
    29ac:	08 95       	ret
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A
		if (port_number == 0)
		{
			p_UDR = &UDR0;
    29ae:	86 ec       	ldi	r24, 0xC6	; 198
    29b0:	90 e0       	ldi	r25, 0x00	; 0
    29b2:	99 83       	std	Y+1, r25	; 0x01
    29b4:	88 83       	st	Y, r24
			p_USR = &UCSR0A;
    29b6:	80 ec       	ldi	r24, 0xC0	; 192
    29b8:	90 e0       	ldi	r25, 0x00	; 0
    29ba:	9b 83       	std	Y+3, r25	; 0x03
    29bc:	8a 83       	std	Y+2, r24	; 0x02
			p_UCR = &UCSR0B;
    29be:	81 ec       	ldi	r24, 0xC1	; 193
    29c0:	90 e0       	ldi	r25, 0x00	; 0
    29c2:	9d 83       	std	Y+5, r25	; 0x05
    29c4:	8c 83       	std	Y+4, r24	; 0x04
			UCSR0B = (1 << RXEN0) | (1 << TXEN0);
    29c6:	88 e1       	ldi	r24, 0x18	; 24
    29c8:	80 93 c1 00 	sts	0x00C1, r24
			UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); // | (1 << USBS0);
    29cc:	86 e0       	ldi	r24, 0x06	; 6
    29ce:	80 93 c2 00 	sts	0x00C2, r24
			UBRR0H = 0x00;
    29d2:	10 92 c5 00 	sts	0x00C5, r1
			UBRR0L = calc_baud_div (baud_rate);
    29d6:	8b 01       	movw	r16, r22
    29d8:	20 e0       	ldi	r18, 0x00	; 0
    29da:	30 e0       	ldi	r19, 0x00	; 0
    29dc:	00 0f       	add	r16, r16
    29de:	11 1f       	adc	r17, r17
    29e0:	22 1f       	adc	r18, r18
    29e2:	33 1f       	adc	r19, r19
    29e4:	00 0f       	add	r16, r16
    29e6:	11 1f       	adc	r17, r17
    29e8:	22 1f       	adc	r18, r18
    29ea:	33 1f       	adc	r19, r19
    29ec:	00 0f       	add	r16, r16
    29ee:	11 1f       	adc	r17, r17
    29f0:	22 1f       	adc	r18, r18
    29f2:	33 1f       	adc	r19, r19
    29f4:	00 0f       	add	r16, r16
    29f6:	11 1f       	adc	r17, r17
    29f8:	22 1f       	adc	r18, r18
    29fa:	33 1f       	adc	r19, r19
    29fc:	60 e0       	ldi	r22, 0x00	; 0
    29fe:	74 e2       	ldi	r23, 0x24	; 36
    2a00:	84 ef       	ldi	r24, 0xF4	; 244
    2a02:	90 e0       	ldi	r25, 0x00	; 0
    2a04:	a9 01       	movw	r20, r18
    2a06:	98 01       	movw	r18, r16
    2a08:	0e 94 4d 16 	call	0x2c9a	; 0x2c9a <__udivmodsi4>
    2a0c:	20 93 c4 00 	sts	0x00C4, r18
			#ifdef UART_DOUBLE_SPEED					// Activate double speed mode
				UCSR0A |= U2X0;							// if required
    2a10:	80 91 c0 00 	lds	r24, 0x00C0
    2a14:	81 60       	ori	r24, 0x01	; 1
    2a16:	80 93 c0 00 	sts	0x00C0, r24
    2a1a:	ba cf       	rjmp	.-140    	; 0x2990 <_ZN7base232C1Ejh+0x7c>

00002a1c <_ZN7base23213ready_to_sendEv>:
 *  tests whether transmitter buffer is empty. 
 *  @return True if the serial port is ready to send, and false if not
 */

bool base232::ready_to_send (void)
{
    2a1c:	fc 01       	movw	r30, r24
#ifdef __AVR
	// If transmitter buffer is full, we're not ready to send
	if (*p_USR & mask_UDRE)
    2a1e:	a2 81       	ldd	r26, Z+2	; 0x02
    2a20:	b3 81       	ldd	r27, Z+3	; 0x03
    2a22:	9c 91       	ld	r25, X
    2a24:	86 81       	ldd	r24, Z+6	; 0x06
    2a26:	98 23       	and	r25, r24
/** This method checks if the serial port transmitter is ready to send data.  It 
 *  tests whether transmitter buffer is empty. 
 *  @return True if the serial port is ready to send, and false if not
 */

bool base232::ready_to_send (void)
    2a28:	81 e0       	ldi	r24, 0x01	; 1
    2a2a:	09 f4       	brne	.+2      	; 0x2a2e <_ZN7base23213ready_to_sendEv+0x12>
    2a2c:	80 e0       	ldi	r24, 0x00	; 0
	return (false);
#else
	// The non-AVR (that is, PC) serial port buffer should always be ready
	return (true);
#endif
}
    2a2e:	08 95       	ret

00002a30 <_ZN7base23210is_sendingEv>:
 *  has been sent. 
 *  @return True if the port is currently sending a character, false if it's idle
 */

bool base232::is_sending (void)
{
    2a30:	fc 01       	movw	r30, r24
#ifdef __AVR
	if (*p_USR & mask_TXC)
    2a32:	a2 81       	ldd	r26, Z+2	; 0x02
    2a34:	b3 81       	ldd	r27, Z+3	; 0x03
    2a36:	9c 91       	ld	r25, X
    2a38:	80 85       	ldd	r24, Z+8	; 0x08
    2a3a:	98 23       	and	r25, r24
 *  last one; it would be a bad idea to put the processor to sleep before the character
 *  has been sent. 
 *  @return True if the port is currently sending a character, false if it's idle
 */

bool base232::is_sending (void)
    2a3c:	81 e0       	ldi	r24, 0x01	; 1
    2a3e:	09 f0       	breq	.+2      	; 0x2a42 <_ZN7base23210is_sendingEv+0x12>
    2a40:	80 e0       	ldi	r24, 0x00	; 0
		return (true);
#else
	// We don't really care if a PC is sending, as it has a buffer anyway
	return (false);
#endif
}
    2a42:	08 95       	ret

00002a44 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2a44:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2a46:	03 96       	adiw	r24, 0x03	; 3
    2a48:	92 83       	std	Z+2, r25	; 0x02
    2a4a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2a4c:	4f ef       	ldi	r20, 0xFF	; 255
    2a4e:	5f ef       	ldi	r21, 0xFF	; 255
    2a50:	ba 01       	movw	r22, r20
    2a52:	43 83       	std	Z+3, r20	; 0x03
    2a54:	54 83       	std	Z+4, r21	; 0x04
    2a56:	65 83       	std	Z+5, r22	; 0x05
    2a58:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2a5a:	90 87       	std	Z+8, r25	; 0x08
    2a5c:	87 83       	std	Z+7, r24	; 0x07
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    2a5e:	92 87       	std	Z+10, r25	; 0x0a
    2a60:	81 87       	std	Z+9, r24	; 0x09

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    2a62:	10 82       	st	Z, r1
}
    2a64:	08 95       	ret

00002a66 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2a66:	fc 01       	movw	r30, r24
    2a68:	13 86       	std	Z+11, r1	; 0x0b
    2a6a:	12 86       	std	Z+10, r1	; 0x0a
}
    2a6c:	08 95       	ret

00002a6e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    2a6e:	cf 93       	push	r28
    2a70:	df 93       	push	r29
    2a72:	ec 01       	movw	r28, r24
    2a74:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2a76:	89 81       	ldd	r24, Y+1	; 0x01
    2a78:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    2a7a:	dc 01       	movw	r26, r24
    2a7c:	14 96       	adiw	r26, 0x04	; 4
    2a7e:	2d 91       	ld	r18, X+
    2a80:	3c 91       	ld	r19, X
    2a82:	15 97       	sbiw	r26, 0x05	; 5
    2a84:	35 83       	std	Z+5, r19	; 0x05
    2a86:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2a88:	97 83       	std	Z+7, r25	; 0x07
    2a8a:	86 83       	std	Z+6, r24	; 0x06
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2a8c:	14 96       	adiw	r26, 0x04	; 4
    2a8e:	2d 91       	ld	r18, X+
    2a90:	3c 91       	ld	r19, X
    2a92:	15 97       	sbiw	r26, 0x05	; 5
    2a94:	d9 01       	movw	r26, r18
    2a96:	17 96       	adiw	r26, 0x07	; 7
    2a98:	7c 93       	st	X, r23
    2a9a:	6e 93       	st	-X, r22
    2a9c:	16 97       	sbiw	r26, 0x06	; 6
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    2a9e:	dc 01       	movw	r26, r24
    2aa0:	15 96       	adiw	r26, 0x05	; 5
    2aa2:	7c 93       	st	X, r23
    2aa4:	6e 93       	st	-X, r22
    2aa6:	14 97       	sbiw	r26, 0x04	; 4
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    2aa8:	7a 83       	std	Y+2, r23	; 0x02
    2aaa:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2aac:	d3 87       	std	Z+11, r29	; 0x0b
    2aae:	c2 87       	std	Z+10, r28	; 0x0a

	( pxList->uxNumberOfItems )++;
    2ab0:	88 81       	ld	r24, Y
    2ab2:	8f 5f       	subi	r24, 0xFF	; 255
    2ab4:	88 83       	st	Y, r24
}
    2ab6:	df 91       	pop	r29
    2ab8:	cf 91       	pop	r28
    2aba:	08 95       	ret

00002abc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2abc:	cf 92       	push	r12
    2abe:	df 92       	push	r13
    2ac0:	ef 92       	push	r14
    2ac2:	ff 92       	push	r15
    2ac4:	cf 93       	push	r28
    2ac6:	df 93       	push	r29
    2ac8:	9c 01       	movw	r18, r24
    2aca:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    2acc:	48 81       	ld	r20, Y
    2ace:	59 81       	ldd	r21, Y+1	; 0x01
    2ad0:	6a 81       	ldd	r22, Y+2	; 0x02
    2ad2:	7b 81       	ldd	r23, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2ad4:	4f 3f       	cpi	r20, 0xFF	; 255
    2ad6:	8f ef       	ldi	r24, 0xFF	; 255
    2ad8:	58 07       	cpc	r21, r24
    2ada:	8f ef       	ldi	r24, 0xFF	; 255
    2adc:	68 07       	cpc	r22, r24
    2ade:	8f ef       	ldi	r24, 0xFF	; 255
    2ae0:	78 07       	cpc	r23, r24
    2ae2:	d1 f1       	breq	.+116    	; 0x2b58 <vListInsert+0x9c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2ae4:	f9 01       	movw	r30, r18
    2ae6:	33 96       	adiw	r30, 0x03	; 3
    2ae8:	d9 01       	movw	r26, r18
    2aea:	17 96       	adiw	r26, 0x07	; 7
    2aec:	8d 91       	ld	r24, X+
    2aee:	9c 91       	ld	r25, X
    2af0:	18 97       	sbiw	r26, 0x08	; 8
    2af2:	dc 01       	movw	r26, r24
    2af4:	cd 90       	ld	r12, X+
    2af6:	dd 90       	ld	r13, X+
    2af8:	ed 90       	ld	r14, X+
    2afa:	fc 90       	ld	r15, X
    2afc:	13 97       	sbiw	r26, 0x03	; 3
    2afe:	4c 15       	cp	r20, r12
    2b00:	5d 05       	cpc	r21, r13
    2b02:	6e 05       	cpc	r22, r14
    2b04:	7f 05       	cpc	r23, r15
    2b06:	78 f0       	brcs	.+30     	; 0x2b26 <vListInsert+0x6a>
    2b08:	04 80       	ldd	r0, Z+4	; 0x04
    2b0a:	f5 81       	ldd	r31, Z+5	; 0x05
    2b0c:	e0 2d       	mov	r30, r0
    2b0e:	a4 81       	ldd	r26, Z+4	; 0x04
    2b10:	b5 81       	ldd	r27, Z+5	; 0x05
    2b12:	8d 91       	ld	r24, X+
    2b14:	9d 91       	ld	r25, X+
    2b16:	0d 90       	ld	r0, X+
    2b18:	bc 91       	ld	r27, X
    2b1a:	a0 2d       	mov	r26, r0
    2b1c:	48 17       	cp	r20, r24
    2b1e:	59 07       	cpc	r21, r25
    2b20:	6a 07       	cpc	r22, r26
    2b22:	7b 07       	cpc	r23, r27
    2b24:	88 f7       	brcc	.-30     	; 0x2b08 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2b26:	a4 81       	ldd	r26, Z+4	; 0x04
    2b28:	b5 81       	ldd	r27, Z+5	; 0x05
    2b2a:	bd 83       	std	Y+5, r27	; 0x05
    2b2c:	ac 83       	std	Y+4, r26	; 0x04
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2b2e:	17 96       	adiw	r26, 0x07	; 7
    2b30:	dc 93       	st	X, r29
    2b32:	ce 93       	st	-X, r28
    2b34:	16 97       	sbiw	r26, 0x06	; 6
	pxNewListItem->pxPrevious = pxIterator;
    2b36:	ff 83       	std	Y+7, r31	; 0x07
    2b38:	ee 83       	std	Y+6, r30	; 0x06
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2b3a:	d5 83       	std	Z+5, r29	; 0x05
    2b3c:	c4 83       	std	Z+4, r28	; 0x04

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2b3e:	3b 87       	std	Y+11, r19	; 0x0b
    2b40:	2a 87       	std	Y+10, r18	; 0x0a

	( pxList->uxNumberOfItems )++;
    2b42:	f9 01       	movw	r30, r18
    2b44:	80 81       	ld	r24, Z
    2b46:	8f 5f       	subi	r24, 0xFF	; 255
    2b48:	80 83       	st	Z, r24
}
    2b4a:	df 91       	pop	r29
    2b4c:	cf 91       	pop	r28
    2b4e:	ff 90       	pop	r15
    2b50:	ef 90       	pop	r14
    2b52:	df 90       	pop	r13
    2b54:	cf 90       	pop	r12
    2b56:	08 95       	ret
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2b58:	d9 01       	movw	r26, r18
    2b5a:	19 96       	adiw	r26, 0x09	; 9
    2b5c:	ed 91       	ld	r30, X+
    2b5e:	fc 91       	ld	r31, X
    2b60:	1a 97       	sbiw	r26, 0x0a	; 10
    2b62:	e1 cf       	rjmp	.-62     	; 0x2b26 <vListInsert+0x6a>

00002b64 <vListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    2b64:	cf 93       	push	r28
    2b66:	df 93       	push	r29
    2b68:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2b6a:	a4 81       	ldd	r26, Z+4	; 0x04
    2b6c:	b5 81       	ldd	r27, Z+5	; 0x05
    2b6e:	86 81       	ldd	r24, Z+6	; 0x06
    2b70:	97 81       	ldd	r25, Z+7	; 0x07
    2b72:	17 96       	adiw	r26, 0x07	; 7
    2b74:	9c 93       	st	X, r25
    2b76:	8e 93       	st	-X, r24
    2b78:	16 97       	sbiw	r26, 0x06	; 6
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2b7a:	c6 81       	ldd	r28, Z+6	; 0x06
    2b7c:	d7 81       	ldd	r29, Z+7	; 0x07
    2b7e:	bd 83       	std	Y+5, r27	; 0x05
    2b80:	ac 83       	std	Y+4, r26	; 0x04
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    2b82:	a2 85       	ldd	r26, Z+10	; 0x0a
    2b84:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2b86:	11 96       	adiw	r26, 0x01	; 1
    2b88:	8d 91       	ld	r24, X+
    2b8a:	9c 91       	ld	r25, X
    2b8c:	12 97       	sbiw	r26, 0x02	; 2
    2b8e:	8e 17       	cp	r24, r30
    2b90:	9f 07       	cpc	r25, r31
    2b92:	41 f0       	breq	.+16     	; 0x2ba4 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
	}

	pxItemToRemove->pvContainer = NULL;
    2b94:	13 86       	std	Z+11, r1	; 0x0b
    2b96:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
    2b98:	8c 91       	ld	r24, X
    2b9a:	81 50       	subi	r24, 0x01	; 1
    2b9c:	8c 93       	st	X, r24
}
    2b9e:	df 91       	pop	r29
    2ba0:	cf 91       	pop	r28
    2ba2:	08 95       	ret
	pxList = ( xList * ) pxItemToRemove->pvContainer;

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2ba4:	12 96       	adiw	r26, 0x02	; 2
    2ba6:	dc 93       	st	X, r29
    2ba8:	ce 93       	st	-X, r28
    2baa:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    2bac:	13 86       	std	Z+11, r1	; 0x0b
    2bae:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
    2bb0:	8c 91       	ld	r24, X
    2bb2:	81 50       	subi	r24, 0x01	; 1
    2bb4:	8c 93       	st	X, r24
}
    2bb6:	df 91       	pop	r29
    2bb8:	cf 91       	pop	r28
    2bba:	08 95       	ret

00002bbc <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    2bbc:	0f 93       	push	r16
    2bbe:	1f 93       	push	r17
    2bc0:	cf 93       	push	r28
    2bc2:	df 93       	push	r29
    2bc4:	cd b7       	in	r28, 0x3d	; 61
    2bc6:	de b7       	in	r29, 0x3e	; 62
    2bc8:	62 97       	sbiw	r28, 0x12	; 18
    2bca:	0f b6       	in	r0, 0x3f	; 63
    2bcc:	f8 94       	cli
    2bce:	de bf       	out	0x3e, r29	; 62
    2bd0:	0f be       	out	0x3f, r0	; 63
    2bd2:	cd bf       	out	0x3d, r28	; 61
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on
	MCUSR = 0;
    2bd4:	14 be       	out	0x34, r1	; 52
	wdt_disable ();
    2bd6:	88 e1       	ldi	r24, 0x18	; 24
    2bd8:	0f b6       	in	r0, 0x3f	; 63
    2bda:	f8 94       	cli
    2bdc:	80 93 60 00 	sts	0x0060, r24
    2be0:	10 92 60 00 	sts	0x0060, r1
    2be4:	0f be       	out	0x3f, r0	; 63

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_port (9600, 1);
    2be6:	ce 01       	movw	r24, r28
    2be8:	01 96       	adiw	r24, 0x01	; 1
    2bea:	60 e8       	ldi	r22, 0x80	; 128
    2bec:	75 e2       	ldi	r23, 0x25	; 37
    2bee:	41 e0       	ldi	r20, 0x01	; 1
    2bf0:	0e 94 b6 07 	call	0xf6c	; 0xf6c <_ZN5rs232C1Ejh>
	ser_port << clrscr << PMS ("ME405 Lab 1 Starting Program") << endl;
    2bf4:	ce 01       	movw	r24, r28
    2bf6:	01 96       	adiw	r24, 0x01	; 1
    2bf8:	67 e0       	ldi	r22, 0x07	; 7
    2bfa:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
    2bfe:	6a e0       	ldi	r22, 0x0A	; 10
    2c00:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
    2c04:	8c 01       	movw	r16, r24
    2c06:	6c ec       	ldi	r22, 0xCC	; 204
    2c08:	70 e0       	ldi	r23, 0x00	; 0
    2c0a:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN8emstream4putsEPKc>
    2c0e:	c8 01       	movw	r24, r16
    2c10:	66 e0       	ldi	r22, 0x06	; 6
    2c12:	0e 94 d5 05 	call	0xbaa	; 0xbaa <_ZN8emstreamlsE15ser_manipulator>
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	//new task_user ("UserInt", task_priority (1), 260, &ser_port);

	// Create a task which reads the A/D and adjusts an LED's brightness accordingly
	new motor_controller ("Bright", task_priority (2), 280, &ser_port);
    2c16:	82 e1       	ldi	r24, 0x12	; 18
    2c18:	90 e0       	ldi	r25, 0x00	; 0
    2c1a:	0e 94 5d 05 	call	0xaba	; 0xaba <_Znwj>
    2c1e:	60 e0       	ldi	r22, 0x00	; 0
    2c20:	72 e0       	ldi	r23, 0x02	; 2
    2c22:	42 e0       	ldi	r20, 0x02	; 2
    2c24:	28 e1       	ldi	r18, 0x18	; 24
    2c26:	31 e0       	ldi	r19, 0x01	; 1
    2c28:	8e 01       	movw	r16, r28
    2c2a:	0f 5f       	subi	r16, 0xFF	; 255
    2c2c:	1f 4f       	sbci	r17, 0xFF	; 255
    2c2e:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <_ZN16motor_controllerC1EPKchjP8emstream>

	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    2c32:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <vTaskStartScheduler>
}
    2c36:	80 e0       	ldi	r24, 0x00	; 0
    2c38:	90 e0       	ldi	r25, 0x00	; 0
    2c3a:	62 96       	adiw	r28, 0x12	; 18
    2c3c:	0f b6       	in	r0, 0x3f	; 63
    2c3e:	f8 94       	cli
    2c40:	de bf       	out	0x3e, r29	; 62
    2c42:	0f be       	out	0x3f, r0	; 63
    2c44:	cd bf       	out	0x3d, r28	; 61
    2c46:	df 91       	pop	r29
    2c48:	cf 91       	pop	r28
    2c4a:	1f 91       	pop	r17
    2c4c:	0f 91       	pop	r16
    2c4e:	08 95       	ret

00002c50 <_GLOBAL__sub_I_print_ser_queue>:
    2c50:	0f 93       	push	r16
    2c52:	1f 93       	push	r17
/** This is a print queue, descended from \c emstream so that things can be printed 
 *  into the queue using the "<<" operator and they'll come out the other end as a 
 *  stream of characters. It's used by tasks that send things to the user interface 
 *  task to be printed. 
 */
frt_text_queue print_ser_queue (32, NULL, 10);
    2c54:	8a e9       	ldi	r24, 0x9A	; 154
    2c56:	92 e0       	ldi	r25, 0x02	; 2
    2c58:	60 e2       	ldi	r22, 0x20	; 32
    2c5a:	70 e0       	ldi	r23, 0x00	; 0
    2c5c:	40 e0       	ldi	r20, 0x00	; 0
    2c5e:	50 e0       	ldi	r21, 0x00	; 0
    2c60:	0a e0       	ldi	r16, 0x0A	; 10
    2c62:	10 e0       	ldi	r17, 0x00	; 0
    2c64:	20 e0       	ldi	r18, 0x00	; 0
    2c66:	30 e0       	ldi	r19, 0x00	; 0
    2c68:	0e 94 25 05 	call	0xa4a	; 0xa4a <_ZN14frt_text_queueC1EjP8emstreamm>
	new motor_controller ("Bright", task_priority (2), 280, &ser_port);

	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    2c6c:	1f 91       	pop	r17
    2c6e:	0f 91       	pop	r16
    2c70:	08 95       	ret

00002c72 <__udivmodhi4>:
    2c72:	aa 1b       	sub	r26, r26
    2c74:	bb 1b       	sub	r27, r27
    2c76:	51 e1       	ldi	r21, 0x11	; 17
    2c78:	07 c0       	rjmp	.+14     	; 0x2c88 <__udivmodhi4_ep>

00002c7a <__udivmodhi4_loop>:
    2c7a:	aa 1f       	adc	r26, r26
    2c7c:	bb 1f       	adc	r27, r27
    2c7e:	a6 17       	cp	r26, r22
    2c80:	b7 07       	cpc	r27, r23
    2c82:	10 f0       	brcs	.+4      	; 0x2c88 <__udivmodhi4_ep>
    2c84:	a6 1b       	sub	r26, r22
    2c86:	b7 0b       	sbc	r27, r23

00002c88 <__udivmodhi4_ep>:
    2c88:	88 1f       	adc	r24, r24
    2c8a:	99 1f       	adc	r25, r25
    2c8c:	5a 95       	dec	r21
    2c8e:	a9 f7       	brne	.-22     	; 0x2c7a <__udivmodhi4_loop>
    2c90:	80 95       	com	r24
    2c92:	90 95       	com	r25
    2c94:	bc 01       	movw	r22, r24
    2c96:	cd 01       	movw	r24, r26
    2c98:	08 95       	ret

00002c9a <__udivmodsi4>:
    2c9a:	a1 e2       	ldi	r26, 0x21	; 33
    2c9c:	1a 2e       	mov	r1, r26
    2c9e:	aa 1b       	sub	r26, r26
    2ca0:	bb 1b       	sub	r27, r27
    2ca2:	fd 01       	movw	r30, r26
    2ca4:	0d c0       	rjmp	.+26     	; 0x2cc0 <__udivmodsi4_ep>

00002ca6 <__udivmodsi4_loop>:
    2ca6:	aa 1f       	adc	r26, r26
    2ca8:	bb 1f       	adc	r27, r27
    2caa:	ee 1f       	adc	r30, r30
    2cac:	ff 1f       	adc	r31, r31
    2cae:	a2 17       	cp	r26, r18
    2cb0:	b3 07       	cpc	r27, r19
    2cb2:	e4 07       	cpc	r30, r20
    2cb4:	f5 07       	cpc	r31, r21
    2cb6:	20 f0       	brcs	.+8      	; 0x2cc0 <__udivmodsi4_ep>
    2cb8:	a2 1b       	sub	r26, r18
    2cba:	b3 0b       	sbc	r27, r19
    2cbc:	e4 0b       	sbc	r30, r20
    2cbe:	f5 0b       	sbc	r31, r21

00002cc0 <__udivmodsi4_ep>:
    2cc0:	66 1f       	adc	r22, r22
    2cc2:	77 1f       	adc	r23, r23
    2cc4:	88 1f       	adc	r24, r24
    2cc6:	99 1f       	adc	r25, r25
    2cc8:	1a 94       	dec	r1
    2cca:	69 f7       	brne	.-38     	; 0x2ca6 <__udivmodsi4_loop>
    2ccc:	60 95       	com	r22
    2cce:	70 95       	com	r23
    2cd0:	80 95       	com	r24
    2cd2:	90 95       	com	r25
    2cd4:	9b 01       	movw	r18, r22
    2cd6:	ac 01       	movw	r20, r24
    2cd8:	bd 01       	movw	r22, r26
    2cda:	cf 01       	movw	r24, r30
    2cdc:	08 95       	ret

00002cde <__tablejump_elpm__>:
    2cde:	07 90       	elpm	r0, Z+
    2ce0:	f6 91       	elpm	r31, Z
    2ce2:	e0 2d       	mov	r30, r0
    2ce4:	09 94       	ijmp

00002ce6 <memcpy>:
    2ce6:	fb 01       	movw	r30, r22
    2ce8:	dc 01       	movw	r26, r24
    2cea:	02 c0       	rjmp	.+4      	; 0x2cf0 <memcpy+0xa>
    2cec:	01 90       	ld	r0, Z+
    2cee:	0d 92       	st	X+, r0
    2cf0:	41 50       	subi	r20, 0x01	; 1
    2cf2:	50 40       	sbci	r21, 0x00	; 0
    2cf4:	d8 f7       	brcc	.-10     	; 0x2cec <memcpy+0x6>
    2cf6:	08 95       	ret

00002cf8 <memset>:
    2cf8:	dc 01       	movw	r26, r24
    2cfa:	01 c0       	rjmp	.+2      	; 0x2cfe <memset+0x6>
    2cfc:	6d 93       	st	X+, r22
    2cfe:	41 50       	subi	r20, 0x01	; 1
    2d00:	50 40       	sbci	r21, 0x00	; 0
    2d02:	e0 f7       	brcc	.-8      	; 0x2cfc <memset+0x4>
    2d04:	08 95       	ret

00002d06 <strncpy>:
    2d06:	fb 01       	movw	r30, r22
    2d08:	dc 01       	movw	r26, r24
    2d0a:	41 50       	subi	r20, 0x01	; 1
    2d0c:	50 40       	sbci	r21, 0x00	; 0
    2d0e:	48 f0       	brcs	.+18     	; 0x2d22 <strncpy+0x1c>
    2d10:	01 90       	ld	r0, Z+
    2d12:	0d 92       	st	X+, r0
    2d14:	00 20       	and	r0, r0
    2d16:	c9 f7       	brne	.-14     	; 0x2d0a <strncpy+0x4>
    2d18:	01 c0       	rjmp	.+2      	; 0x2d1c <strncpy+0x16>
    2d1a:	1d 92       	st	X+, r1
    2d1c:	41 50       	subi	r20, 0x01	; 1
    2d1e:	50 40       	sbci	r21, 0x00	; 0
    2d20:	e0 f7       	brcc	.-8      	; 0x2d1a <strncpy+0x14>
    2d22:	08 95       	ret

00002d24 <ultoa>:
    2d24:	fa 01       	movw	r30, r20
    2d26:	cf 93       	push	r28
    2d28:	ff 93       	push	r31
    2d2a:	ef 93       	push	r30
    2d2c:	22 30       	cpi	r18, 0x02	; 2
    2d2e:	cc f0       	brlt	.+50     	; 0x2d62 <ultoa+0x3e>
    2d30:	25 32       	cpi	r18, 0x25	; 37
    2d32:	bc f4       	brge	.+46     	; 0x2d62 <ultoa+0x3e>
    2d34:	c2 2f       	mov	r28, r18
    2d36:	2c 2f       	mov	r18, r28
    2d38:	33 27       	eor	r19, r19
    2d3a:	44 27       	eor	r20, r20
    2d3c:	55 27       	eor	r21, r21
    2d3e:	ff 93       	push	r31
    2d40:	ef 93       	push	r30
    2d42:	0e 94 4d 16 	call	0x2c9a	; 0x2c9a <__udivmodsi4>
    2d46:	ef 91       	pop	r30
    2d48:	ff 91       	pop	r31
    2d4a:	60 5d       	subi	r22, 0xD0	; 208
    2d4c:	6a 33       	cpi	r22, 0x3A	; 58
    2d4e:	0c f0       	brlt	.+2      	; 0x2d52 <ultoa+0x2e>
    2d50:	69 5d       	subi	r22, 0xD9	; 217
    2d52:	61 93       	st	Z+, r22
    2d54:	b9 01       	movw	r22, r18
    2d56:	ca 01       	movw	r24, r20
    2d58:	60 50       	subi	r22, 0x00	; 0
    2d5a:	70 40       	sbci	r23, 0x00	; 0
    2d5c:	80 40       	sbci	r24, 0x00	; 0
    2d5e:	90 40       	sbci	r25, 0x00	; 0
    2d60:	51 f7       	brne	.-44     	; 0x2d36 <ultoa+0x12>
    2d62:	10 82       	st	Z, r1
    2d64:	8f 91       	pop	r24
    2d66:	9f 91       	pop	r25
    2d68:	cf 91       	pop	r28
    2d6a:	0c 94 cd 16 	jmp	0x2d9a	; 0x2d9a <strrev>

00002d6e <utoa>:
    2d6e:	fb 01       	movw	r30, r22
    2d70:	9f 01       	movw	r18, r30
    2d72:	42 30       	cpi	r20, 0x02	; 2
    2d74:	74 f0       	brlt	.+28     	; 0x2d92 <utoa+0x24>
    2d76:	45 32       	cpi	r20, 0x25	; 37
    2d78:	64 f4       	brge	.+24     	; 0x2d92 <utoa+0x24>
    2d7a:	64 2f       	mov	r22, r20
    2d7c:	77 27       	eor	r23, r23
    2d7e:	0e 94 39 16 	call	0x2c72	; 0x2c72 <__udivmodhi4>
    2d82:	80 5d       	subi	r24, 0xD0	; 208
    2d84:	8a 33       	cpi	r24, 0x3A	; 58
    2d86:	0c f0       	brlt	.+2      	; 0x2d8a <utoa+0x1c>
    2d88:	89 5d       	subi	r24, 0xD9	; 217
    2d8a:	81 93       	st	Z+, r24
    2d8c:	cb 01       	movw	r24, r22
    2d8e:	00 97       	sbiw	r24, 0x00	; 0
    2d90:	a1 f7       	brne	.-24     	; 0x2d7a <utoa+0xc>
    2d92:	10 82       	st	Z, r1
    2d94:	c9 01       	movw	r24, r18
    2d96:	0c 94 cd 16 	jmp	0x2d9a	; 0x2d9a <strrev>

00002d9a <strrev>:
    2d9a:	dc 01       	movw	r26, r24
    2d9c:	fc 01       	movw	r30, r24
    2d9e:	67 2f       	mov	r22, r23
    2da0:	71 91       	ld	r23, Z+
    2da2:	77 23       	and	r23, r23
    2da4:	e1 f7       	brne	.-8      	; 0x2d9e <strrev+0x4>
    2da6:	32 97       	sbiw	r30, 0x02	; 2
    2da8:	04 c0       	rjmp	.+8      	; 0x2db2 <strrev+0x18>
    2daa:	7c 91       	ld	r23, X
    2dac:	6d 93       	st	X+, r22
    2dae:	70 83       	st	Z, r23
    2db0:	62 91       	ld	r22, -Z
    2db2:	ae 17       	cp	r26, r30
    2db4:	bf 07       	cpc	r27, r31
    2db6:	c8 f3       	brcs	.-14     	; 0x2daa <strrev+0x10>
    2db8:	08 95       	ret

00002dba <_exit>:
    2dba:	f8 94       	cli

00002dbc <__stop_program>:
    2dbc:	ff cf       	rjmp	.-2      	; 0x2dbc <__stop_program>

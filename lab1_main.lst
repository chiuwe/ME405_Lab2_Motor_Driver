
lab1_main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000009a  00800200  00003814  000038a8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003814  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000017bc  0080029a  0080029a  00003942  2**0
                  ALLOC
  3 .stab         00000c6c  00000000  00000000  00003944  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000002ae  00000000  00000000  000045b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000448  00000000  00000000  00004860  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00007569  00000000  00000000  00004ca8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002a9e  00000000  00000000  0000c211  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002545  00000000  00000000  0000ecaf  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001028  00000000  00000000  000111f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000022ad  00000000  00000000  0001221c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004e21  00000000  00000000  000144c9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000210  00000000  00000000  000192ea  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 c8 01 	jmp	0x390	; 0x390 <__ctors_end>
       4:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
       8:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
       c:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      10:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      14:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      18:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      1c:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      20:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      24:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      28:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      2c:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      30:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      34:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      38:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      3c:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      40:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      44:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      48:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      4c:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      50:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      54:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      58:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      5c:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      60:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      64:	0c 94 b6 0c 	jmp	0x196c	; 0x196c <__vector_25>
      68:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      6c:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      70:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      74:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      78:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      7c:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      80:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      84:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      88:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      8c:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      90:	0c 94 03 0d 	jmp	0x1a06	; 0x1a06 <__vector_36>
      94:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      98:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      9c:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      a0:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      a4:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      a8:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      ac:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      b0:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      b4:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      b8:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      bc:	0c 94 0f 0f 	jmp	0x1e1e	; 0x1e1e <__vector_47>
      c0:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      c4:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>
      c8:	0c 94 f9 01 	jmp	0x3f2	; 0x3f2 <__bad_interrupt>

000000cc <_ZZ4mainE3__c>:
      cc:	4d 45 34 30 35 20 4c 61 62 20 31 20 53 74 61 72     ME405 Lab 1 Star
      dc:	74 69 6e 67 20 50 72 6f 67 72 61 6d 00              ting Program.

000000e9 <_ZZN9task_user3runEvE3__c>:
      e9:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
      f9:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000107 <_ZZN9task_user3runEvE3__c_0>:
     107:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000115 <_ZZN9task_user3runEvE3__c_1>:
     115:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     125:	65 00                                               e.

00000127 <_ZZN9task_user3runEvE3__c_2>:
     127:	3a 57 54 46 3f 00                                   :WTF?.

0000012d <_ZZN9task_user3runEvE3__c_3>:
     12d:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     13d:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

0000014a <_ZZN9task_user18print_help_messageEvE3__c>:
     14a:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     15a:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

00000169 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     169:	20 68 65 6c 70 00                                    help.

0000016f <_ZZN9task_user18print_help_messageEvE3__c_1>:
     16f:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     17f:	68 65 20 41 56 52 00                                he AVR.

00000186 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     186:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     196:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000001a2 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     1a2:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     1b2:	65 20 6f 6e 6c 79 3a 00                             e only:.

000001ba <_ZZN9task_user18print_help_messageEvE3__c_4>:
     1ba:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     1ca:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

000001db <_ZZN9task_user18print_help_messageEvE3__c_5>:
     1db:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     1eb:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     1fb:	6d 61 74 69 6f 6e 00                                mation.

00000202 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     202:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     212:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000220 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     220:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     230:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

0000023b <_ZZN9task_user18print_help_messageEvE3__c_8>:
     23b:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000024a <_ZZN9task_user11show_statusEvE3__c>:
     24a:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     25a:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

00000269 <_ZZN9task_user11show_statusEvE3__c_0>:
     269:	41 70 72 20 31 31 20 32 30 31 34 00                 Apr 11 2014.

00000275 <_ZZN9task_user11show_statusEvE3__c_1>:
     275:	54 69 6d 65 3a 20 00                                Time: .

0000027c <_ZZN9task_user11show_statusEvE3__c_2>:
     27c:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

0000028a <_ZZN9task_user11show_statusEvE3__c_3>:
     28a:	2f 00                                               /.

0000028c <_ZZN9task_user11show_statusEvE3__c_4>:
     28c:	2c 20 4f 43 52 35 41 3d 00                          , OCR5A=.

00000295 <_ZZN8frt_taskC1EPKchjP8emstreamE3__c>:
     295:	54 61 73 6b 20 00                                   Task .

0000029b <_ZZN8frt_taskC1EPKchjP8emstreamE3__c_0>:
     29b:	20 63 72 65 61 74 65 64 00                           created.

000002a4 <_ZZN8frt_taskC1EPKchjP8emstreamE3__c_1>:
     2a4:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

000002b2 <_ZZN8frt_taskC1EPKchjP8emstreamE3__c_2>:
     2b2:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     2c2:	61 73 6b 20 00                                      ask .

000002c7 <_ZZN8frt_task15emergency_resetEvE3__c>:
     2c7:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

000002d6 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     2d6:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

000002e0 <_ZZ17print_task_stacksP8emstreamE3__c>:
     2e0:	1b 5b 31 6d 00                                      .[1m.

000002e5 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     2e5:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000002f0 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     2f0:	1b 5b 32 32 6d 00                                   .[22m.

000002f6 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     2f6:	1b 5b 31 6d 00                                      .[1m.

000002fb <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     2fb:	54 61 73 6b 3a 20 00                                Task: .

00000302 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     302:	1b 5b 32 32 6d 00                                   .[22m.

00000308 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     308:	09 00                                               ..

0000030a <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     30a:	09 00                                               ..

0000030c <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     30c:	2f 00                                               /.

0000030e <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     30e:	09 00                                               ..

00000310 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     310:	09 00                                               ..

00000312 <_ZZ15print_task_listP8emstreamE3__c>:
     312:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000031d <_ZZ15print_task_listP8emstreamE3__c_0>:
     31d:	09 53 74 61 63 6b 00                                .Stack.

00000324 <_ZZ15print_task_listP8emstreamE3__c_1>:
     324:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000335 <_ZZ15print_task_listP8emstreamE3__c_2>:
     335:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000341 <_ZZ15print_task_listP8emstreamE3__c_3>:
     341:	09 52 75 6e 73 00                                   .Runs.

00000347 <_ZZ15print_task_listP8emstreamE3__c_4>:
     347:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

00000358 <_ZZ15print_task_listP8emstreamE3__c_5>:
     358:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

00000364 <_ZZ15print_task_listP8emstreamE3__c_6>:
     364:	09 2d 2d 2d 2d 00                                   .----.

0000036a <_ZZ15print_task_listP8emstreamE3__c_7>:
     36a:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

00000375 <_ZZ15print_task_listP8emstreamE3__c_8>:
     375:	2f 00                                               /.

00000377 <_ZZ15print_task_listP8emstreamE3__c_9>:
     377:	09 09 00                                            ...

0000037a <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     37a:	20 20 00                                              .

0000037d <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     37d:	1b 5b 31 6d 00                                      .[1m.

00000382 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     382:	1b 5b 31 6d 00                                      .[1m.

00000387 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     387:	1b 5b 32 32 6d 00 00                                .[22m..

0000038e <__ctors_start>:
     38e:	19 1b       	sub	r17, r25

00000390 <__ctors_end>:
     390:	11 24       	eor	r1, r1
     392:	1f be       	out	0x3f, r1	; 63
     394:	cf ef       	ldi	r28, 0xFF	; 255
     396:	d1 e2       	ldi	r29, 0x21	; 33
     398:	de bf       	out	0x3e, r29	; 62
     39a:	cd bf       	out	0x3d, r28	; 61

0000039c <__do_copy_data>:
     39c:	12 e0       	ldi	r17, 0x02	; 2
     39e:	a0 e0       	ldi	r26, 0x00	; 0
     3a0:	b2 e0       	ldi	r27, 0x02	; 2
     3a2:	e4 e1       	ldi	r30, 0x14	; 20
     3a4:	f8 e3       	ldi	r31, 0x38	; 56
     3a6:	00 e0       	ldi	r16, 0x00	; 0
     3a8:	0b bf       	out	0x3b, r16	; 59
     3aa:	02 c0       	rjmp	.+4      	; 0x3b0 <__do_copy_data+0x14>
     3ac:	07 90       	elpm	r0, Z+
     3ae:	0d 92       	st	X+, r0
     3b0:	aa 39       	cpi	r26, 0x9A	; 154
     3b2:	b1 07       	cpc	r27, r17
     3b4:	d9 f7       	brne	.-10     	; 0x3ac <__do_copy_data+0x10>
     3b6:	1b be       	out	0x3b, r1	; 59

000003b8 <__do_clear_bss>:
     3b8:	1a e1       	ldi	r17, 0x1A	; 26
     3ba:	aa e9       	ldi	r26, 0x9A	; 154
     3bc:	b2 e0       	ldi	r27, 0x02	; 2
     3be:	01 c0       	rjmp	.+2      	; 0x3c2 <.do_clear_bss_start>

000003c0 <.do_clear_bss_loop>:
     3c0:	1d 92       	st	X+, r1

000003c2 <.do_clear_bss_start>:
     3c2:	a6 35       	cpi	r26, 0x56	; 86
     3c4:	b1 07       	cpc	r27, r17
     3c6:	e1 f7       	brne	.-8      	; 0x3c0 <.do_clear_bss_loop>

000003c8 <__do_global_ctors>:
     3c8:	13 e0       	ldi	r17, 0x03	; 3
     3ca:	c0 e9       	ldi	r28, 0x90	; 144
     3cc:	d3 e0       	ldi	r29, 0x03	; 3
     3ce:	00 e0       	ldi	r16, 0x00	; 0
     3d0:	06 c0       	rjmp	.+12     	; 0x3de <__do_global_ctors+0x16>
     3d2:	22 97       	sbiw	r28, 0x02	; 2
     3d4:	01 09       	sbc	r16, r1
     3d6:	fe 01       	movw	r30, r28
     3d8:	0b bf       	out	0x3b, r16	; 59
     3da:	0e 94 9a 1b 	call	0x3734	; 0x3734 <__tablejump_elpm__>
     3de:	ce 38       	cpi	r28, 0x8E	; 142
     3e0:	d1 07       	cpc	r29, r17
     3e2:	80 e0       	ldi	r24, 0x00	; 0
     3e4:	08 07       	cpc	r16, r24
     3e6:	a9 f7       	brne	.-22     	; 0x3d2 <__do_global_ctors+0xa>
     3e8:	1b be       	out	0x3b, r1	; 59
     3ea:	0e 94 cf 1a 	call	0x359e	; 0x359e <main>
     3ee:	0c 94 08 1c 	jmp	0x3810	; 0x3810 <_exit>

000003f2 <__bad_interrupt>:
     3f2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000003f6 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     3f6:	0f 93       	push	r16
     3f8:	1f 93       	push	r17
     3fa:	cf 93       	push	r28
     3fc:	df 93       	push	r29
     3fe:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     400:	0e 94 89 05 	call	0xb12	; 0xb12 <_ZN8frt_taskC1EPKchjP8emstream>
     404:	8b e0       	ldi	r24, 0x0B	; 11
     406:	92 e0       	ldi	r25, 0x02	; 2
     408:	99 83       	std	Y+1, r25	; 0x01
     40a:	88 83       	st	Y, r24
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     40c:	df 91       	pop	r29
     40e:	cf 91       	pop	r28
     410:	1f 91       	pop	r17
     412:	0f 91       	pop	r16
     414:	08 95       	ret

00000416 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     416:	0f 93       	push	r16
     418:	1f 93       	push	r17
     41a:	cf 93       	push	r28
     41c:	df 93       	push	r29
     41e:	8c 01       	movw	r16, r24
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     420:	fc 01       	movw	r30, r24
     422:	86 81       	ldd	r24, Z+6	; 0x06
     424:	97 81       	ldd	r25, Z+7	; 0x07
     426:	6a e0       	ldi	r22, 0x0A	; 10
     428:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     42c:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     42e:	6a e4       	ldi	r22, 0x4A	; 74
     430:	71 e0       	ldi	r23, 0x01	; 1
     432:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     436:	ce 01       	movw	r24, r28
     438:	6a e0       	ldi	r22, 0x0A	; 10
     43a:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     43e:	ec 01       	movw	r28, r24
     440:	69 e6       	ldi	r22, 0x69	; 105
     442:	71 e0       	ldi	r23, 0x01	; 1
     444:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     448:	ce 01       	movw	r24, r28
     44a:	66 e0       	ldi	r22, 0x06	; 6
     44c:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     450:	f8 01       	movw	r30, r16
     452:	86 81       	ldd	r24, Z+6	; 0x06
     454:	97 81       	ldd	r25, Z+7	; 0x07
     456:	6a e0       	ldi	r22, 0x0A	; 10
     458:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     45c:	ec 01       	movw	r28, r24
     45e:	6f e6       	ldi	r22, 0x6F	; 111
     460:	71 e0       	ldi	r23, 0x01	; 1
     462:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     466:	ce 01       	movw	r24, r28
     468:	66 e0       	ldi	r22, 0x06	; 6
     46a:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     46e:	f8 01       	movw	r30, r16
     470:	86 81       	ldd	r24, Z+6	; 0x06
     472:	97 81       	ldd	r25, Z+7	; 0x07
     474:	6a e0       	ldi	r22, 0x0A	; 10
     476:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     47a:	ec 01       	movw	r28, r24
     47c:	66 e8       	ldi	r22, 0x86	; 134
     47e:	71 e0       	ldi	r23, 0x01	; 1
     480:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     484:	ce 01       	movw	r24, r28
     486:	66 e0       	ldi	r22, 0x06	; 6
     488:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     48c:	f8 01       	movw	r30, r16
     48e:	86 81       	ldd	r24, Z+6	; 0x06
     490:	97 81       	ldd	r25, Z+7	; 0x07
     492:	6a e0       	ldi	r22, 0x0A	; 10
     494:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     498:	ec 01       	movw	r28, r24
     49a:	62 ea       	ldi	r22, 0xA2	; 162
     49c:	71 e0       	ldi	r23, 0x01	; 1
     49e:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     4a2:	ce 01       	movw	r24, r28
     4a4:	66 e0       	ldi	r22, 0x06	; 6
     4a6:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     4aa:	f8 01       	movw	r30, r16
     4ac:	86 81       	ldd	r24, Z+6	; 0x06
     4ae:	97 81       	ldd	r25, Z+7	; 0x07
     4b0:	6a e0       	ldi	r22, 0x0A	; 10
     4b2:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     4b6:	ec 01       	movw	r28, r24
     4b8:	6a eb       	ldi	r22, 0xBA	; 186
     4ba:	71 e0       	ldi	r23, 0x01	; 1
     4bc:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     4c0:	ce 01       	movw	r24, r28
     4c2:	66 e0       	ldi	r22, 0x06	; 6
     4c4:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     4c8:	f8 01       	movw	r30, r16
     4ca:	86 81       	ldd	r24, Z+6	; 0x06
     4cc:	97 81       	ldd	r25, Z+7	; 0x07
     4ce:	6a e0       	ldi	r22, 0x0A	; 10
     4d0:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     4d4:	ec 01       	movw	r28, r24
     4d6:	6b ed       	ldi	r22, 0xDB	; 219
     4d8:	71 e0       	ldi	r23, 0x01	; 1
     4da:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     4de:	ce 01       	movw	r24, r28
     4e0:	66 e0       	ldi	r22, 0x06	; 6
     4e2:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     4e6:	f8 01       	movw	r30, r16
     4e8:	86 81       	ldd	r24, Z+6	; 0x06
     4ea:	97 81       	ldd	r25, Z+7	; 0x07
     4ec:	6a e0       	ldi	r22, 0x0A	; 10
     4ee:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     4f2:	ec 01       	movw	r28, r24
     4f4:	62 e0       	ldi	r22, 0x02	; 2
     4f6:	72 e0       	ldi	r23, 0x02	; 2
     4f8:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     4fc:	ce 01       	movw	r24, r28
     4fe:	66 e0       	ldi	r22, 0x06	; 6
     500:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     504:	f8 01       	movw	r30, r16
     506:	86 81       	ldd	r24, Z+6	; 0x06
     508:	97 81       	ldd	r25, Z+7	; 0x07
     50a:	6a e0       	ldi	r22, 0x0A	; 10
     50c:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     510:	ec 01       	movw	r28, r24
     512:	60 e2       	ldi	r22, 0x20	; 32
     514:	72 e0       	ldi	r23, 0x02	; 2
     516:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     51a:	ce 01       	movw	r24, r28
     51c:	66 e0       	ldi	r22, 0x06	; 6
     51e:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     522:	f8 01       	movw	r30, r16
     524:	86 81       	ldd	r24, Z+6	; 0x06
     526:	97 81       	ldd	r25, Z+7	; 0x07
     528:	6a e0       	ldi	r22, 0x0A	; 10
     52a:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     52e:	ec 01       	movw	r28, r24
     530:	6b e3       	ldi	r22, 0x3B	; 59
     532:	72 e0       	ldi	r23, 0x02	; 2
     534:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     538:	ce 01       	movw	r24, r28
     53a:	66 e0       	ldi	r22, 0x06	; 6
     53c:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
}
     540:	df 91       	pop	r29
     542:	cf 91       	pop	r28
     544:	1f 91       	pop	r17
     546:	0f 91       	pop	r16
     548:	08 95       	ret

0000054a <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     54a:	ef 92       	push	r14
     54c:	ff 92       	push	r15
     54e:	0f 93       	push	r16
     550:	1f 93       	push	r17
     552:	cf 93       	push	r28
     554:	df 93       	push	r29
     556:	00 d0       	rcall	.+0      	; 0x558 <_ZN9task_user11show_statusEv+0xe>
     558:	00 d0       	rcall	.+0      	; 0x55a <_ZN9task_user11show_statusEv+0x10>
     55a:	00 d0       	rcall	.+0      	; 0x55c <_ZN9task_user11show_statusEv+0x12>
     55c:	cd b7       	in	r28, 0x3d	; 61
     55e:	de b7       	in	r29, 0x3e	; 62
     560:	7c 01       	movw	r14, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     562:	19 82       	std	Y+1, r1	; 0x01
     564:	1a 82       	std	Y+2, r1	; 0x02
     566:	1b 82       	std	Y+3, r1	; 0x03
     568:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     56a:	1e 82       	std	Y+6, r1	; 0x06
     56c:	1d 82       	std	Y+5, r1	; 0x05
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     56e:	fc 01       	movw	r30, r24
     570:	86 81       	ldd	r24, Z+6	; 0x06
     572:	97 81       	ldd	r25, Z+7	; 0x07
     574:	66 e0       	ldi	r22, 0x06	; 6
     576:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     57a:	6a e0       	ldi	r22, 0x0A	; 10
     57c:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     580:	8c 01       	movw	r16, r24
     582:	6a e4       	ldi	r22, 0x4A	; 74
     584:	72 e0       	ldi	r23, 0x02	; 2
     586:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     58a:	c8 01       	movw	r24, r16
     58c:	6a e0       	ldi	r22, 0x0A	; 10
     58e:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     592:	8c 01       	movw	r16, r24
     594:	69 e6       	ldi	r22, 0x69	; 105
     596:	72 e0       	ldi	r23, 0x02	; 2
     598:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     59c:	c8 01       	movw	r24, r16
     59e:	66 e0       	ldi	r22, 0x06	; 6
     5a0:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     5a4:	6a e0       	ldi	r22, 0x0A	; 10
     5a6:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     5aa:	8c 01       	movw	r16, r24
     5ac:	65 e7       	ldi	r22, 0x75	; 117
     5ae:	72 e0       	ldi	r23, 0x02	; 2
     5b0:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     5b4:	ce 01       	movw	r24, r28
     5b6:	01 96       	adiw	r24, 0x01	; 1
     5b8:	0e 94 49 09 	call	0x1292	; 0x1292 <_ZN10time_stamp10set_to_nowEv>
     5bc:	bc 01       	movw	r22, r24
     5be:	c8 01       	movw	r24, r16
     5c0:	0e 94 dc 08 	call	0x11b8	; 0x11b8 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     5c4:	6a e0       	ldi	r22, 0x0A	; 10
     5c6:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     5ca:	8c 01       	movw	r16, r24
     5cc:	6c e7       	ldi	r22, 0x7C	; 124
     5ce:	72 e0       	ldi	r23, 0x02	; 2
     5d0:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     5d4:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <xPortGetFreeHeapSize>
     5d8:	bc 01       	movw	r22, r24
     5da:	c8 01       	movw	r24, r16
     5dc:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <_ZN8emstreamlsEj>
     5e0:	6a e0       	ldi	r22, 0x0A	; 10
     5e2:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     5e6:	8c 01       	movw	r16, r24
     5e8:	6a e8       	ldi	r22, 0x8A	; 138
     5ea:	72 e0       	ldi	r23, 0x02	; 2
     5ec:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     5f0:	c8 01       	movw	r24, r16
     5f2:	48 e3       	ldi	r20, 0x38	; 56
     5f4:	57 e1       	ldi	r21, 0x17	; 23
     5f6:	60 e0       	ldi	r22, 0x00	; 0
     5f8:	70 e0       	ldi	r23, 0x00	; 0
     5fa:	0e 94 13 0b 	call	0x1626	; 0x1626 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	#if (defined OCR5A)
		*p_serial << PMS (", OCR5A=") << OCR3A << endl << endl;
     5fe:	f7 01       	movw	r30, r14
     600:	86 81       	ldd	r24, Z+6	; 0x06
     602:	97 81       	ldd	r25, Z+7	; 0x07
     604:	6a e0       	ldi	r22, 0x0A	; 10
     606:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     60a:	8c 01       	movw	r16, r24
     60c:	6c e8       	ldi	r22, 0x8C	; 140
     60e:	72 e0       	ldi	r23, 0x02	; 2
     610:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     614:	60 91 98 00 	lds	r22, 0x0098
     618:	70 91 99 00 	lds	r23, 0x0099
     61c:	c8 01       	movw	r24, r16
     61e:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <_ZN8emstreamlsEj>
     622:	66 e0       	ldi	r22, 0x06	; 6
     624:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     628:	66 e0       	ldi	r22, 0x06	; 6
     62a:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
	#else
		*p_serial << PMS (", OCR1A=") << OCR1A << endl << endl;
	#endif

	// Have the tasks print their status
	print_task_list (p_serial);
     62e:	f7 01       	movw	r30, r14
     630:	86 81       	ldd	r24, Z+6	; 0x06
     632:	97 81       	ldd	r25, Z+7	; 0x07
     634:	0e 94 cb 07 	call	0xf96	; 0xf96 <_Z15print_task_listP8emstream>
}
     638:	26 96       	adiw	r28, 0x06	; 6
     63a:	0f b6       	in	r0, 0x3f	; 63
     63c:	f8 94       	cli
     63e:	de bf       	out	0x3e, r29	; 62
     640:	0f be       	out	0x3f, r0	; 63
     642:	cd bf       	out	0x3d, r28	; 61
     644:	df 91       	pop	r29
     646:	cf 91       	pop	r28
     648:	1f 91       	pop	r17
     64a:	0f 91       	pop	r16
     64c:	ff 90       	pop	r15
     64e:	ef 90       	pop	r14
     650:	08 95       	ret

00000652 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     652:	cf 93       	push	r28
     654:	df 93       	push	r29
     656:	cd b7       	in	r28, 0x3d	; 61
     658:	de b7       	in	r29, 0x3e	; 62
     65a:	28 97       	sbiw	r28, 0x08	; 8
     65c:	0f b6       	in	r0, 0x3f	; 63
     65e:	f8 94       	cli
     660:	de bf       	out	0x3e, r29	; 62
     662:	0f be       	out	0x3f, r0	; 63
     664:	cd bf       	out	0x3d, r28	; 61
     666:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     668:	19 82       	std	Y+1, r1	; 0x01
     66a:	1a 82       	std	Y+2, r1	; 0x02
     66c:	1b 82       	std	Y+3, r1	; 0x03
     66e:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     670:	1e 82       	std	Y+6, r1	; 0x06
     672:	1d 82       	std	Y+5, r1	; 0x05
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     674:	dc 01       	movw	r26, r24
     676:	16 96       	adiw	r26, 0x06	; 6
     678:	8d 91       	ld	r24, X+
     67a:	9c 91       	ld	r25, X
     67c:	17 97       	sbiw	r26, 0x07	; 7
     67e:	6a e0       	ldi	r22, 0x0A	; 10
     680:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     684:	7c 01       	movw	r14, r24
     686:	69 ee       	ldi	r22, 0xE9	; 233
     688:	70 e0       	ldi	r23, 0x00	; 0
     68a:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     68e:	c7 01       	movw	r24, r14
     690:	66 e0       	ldi	r22, 0x06	; 6
     692:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     696:	f8 01       	movw	r30, r16
     698:	84 85       	ldd	r24, Z+12	; 0x0c
     69a:	88 23       	and	r24, r24
     69c:	91 f5       	brne	.+100    	; 0x702 <_ZN9task_user3runEv+0xb0>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     69e:	86 81       	ldd	r24, Z+6	; 0x06
     6a0:	97 81       	ldd	r25, Z+7	; 0x07
     6a2:	dc 01       	movw	r26, r24
     6a4:	ed 91       	ld	r30, X+
     6a6:	fc 91       	ld	r31, X
     6a8:	04 80       	ldd	r0, Z+4	; 0x04
     6aa:	f5 81       	ldd	r31, Z+5	; 0x05
     6ac:	e0 2d       	mov	r30, r0
     6ae:	09 95       	icall
     6b0:	88 23       	and	r24, r24
     6b2:	09 f4       	brne	.+2      	; 0x6b6 <_ZN9task_user3runEv+0x64>
     6b4:	a6 c0       	rjmp	.+332    	; 0x802 <_ZN9task_user3runEv+0x1b0>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     6b6:	f8 01       	movw	r30, r16
     6b8:	86 81       	ldd	r24, Z+6	; 0x06
     6ba:	97 81       	ldd	r25, Z+7	; 0x07
     6bc:	dc 01       	movw	r26, r24
     6be:	ed 91       	ld	r30, X+
     6c0:	fc 91       	ld	r31, X
     6c2:	06 80       	ldd	r0, Z+6	; 0x06
     6c4:	f7 81       	ldd	r31, Z+7	; 0x07
     6c6:	e0 2d       	mov	r30, r0
     6c8:	09 95       	icall

					// In this switch statement, we respond to different characters
					switch (char_in)
     6ca:	81 30       	cpi	r24, 0x01	; 1
     6cc:	09 f4       	brne	.+2      	; 0x6d0 <_ZN9task_user3runEv+0x7e>
     6ce:	91 c0       	rjmp	.+290    	; 0x7f2 <_ZN9task_user3runEv+0x1a0>
     6d0:	83 30       	cpi	r24, 0x03	; 3
     6d2:	09 f4       	brne	.+2      	; 0x6d6 <_ZN9task_user3runEv+0x84>
     6d4:	73 c0       	rjmp	.+230    	; 0x7bc <_ZN9task_user3runEv+0x16a>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
     6d6:	f8 01       	movw	r30, r16
     6d8:	86 85       	ldd	r24, Z+14	; 0x0e
     6da:	97 85       	ldd	r25, Z+15	; 0x0f
     6dc:	a0 89       	ldd	r26, Z+16	; 0x10
     6de:	b1 89       	ldd	r27, Z+17	; 0x11
     6e0:	01 96       	adiw	r24, 0x01	; 1
     6e2:	a1 1d       	adc	r26, r1
     6e4:	b1 1d       	adc	r27, r1
     6e6:	86 87       	std	Z+14, r24	; 0x0e
     6e8:	97 87       	std	Z+15, r25	; 0x0f
     6ea:	a0 8b       	std	Z+16, r26	; 0x10
     6ec:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
     6ee:	61 e0       	ldi	r22, 0x01	; 1
     6f0:	70 e0       	ldi	r23, 0x00	; 0
     6f2:	80 e0       	ldi	r24, 0x00	; 0
     6f4:	90 e0       	ldi	r25, 0x00	; 0
     6f6:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <vTaskDelay>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     6fa:	f8 01       	movw	r30, r16
     6fc:	84 85       	ldd	r24, Z+12	; 0x0c
     6fe:	88 23       	and	r24, r24
     700:	71 f2       	breq	.-100    	; 0x69e <_ZN9task_user3runEv+0x4c>
     702:	81 30       	cpi	r24, 0x01	; 1
     704:	d9 f0       	breq	.+54     	; 0x73c <_ZN9task_user3runEv+0xea>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
     706:	f8 01       	movw	r30, r16
     708:	86 81       	ldd	r24, Z+6	; 0x06
     70a:	97 81       	ldd	r25, Z+7	; 0x07
     70c:	6a e0       	ldi	r22, 0x0A	; 10
     70e:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     712:	8c 01       	movw	r16, r24
     714:	6d e2       	ldi	r22, 0x2D	; 45
     716:	71 e0       	ldi	r23, 0x01	; 1
     718:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     71c:	c8 01       	movw	r24, r16
     71e:	66 e0       	ldi	r22, 0x06	; 6
     720:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
     724:	2b e0       	ldi	r18, 0x0B	; 11
     726:	88 e1       	ldi	r24, 0x18	; 24
     728:	90 e0       	ldi	r25, 0x00	; 0
     72a:	0f b6       	in	r0, 0x3f	; 63
     72c:	f8 94       	cli
     72e:	a8 95       	wdr
     730:	80 93 60 00 	sts	0x0060, r24
     734:	0f be       	out	0x3f, r0	; 63
     736:	20 93 60 00 	sts	0x0060, r18
     73a:	ff cf       	rjmp	.-2      	; 0x73a <_ZN9task_user3runEv+0xe8>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
     73c:	86 81       	ldd	r24, Z+6	; 0x06
     73e:	97 81       	ldd	r25, Z+7	; 0x07
     740:	dc 01       	movw	r26, r24
     742:	ed 91       	ld	r30, X+
     744:	fc 91       	ld	r31, X
     746:	04 80       	ldd	r0, Z+4	; 0x04
     748:	f5 81       	ldd	r31, Z+5	; 0x05
     74a:	e0 2d       	mov	r30, r0
     74c:	09 95       	icall
     74e:	88 23       	and	r24, r24
     750:	09 f4       	brne	.+2      	; 0x754 <_ZN9task_user3runEv+0x102>
     752:	c1 cf       	rjmp	.-126    	; 0x6d6 <_ZN9task_user3runEv+0x84>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
     754:	f8 01       	movw	r30, r16
     756:	86 81       	ldd	r24, Z+6	; 0x06
     758:	97 81       	ldd	r25, Z+7	; 0x07
     75a:	dc 01       	movw	r26, r24
     75c:	ed 91       	ld	r30, X+
     75e:	fc 91       	ld	r31, X
     760:	06 80       	ldd	r0, Z+6	; 0x06
     762:	f7 81       	ldd	r31, Z+7	; 0x07
     764:	e0 2d       	mov	r30, r0
     766:	09 95       	icall
     768:	68 2f       	mov	r22, r24

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
     76a:	88 36       	cpi	r24, 0x68	; 104
     76c:	09 f4       	brne	.+2      	; 0x770 <_ZN9task_user3runEv+0x11e>
     76e:	91 c0       	rjmp	.+290    	; 0x892 <_ZN9task_user3runEv+0x240>
     770:	89 36       	cpi	r24, 0x69	; 105
     772:	0c f0       	brlt	.+2      	; 0x776 <_ZN9task_user3runEv+0x124>
     774:	78 c0       	rjmp	.+240    	; 0x866 <_ZN9task_user3runEv+0x214>
     776:	8b 31       	cpi	r24, 0x1B	; 27
     778:	09 f4       	brne	.+2      	; 0x77c <_ZN9task_user3runEv+0x12a>
     77a:	61 c0       	rjmp	.+194    	; 0x83e <_ZN9task_user3runEv+0x1ec>
     77c:	85 36       	cpi	r24, 0x65	; 101
     77e:	09 f4       	brne	.+2      	; 0x782 <_ZN9task_user3runEv+0x130>
     780:	5e c0       	rjmp	.+188    	; 0x83e <_ZN9task_user3runEv+0x1ec>
							transition_to (0);
							break;

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
     782:	f8 01       	movw	r30, r16
     784:	a6 81       	ldd	r26, Z+6	; 0x06
     786:	b7 81       	ldd	r27, Z+7	; 0x07
     788:	ed 91       	ld	r30, X+
     78a:	fc 91       	ld	r31, X
     78c:	11 97       	sbiw	r26, 0x01	; 1
     78e:	02 80       	ldd	r0, Z+2	; 0x02
     790:	f3 81       	ldd	r31, Z+3	; 0x03
     792:	e0 2d       	mov	r30, r0
     794:	cd 01       	movw	r24, r26
     796:	09 95       	icall
							*p_serial << PMS (":WTF?") << endl;
     798:	d8 01       	movw	r26, r16
     79a:	16 96       	adiw	r26, 0x06	; 6
     79c:	8d 91       	ld	r24, X+
     79e:	9c 91       	ld	r25, X
     7a0:	17 97       	sbiw	r26, 0x07	; 7
     7a2:	6a e0       	ldi	r22, 0x0A	; 10
     7a4:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     7a8:	7c 01       	movw	r14, r24
     7aa:	67 e2       	ldi	r22, 0x27	; 39
     7ac:	71 e0       	ldi	r23, 0x01	; 1
     7ae:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     7b2:	c7 01       	movw	r24, r14
     7b4:	66 e0       	ldi	r22, 0x06	; 6
     7b6:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
							break;
     7ba:	8d cf       	rjmp	.-230    	; 0x6d6 <_ZN9task_user3runEv+0x84>
					// In this switch statement, we respond to different characters
					switch (char_in)
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
     7bc:	f8 01       	movw	r30, r16
     7be:	86 81       	ldd	r24, Z+6	; 0x06
     7c0:	97 81       	ldd	r25, Z+7	; 0x07
     7c2:	6a e0       	ldi	r22, 0x0A	; 10
     7c4:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     7c8:	8c 01       	movw	r16, r24
     7ca:	67 e0       	ldi	r22, 0x07	; 7
     7cc:	71 e0       	ldi	r23, 0x01	; 1
     7ce:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     7d2:	c8 01       	movw	r24, r16
     7d4:	66 e0       	ldi	r22, 0x06	; 6
     7d6:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
     7da:	2b e0       	ldi	r18, 0x0B	; 11
     7dc:	88 e1       	ldi	r24, 0x18	; 24
     7de:	90 e0       	ldi	r25, 0x00	; 0
     7e0:	0f b6       	in	r0, 0x3f	; 63
     7e2:	f8 94       	cli
     7e4:	a8 95       	wdr
     7e6:	80 93 60 00 	sts	0x0060, r24
     7ea:	0f be       	out	0x3f, r0	; 63
     7ec:	20 93 60 00 	sts	0x0060, r18
     7f0:	ff cf       	rjmp	.-2      	; 0x7f0 <_ZN9task_user3runEv+0x19e>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
     7f2:	c8 01       	movw	r24, r16
     7f4:	0e 94 0b 02 	call	0x416	; 0x416 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
     7f8:	c8 01       	movw	r24, r16
     7fa:	61 e0       	ldi	r22, 0x01	; 1
     7fc:	0e 94 85 05 	call	0xb0a	; 0xb0a <_ZN8frt_task13transition_toEh>
							break;
     800:	6a cf       	rjmp	.-300    	; 0x6d6 <_ZN9task_user3runEv+0x84>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
     802:	8a e9       	ldi	r24, 0x9A	; 154
     804:	92 e0       	ldi	r25, 0x02	; 2
     806:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <_ZN14frt_text_queue14check_for_charEv>
     80a:	88 23       	and	r24, r24
     80c:	09 f4       	brne	.+2      	; 0x810 <_ZN9task_user3runEv+0x1be>
     80e:	63 cf       	rjmp	.-314    	; 0x6d6 <_ZN9task_user3runEv+0x84>
				{
					p_serial->putchar (print_ser_queue.getchar ());
     810:	d8 01       	movw	r26, r16
     812:	16 96       	adiw	r26, 0x06	; 6
     814:	ed 90       	ld	r14, X+
     816:	fc 90       	ld	r15, X
     818:	17 97       	sbiw	r26, 0x07	; 7
     81a:	d7 01       	movw	r26, r14
     81c:	ed 91       	ld	r30, X+
     81e:	fc 91       	ld	r31, X
     820:	22 81       	ldd	r18, Z+2	; 0x02
     822:	33 81       	ldd	r19, Z+3	; 0x03
     824:	38 87       	std	Y+8, r19	; 0x08
     826:	2f 83       	std	Y+7, r18	; 0x07
     828:	8a e9       	ldi	r24, 0x9A	; 154
     82a:	92 e0       	ldi	r25, 0x02	; 2
     82c:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <_ZN14frt_text_queue7getcharEv>
     830:	68 2f       	mov	r22, r24
     832:	c7 01       	movw	r24, r14
     834:	2f 81       	ldd	r18, Y+7	; 0x07
     836:	38 85       	ldd	r19, Y+8	; 0x08
     838:	f9 01       	movw	r30, r18
     83a:	09 95       	icall
     83c:	4c cf       	rjmp	.-360    	; 0x6d6 <_ZN9task_user3runEv+0x84>
							break;

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
     83e:	f8 01       	movw	r30, r16
     840:	86 81       	ldd	r24, Z+6	; 0x06
     842:	97 81       	ldd	r25, Z+7	; 0x07
     844:	6a e0       	ldi	r22, 0x0A	; 10
     846:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     84a:	7c 01       	movw	r14, r24
     84c:	65 e1       	ldi	r22, 0x15	; 21
     84e:	71 e0       	ldi	r23, 0x01	; 1
     850:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     854:	c7 01       	movw	r24, r14
     856:	66 e0       	ldi	r22, 0x06	; 6
     858:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
     85c:	c8 01       	movw	r24, r16
     85e:	60 e0       	ldi	r22, 0x00	; 0
     860:	0e 94 85 05 	call	0xb0a	; 0xb0a <_ZN8frt_task13transition_toEh>
							break;
     864:	38 cf       	rjmp	.-400    	; 0x6d6 <_ZN9task_user3runEv+0x84>
				{											// character, read
					char_in = p_serial->getchar ();			// the character

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
     866:	83 37       	cpi	r24, 0x73	; 115
     868:	e1 f0       	breq	.+56     	; 0x8a2 <_ZN9task_user3runEv+0x250>
     86a:	86 37       	cpi	r24, 0x76	; 118
     86c:	b1 f0       	breq	.+44     	; 0x89a <_ZN9task_user3runEv+0x248>
     86e:	8e 36       	cpi	r24, 0x6E	; 110
     870:	09 f0       	breq	.+2      	; 0x874 <_ZN9task_user3runEv+0x222>
     872:	87 cf       	rjmp	.-242    	; 0x782 <_ZN9task_user3runEv+0x130>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
     874:	f8 01       	movw	r30, r16
     876:	e6 80       	ldd	r14, Z+6	; 0x06
     878:	f7 80       	ldd	r15, Z+7	; 0x07
     87a:	ce 01       	movw	r24, r28
     87c:	01 96       	adiw	r24, 0x01	; 1
     87e:	0e 94 49 09 	call	0x1292	; 0x1292 <_ZN10time_stamp10set_to_nowEv>
     882:	bc 01       	movw	r22, r24
     884:	c7 01       	movw	r24, r14
     886:	0e 94 dc 08 	call	0x11b8	; 0x11b8 <_ZlsR8emstreamR10time_stamp>
     88a:	66 e0       	ldi	r22, 0x06	; 6
     88c:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
							break;
     890:	22 cf       	rjmp	.-444    	; 0x6d6 <_ZN9task_user3runEv+0x84>
							print_task_stacks (p_serial);
							break;

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
     892:	c8 01       	movw	r24, r16
     894:	0e 94 0b 02 	call	0x416	; 0x416 <_ZN9task_user18print_help_messageEv>
							break;
     898:	1e cf       	rjmp	.-452    	; 0x6d6 <_ZN9task_user3runEv+0x84>
							*p_serial << (a_time.set_to_now ()) << endl;
							break;

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
     89a:	c8 01       	movw	r24, r16
     89c:	0e 94 a5 02 	call	0x54a	; 0x54a <_ZN9task_user11show_statusEv>
							break;
     8a0:	1a cf       	rjmp	.-460    	; 0x6d6 <_ZN9task_user3runEv+0x84>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
     8a2:	d8 01       	movw	r26, r16
     8a4:	16 96       	adiw	r26, 0x06	; 6
     8a6:	8d 91       	ld	r24, X+
     8a8:	9c 91       	ld	r25, X
     8aa:	17 97       	sbiw	r26, 0x07	; 7
     8ac:	0e 94 db 06 	call	0xdb6	; 0xdb6 <_Z17print_task_stacksP8emstream>
							break;
     8b0:	12 cf       	rjmp	.-476    	; 0x6d6 <_ZN9task_user3runEv+0x84>

000008b2 <_ZN15task_brightness3runEv>:
 *  loop, it reads the A/D converter and uses the result to control the brightness of 
 *  an LED. 
 */

void task_brightness::run (void)
{
     8b2:	cf 93       	push	r28
     8b4:	df 93       	push	r29
     8b6:	00 d0       	rcall	.+0      	; 0x8b8 <_ZN15task_brightness3runEv+0x6>
     8b8:	00 d0       	rcall	.+0      	; 0x8ba <_ZN15task_brightness3runEv+0x8>
     8ba:	00 d0       	rcall	.+0      	; 0x8bc <_ZN15task_brightness3runEv+0xa>
     8bc:	cd b7       	in	r28, 0x3d	; 61
     8be:	de b7       	in	r29, 0x3e	; 62
     8c0:	9e 83       	std	Y+6, r25	; 0x06
     8c2:	8d 83       	std	Y+5, r24	; 0x05
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     8c4:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <xTaskGetTickCount>
     8c8:	dc 01       	movw	r26, r24
     8ca:	cb 01       	movw	r24, r22
     8cc:	89 83       	std	Y+1, r24	; 0x01
     8ce:	9a 83       	std	Y+2, r25	; 0x02
     8d0:	ab 83       	std	Y+3, r26	; 0x03
     8d2:	bc 83       	std	Y+4, r27	; 0x04

	// Create an analog to digital converter driver object and a variable in which to
	// store its output. The variable p_my_adc only exists within this run() method,
	// so the A/D converter cannot be used from any other function or method
	motor_driver* p_my_motor_driver = new motor_driver(p_serial);
     8d4:	82 e0       	ldi	r24, 0x02	; 2
     8d6:	90 e0       	ldi	r25, 0x00	; 0
     8d8:	0e 94 10 0a 	call	0x1420	; 0x1420 <_Znwj>
     8dc:	ed 81       	ldd	r30, Y+5	; 0x05
     8de:	fe 81       	ldd	r31, Y+6	; 0x06
     8e0:	66 81       	ldd	r22, Z+6	; 0x06
     8e2:	77 81       	ldd	r23, Z+7	; 0x07
     8e4:	0e 94 46 05 	call	0xa8c	; 0xa8c <_ZN12motor_driverC1EP8emstream>

	// Configure counter/timer 3 as a PWM for LED brightness. First set the data
	// direction register so that the pin used for the PWM will be an output. The 
	// pin is Port E pin 4, which is also OC3B (Output Compare B for Timer 3)
	DDRE = (1 << 4);
     8e8:	80 e1       	ldi	r24, 0x10	; 16
     8ea:	8d b9       	out	0x0d, r24	; 13
	// To set 8-bit fast PWM mode we must set bits WGM30 and WGM32, which are in two
	// different registers (ugh). We use COM3B1 and Com3B0 to set up the PWM so that
	// the pin output will have inverted sense, that is, a 0 is on and a 1 is off; 
	// this is needed because the LED connects from Vcc to the pin. 
	TCCR3A = (1 << WGM30)
			 | (1 << COM3B1) | (1 << COM3B0);
     8ec:	81 e3       	ldi	r24, 0x31	; 49
     8ee:	80 93 90 00 	sts	0x0090, r24

	// The CS31 and CS30 bits set the prescaler for this timer/counter to run the
	// timer at F_CPU / 64
	TCCR3B = (1 << WGM32)
			 | (1 << CS31)  | (1 << CS30);
     8f2:	8b e0       	ldi	r24, 0x0B	; 11
     8f4:	80 93 91 00 	sts	0x0091, r24
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     8f8:	ce 01       	movw	r24, r28
     8fa:	01 96       	adiw	r24, 0x01	; 1
     8fc:	44 e6       	ldi	r20, 0x64	; 100
     8fe:	50 e0       	ldi	r21, 0x00	; 0
     900:	60 e0       	ldi	r22, 0x00	; 0
     902:	70 e0       	ldi	r23, 0x00	; 0
     904:	0e 94 db 16 	call	0x2db6	; 0x2db6 <vTaskDelayUntil>
     908:	f7 cf       	rjmp	.-18     	; 0x8f8 <_ZN15task_brightness3runEv+0x46>

0000090a <_ZN15task_brightnessC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_brightness::task_brightness (const char* a_name, 
     90a:	0f 93       	push	r16
     90c:	1f 93       	push	r17
     90e:	cf 93       	push	r28
     910:	df 93       	push	r29
     912:	ec 01       	movw	r28, r24
								 unsigned portBASE_TYPE a_priority, 
								 size_t a_stack_size,
								 emstream* p_ser_dev
								)
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     914:	0e 94 89 05 	call	0xb12	; 0xb12 <_ZN8frt_taskC1EPKchjP8emstream>
     918:	83 e1       	ldi	r24, 0x13	; 19
     91a:	92 e0       	ldi	r25, 0x02	; 2
     91c:	99 83       	std	Y+1, r25	; 0x01
     91e:	88 83       	st	Y, r24
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     920:	df 91       	pop	r29
     922:	cf 91       	pop	r28
     924:	1f 91       	pop	r17
     926:	0f 91       	pop	r16
     928:	08 95       	ret

0000092a <_ZN3adcC1EP8emstream>:
/** \brief This constructor sets up an A/D converter. 
 *  \details \b Details: The A/D converter is enabled and the division factor is set to 32.
 *  @param p_serial_port A pointer to the serial port where debugging info is written. 
 */

adc::adc (emstream* p_serial_port) {  
     92a:	cf 93       	push	r28
     92c:	df 93       	push	r29
     92e:	fc 01       	movw	r30, r24
	ptr_to_serial = p_serial_port;
     930:	71 83       	std	Z+1, r23	; 0x01
     932:	60 83       	st	Z, r22
   
   // Set AVCC with external capacitor at AREF pin.
	ADMUX = (1 << REFS0);
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	80 93 7c 00 	sts	0x007C, r24
	ADMUX_init = ADMUX;
     93a:	80 91 7c 00 	lds	r24, 0x007C
     93e:	82 83       	std	Z+2, r24	; 0x02
	
	// Enable ADC and set prescaler to 32.
	ADCSRA = (1 << ADEN) | (1 << ADPS2) | (1 << ADPS0);
     940:	85 e8       	ldi	r24, 0x85	; 133
     942:	80 93 7a 00 	sts	0x007A, r24

	// Print a handy debugging message
  	DBG (ptr_to_serial, "A/D constructor OK" << endl);
     946:	c0 81       	ld	r28, Z
     948:	d1 81       	ldd	r29, Z+1	; 0x01
     94a:	20 97       	sbiw	r28, 0x00	; 0
     94c:	49 f0       	breq	.+18     	; 0x960 <_ZN3adcC1EP8emstream+0x36>
     94e:	ce 01       	movw	r24, r28
     950:	67 e1       	ldi	r22, 0x17	; 23
     952:	72 e0       	ldi	r23, 0x02	; 2
     954:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     958:	ce 01       	movw	r24, r28
     95a:	66 e0       	ldi	r22, 0x06	; 6
     95c:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
}
     960:	df 91       	pop	r29
     962:	cf 91       	pop	r28
     964:	08 95       	ret

00000966 <_ZN3adc9read_onceEh>:

uint16_t adc::read_once (uint8_t ch) {
   uint8_t i = 0;
   uint16_t result;

   ADMUX = ADMUX_init;
     966:	fc 01       	movw	r30, r24
     968:	82 81       	ldd	r24, Z+2	; 0x02
     96a:	80 93 7c 00 	sts	0x007C, r24
   ADMUX |= ch;
     96e:	80 91 7c 00 	lds	r24, 0x007C
     972:	68 2b       	or	r22, r24
     974:	60 93 7c 00 	sts	0x007C, r22

   // start conversion with ADSC
   ADCSRA |= (1 << ADSC);
     978:	80 91 7a 00 	lds	r24, 0x007A
     97c:	80 64       	ori	r24, 0x40	; 64
     97e:	80 93 7a 00 	sts	0x007A, r24
   while (ADCSRA & (1 << ADSC) && i < 65) {
     982:	80 91 7a 00 	lds	r24, 0x007A
     986:	86 ff       	sbrs	r24, 6
     988:	1b c0       	rjmp	.+54     	; 0x9c0 <_ZN3adc9read_onceEh+0x5a>
     98a:	90 e0       	ldi	r25, 0x00	; 0
      i++;
     98c:	9f 5f       	subi	r25, 0xFF	; 255
   ADMUX = ADMUX_init;
   ADMUX |= ch;

   // start conversion with ADSC
   ADCSRA |= (1 << ADSC);
   while (ADCSRA & (1 << ADSC) && i < 65) {
     98e:	80 91 7a 00 	lds	r24, 0x007A
     992:	86 fd       	sbrc	r24, 6
     994:	0c c0       	rjmp	.+24     	; 0x9ae <_ZN3adc9read_onceEh+0x48>
      i++;
   }
   
   result = ADCL | (ADCH << 8);
     996:	80 91 78 00 	lds	r24, 0x0078
     99a:	40 91 79 00 	lds	r20, 0x0079
   //DBG (ptr_to_serial, "result: " << result << endl);
   return i == 65 ? -1 : result;
     99e:	91 34       	cpi	r25, 0x41	; 65
     9a0:	c9 f0       	breq	.+50     	; 0x9d4 <_ZN3adc9read_onceEh+0x6e>
   ADCSRA |= (1 << ADSC);
   while (ADCSRA & (1 << ADSC) && i < 65) {
      i++;
   }
   
   result = ADCL | (ADCH << 8);
     9a2:	34 2f       	mov	r19, r20
     9a4:	20 e0       	ldi	r18, 0x00	; 0
     9a6:	90 e0       	ldi	r25, 0x00	; 0
     9a8:	82 2b       	or	r24, r18
     9aa:	93 2b       	or	r25, r19
     9ac:	08 95       	ret
   ADMUX = ADMUX_init;
   ADMUX |= ch;

   // start conversion with ADSC
   ADCSRA |= (1 << ADSC);
   while (ADCSRA & (1 << ADSC) && i < 65) {
     9ae:	91 34       	cpi	r25, 0x41	; 65
     9b0:	69 f7       	brne	.-38     	; 0x98c <_ZN3adc9read_onceEh+0x26>
      i++;
   }
   
   result = ADCL | (ADCH << 8);
     9b2:	80 91 78 00 	lds	r24, 0x0078
     9b6:	80 91 79 00 	lds	r24, 0x0079
   //DBG (ptr_to_serial, "result: " << result << endl);
   return i == 65 ? -1 : result;
     9ba:	8f ef       	ldi	r24, 0xFF	; 255
     9bc:	9f ef       	ldi	r25, 0xFF	; 255
     9be:	08 95       	ret
   ADCSRA |= (1 << ADSC);
   while (ADCSRA & (1 << ADSC) && i < 65) {
      i++;
   }
   
   result = ADCL | (ADCH << 8);
     9c0:	80 91 78 00 	lds	r24, 0x0078
     9c4:	90 91 79 00 	lds	r25, 0x0079
     9c8:	39 2f       	mov	r19, r25
     9ca:	20 e0       	ldi	r18, 0x00	; 0
     9cc:	90 e0       	ldi	r25, 0x00	; 0
     9ce:	82 2b       	or	r24, r18
     9d0:	93 2b       	or	r25, r19
     9d2:	08 95       	ret
   //DBG (ptr_to_serial, "result: " << result << endl);
   return i == 65 ? -1 : result;
     9d4:	8f ef       	ldi	r24, 0xFF	; 255
     9d6:	9f ef       	ldi	r25, 0xFF	; 255
}
     9d8:	08 95       	ret

000009da <_ZN3adc16read_oversampledEhh>:
 *  @param channel A selected channel to read from.
 *  @param samples The chosen number of samples.
 *  @return The average readings from a chosen number of samples.
 */

uint16_t adc::read_oversampled (uint8_t channel, uint8_t samples) {
     9da:	df 92       	push	r13
     9dc:	ef 92       	push	r14
     9de:	ff 92       	push	r15
     9e0:	0f 93       	push	r16
     9e2:	1f 93       	push	r17
     9e4:	cf 93       	push	r28
     9e6:	df 93       	push	r29
     9e8:	8c 01       	movw	r16, r24
     9ea:	f6 2e       	mov	r15, r22
     9ec:	d4 2e       	mov	r13, r20
	uint16_t sum = 0;
     9ee:	80 e2       	ldi	r24, 0x20	; 32
     9f0:	84 17       	cp	r24, r20
     9f2:	e0 f4       	brcc	.+56     	; 0xa2c <_ZN3adc16read_oversampledEhh+0x52>
     9f4:	80 e2       	ldi	r24, 0x20	; 32
     9f6:	d8 2e       	mov	r13, r24

   if (samples > 32) {
      samples = 32;
   }
   
   for (i = 0; i < samples; i++) {
     9f8:	ee 24       	eor	r14, r14
     9fa:	c0 e0       	ldi	r28, 0x00	; 0
     9fc:	d0 e0       	ldi	r29, 0x00	; 0
      sum += read_once(channel);
     9fe:	c8 01       	movw	r24, r16
     a00:	6f 2d       	mov	r22, r15
     a02:	0e 94 b3 04 	call	0x966	; 0x966 <_ZN3adc9read_onceEh>
     a06:	c8 0f       	add	r28, r24
     a08:	d9 1f       	adc	r29, r25

   if (samples > 32) {
      samples = 32;
   }
   
   for (i = 0; i < samples; i++) {
     a0a:	e3 94       	inc	r14
     a0c:	ed 14       	cp	r14, r13
     a0e:	b9 f7       	brne	.-18     	; 0x9fe <_ZN3adc16read_oversampledEhh+0x24>
      sum += read_once(channel);
   }

   //DBG (ptr_to_serial, "average: " << sum / samples << endl);
   return sum / samples;
     a10:	6d 2d       	mov	r22, r13
     a12:	ce 01       	movw	r24, r28
     a14:	70 e0       	ldi	r23, 0x00	; 0
     a16:	0e 94 49 1b 	call	0x3692	; 0x3692 <__udivmodhi4>
     a1a:	cb 01       	movw	r24, r22
}
     a1c:	df 91       	pop	r29
     a1e:	cf 91       	pop	r28
     a20:	1f 91       	pop	r17
     a22:	0f 91       	pop	r16
     a24:	ff 90       	pop	r15
     a26:	ef 90       	pop	r14
     a28:	df 90       	pop	r13
     a2a:	08 95       	ret

   if (samples > 32) {
      samples = 32;
   }
   
   for (i = 0; i < samples; i++) {
     a2c:	44 23       	and	r20, r20
     a2e:	21 f7       	brne	.-56     	; 0x9f8 <_ZN3adc16read_oversampledEhh+0x1e>
 *  @param samples The chosen number of samples.
 *  @return The average readings from a chosen number of samples.
 */

uint16_t adc::read_oversampled (uint8_t channel, uint8_t samples) {
	uint16_t sum = 0;
     a30:	c0 e0       	ldi	r28, 0x00	; 0
     a32:	d0 e0       	ldi	r29, 0x00	; 0
     a34:	ed cf       	rjmp	.-38     	; 0xa10 <_ZN3adc16read_oversampledEhh+0x36>

00000a36 <_ZlsR8emstreamR3adc>:
 *  @param a2d The A/D driver which is being printed.
 *  @return A reference to the same serial device that the information is written to.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& serpt, adc& a2d) {
     a36:	cf 93       	push	r28
     a38:	df 93       	push	r29
     a3a:	d8 2f       	mov	r29, r24
     a3c:	c9 2f       	mov	r28, r25
     a3e:	6a e2       	ldi	r22, 0x2A	; 42
     a40:	72 e0       	ldi	r23, 0x02	; 2
     a42:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>

	serpt << "ADMUX: " << bin << ADMUX << endl;
     a46:	8d 2f       	mov	r24, r29
     a48:	9c 2f       	mov	r25, r28
     a4a:	60 e0       	ldi	r22, 0x00	; 0
     a4c:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     a50:	60 91 7c 00 	lds	r22, 0x007C
     a54:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <_ZN8emstreamlsEh>
     a58:	66 e0       	ldi	r22, 0x06	; 6
     a5a:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     a5e:	8d 2f       	mov	r24, r29
     a60:	9c 2f       	mov	r25, r28
     a62:	62 e3       	ldi	r22, 0x32	; 50
     a64:	72 e0       	ldi	r23, 0x02	; 2
     a66:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
   serpt << "ADCSRA: " << bin << ADCSRA << endl;
     a6a:	8d 2f       	mov	r24, r29
     a6c:	9c 2f       	mov	r25, r28
     a6e:	60 e0       	ldi	r22, 0x00	; 0
     a70:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     a74:	60 91 7a 00 	lds	r22, 0x007A
     a78:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <_ZN8emstreamlsEh>
     a7c:	66 e0       	ldi	r22, 0x06	; 6
     a7e:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>

	return (serpt);
}
     a82:	8d 2f       	mov	r24, r29
     a84:	9c 2f       	mov	r25, r28
     a86:	df 91       	pop	r29
     a88:	cf 91       	pop	r28
     a8a:	08 95       	ret

00000a8c <_ZN12motor_driverC1EP8emstream>:
/** \brief This constructor sets up an A/D converter. 
 *  \details \b Details: The A/D converter is enabled and the division factor is set to 32.
 *  @param p_serial_port A pointer to the serial port where debugging info is written. 
 */

motor_driver::motor_driver (emstream* p_serial_port) {  
     a8c:	cf 93       	push	r28
     a8e:	df 93       	push	r29
     a90:	fc 01       	movw	r30, r24

   ptr_to_serial = p_serial_port;
     a92:	71 83       	std	Z+1, r23	; 0x01
     a94:	60 83       	st	Z, r22

   DDRC = 0xFF;
     a96:	8f ef       	ldi	r24, 0xFF	; 255
     a98:	87 b9       	out	0x07, r24	; 7
   DDRB = 0xFF;
     a9a:	84 b9       	out	0x04, r24	; 4
   PORTC = 0x05;
     a9c:	85 e0       	ldi	r24, 0x05	; 5
     a9e:	88 b9       	out	0x08, r24	; 8
   PORTD = (1 << 5) | (1 << 7);
     aa0:	80 ea       	ldi	r24, 0xA0	; 160
     aa2:	8b b9       	out	0x0b, r24	; 11
   TCCR1A = 0b10101001;   // Fast PWM 8-bit
     aa4:	89 ea       	ldi	r24, 0xA9	; 169
     aa6:	80 93 80 00 	sts	0x0080, r24
   TCCR1B = 0b00010011;   // clk/64 (prescaler)
     aaa:	83 e1       	ldi	r24, 0x13	; 19
     aac:	80 93 81 00 	sts	0x0081, r24
                          // outputs 16E6/64/255 = 980Hz PWM
   OCR1A = 50;            // compare value => 20% duty cycle
     ab0:	82 e3       	ldi	r24, 0x32	; 50
     ab2:	90 e0       	ldi	r25, 0x00	; 0
     ab4:	90 93 89 00 	sts	0x0089, r25
     ab8:	80 93 88 00 	sts	0x0088, r24
   OCR1B = 171;           // compare value => 75% duty cycle
     abc:	8b ea       	ldi	r24, 0xAB	; 171
     abe:	90 e0       	ldi	r25, 0x00	; 0
     ac0:	90 93 8b 00 	sts	0x008B, r25
     ac4:	80 93 8a 00 	sts	0x008A, r24

   DBG(ptr_to_serial, "Motor driver constructor OK" << endl);
     ac8:	c0 81       	ld	r28, Z
     aca:	d1 81       	ldd	r29, Z+1	; 0x01
     acc:	20 97       	sbiw	r28, 0x00	; 0
     ace:	49 f0       	breq	.+18     	; 0xae2 <_ZN12motor_driverC1EP8emstream+0x56>
     ad0:	ce 01       	movw	r24, r28
     ad2:	6b e3       	ldi	r22, 0x3B	; 59
     ad4:	72 e0       	ldi	r23, 0x02	; 2
     ad6:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     ada:	ce 01       	movw	r24, r28
     adc:	66 e0       	ldi	r22, 0x06	; 6
     ade:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     ae2:	df 91       	pop	r29
     ae4:	cf 91       	pop	r28
     ae6:	08 95       	ret

00000ae8 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
     ae8:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
     aea:	e8 81       	ld	r30, Y
     aec:	f9 81       	ldd	r31, Y+1	; 0x01
     aee:	01 90       	ld	r0, Z+
     af0:	f0 81       	ld	r31, Z
     af2:	e0 2d       	mov	r30, r0
     af4:	09 95       	icall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
     af6:	1b 82       	std	Y+3, r1	; 0x03
     af8:	1a 82       	std	Y+2, r1	; 0x02

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
     afa:	6f ef       	ldi	r22, 0xFF	; 255
     afc:	7f ef       	ldi	r23, 0xFF	; 255
     afe:	cb 01       	movw	r24, r22
     b00:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <vTaskDelay>
     b04:	fa cf       	rjmp	.-12     	; 0xafa <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00000b06 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     b06:	0e 94 74 05 	call	0xae8	; 0xae8 <_ZN8frt_task22_call_users_run_methodEPS_>

00000b0a <_ZN8frt_task13transition_toEh>:
 *  variable 'state', and if transition logging is enabled, it logs the transition to 
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
     b0a:	fc 01       	movw	r30, r24
	state = new_state;
     b0c:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
     b0e:	65 87       	std	Z+13, r22	; 0x0d
}
     b10:	08 95       	ret

00000b12 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
     b12:	2f 92       	push	r2
     b14:	3f 92       	push	r3
     b16:	4f 92       	push	r4
     b18:	5f 92       	push	r5
     b1a:	6f 92       	push	r6
     b1c:	7f 92       	push	r7
     b1e:	8f 92       	push	r8
     b20:	9f 92       	push	r9
     b22:	af 92       	push	r10
     b24:	bf 92       	push	r11
     b26:	cf 92       	push	r12
     b28:	df 92       	push	r13
     b2a:	ef 92       	push	r14
     b2c:	ff 92       	push	r15
     b2e:	0f 93       	push	r16
     b30:	1f 93       	push	r17
     b32:	cf 93       	push	r28
     b34:	df 93       	push	r29
     b36:	cd b7       	in	r28, 0x3d	; 61
     b38:	de b7       	in	r29, 0x3e	; 62
     b3a:	2a 97       	sbiw	r28, 0x0a	; 10
     b3c:	0f b6       	in	r0, 0x3f	; 63
     b3e:	f8 94       	cli
     b40:	de bf       	out	0x3e, r29	; 62
     b42:	0f be       	out	0x3f, r0	; 63
     b44:	cd bf       	out	0x3d, r28	; 61
     b46:	4c 01       	movw	r8, r24
     b48:	db 01       	movw	r26, r22
     b4a:	d4 2e       	mov	r13, r20
     b4c:	19 01       	movw	r2, r18
     b4e:	28 01       	movw	r4, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
     b50:	8b e5       	ldi	r24, 0x5B	; 91
     b52:	92 e0       	ldi	r25, 0x02	; 2
     b54:	f4 01       	movw	r30, r8
     b56:	91 83       	std	Z+1, r25	; 0x01
     b58:	80 83       	st	Z, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
     b5a:	2c 91       	ld	r18, X
     b5c:	22 23       	and	r18, r18
     b5e:	09 f4       	brne	.+2      	; 0xb62 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
     b60:	7b c0       	rjmp	.+246    	; 0xc58 <_ZN8frt_taskC1EPKchjP8emstream+0x146>
     b62:	3e 01       	movw	r6, r28
     b64:	08 94       	sec
     b66:	61 1c       	adc	r6, r1
     b68:	71 1c       	adc	r7, r1
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
     b6a:	11 96       	adiw	r26, 0x01	; 1
     b6c:	ce 01       	movw	r24, r28
     b6e:	0a 96       	adiw	r24, 0x0a	; 10
     b70:	f3 01       	movw	r30, r6
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
     b72:	21 93       	st	Z+, r18
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
     b74:	3e 2f       	mov	r19, r30
     b76:	36 19       	sub	r19, r6
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
     b78:	2d 91       	ld	r18, X+
     b7a:	22 23       	and	r18, r18
     b7c:	09 f0       	breq	.+2      	; 0xb80 <_ZN8frt_taskC1EPKchjP8emstream+0x6e>
     b7e:	67 c0       	rjmp	.+206    	; 0xc4e <_ZN8frt_taskC1EPKchjP8emstream+0x13c>
     b80:	83 2f       	mov	r24, r19
     b82:	90 e0       	ldi	r25, 0x00	; 0
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
     b84:	86 0d       	add	r24, r6
     b86:	97 1d       	adc	r25, r7
     b88:	fc 01       	movw	r30, r24
     b8a:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
     b8c:	22 e0       	ldi	r18, 0x02	; 2
     b8e:	e2 2e       	mov	r14, r18
     b90:	f1 2c       	mov	r15, r1
     b92:	e8 0c       	add	r14, r8
     b94:	f9 1c       	adc	r15, r9
     b96:	83 e8       	ldi	r24, 0x83	; 131
     b98:	95 e0       	ldi	r25, 0x05	; 5
     b9a:	b3 01       	movw	r22, r6
     b9c:	a1 01       	movw	r20, r2
     b9e:	94 01       	movw	r18, r8
     ba0:	0d 2d       	mov	r16, r13
     ba2:	cc 24       	eor	r12, r12
     ba4:	dd 24       	eor	r13, r13
     ba6:	aa 24       	eor	r10, r10
     ba8:	bb 24       	eor	r11, r11
     baa:	0e 94 ed 12 	call	0x25da	; 0x25da <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
     bae:	f4 01       	movw	r30, r8
     bb0:	57 82       	std	Z+7, r5	; 0x07
     bb2:	46 82       	std	Z+6, r4	; 0x06
	total_stack = a_stack_size;
     bb4:	31 86       	std	Z+9, r3	; 0x09
     bb6:	20 86       	std	Z+8, r2	; 0x08

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
     bb8:	20 91 aa 02 	lds	r18, 0x02AA
     bbc:	30 91 ab 02 	lds	r19, 0x02AB
     bc0:	35 83       	std	Z+5, r19	; 0x05
     bc2:	24 83       	std	Z+4, r18	; 0x04
	last_created_task_pointer = this;
     bc4:	90 92 ab 02 	sts	0x02AB, r9
     bc8:	80 92 aa 02 	sts	0x02AA, r8

	// Initialize the finite state machine and its transition logger
	state = 0;
     bcc:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
     bce:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
     bd0:	20 91 54 1a 	lds	r18, 0x1A54
     bd4:	30 91 55 1a 	lds	r19, 0x1A55
     bd8:	2f 5f       	subi	r18, 0xFF	; 255
     bda:	3f 4f       	sbci	r19, 0xFF	; 255
     bdc:	30 93 55 1a 	sts	0x1A55, r19
     be0:	20 93 54 1a 	sts	0x1A54, r18
     be4:	33 87       	std	Z+11, r19	; 0x0b
     be6:	22 87       	std	Z+10, r18	; 0x0a

	// Initialize the run counter
	runs = 0;
     be8:	16 86       	std	Z+14, r1	; 0x0e
     bea:	17 86       	std	Z+15, r1	; 0x0f
     bec:	10 8a       	std	Z+16, r1	; 0x10
     bee:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
     bf0:	41 14       	cp	r4, r1
     bf2:	51 04       	cpc	r5, r1
     bf4:	99 f0       	breq	.+38     	; 0xc1c <_ZN8frt_taskC1EPKchjP8emstream+0x10a>
	{
		if (task_status == pdPASS)
     bf6:	81 30       	cpi	r24, 0x01	; 1
     bf8:	b1 f1       	breq	.+108    	; 0xc66 <_ZN8frt_taskC1EPKchjP8emstream+0x154>
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
     bfa:	c2 01       	movw	r24, r4
     bfc:	6a e0       	ldi	r22, 0x0A	; 10
     bfe:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     c02:	7c 01       	movw	r14, r24
     c04:	62 eb       	ldi	r22, 0xB2	; 178
     c06:	72 e0       	ldi	r23, 0x02	; 2
     c08:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     c0c:	c7 01       	movw	r24, r14
     c0e:	b3 01       	movw	r22, r6
     c10:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     c14:	c7 01       	movw	r24, r14
     c16:	66 e0       	ldi	r22, 0x06	; 6
     c18:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
     c1c:	2a 96       	adiw	r28, 0x0a	; 10
     c1e:	0f b6       	in	r0, 0x3f	; 63
     c20:	f8 94       	cli
     c22:	de bf       	out	0x3e, r29	; 62
     c24:	0f be       	out	0x3f, r0	; 63
     c26:	cd bf       	out	0x3d, r28	; 61
     c28:	df 91       	pop	r29
     c2a:	cf 91       	pop	r28
     c2c:	1f 91       	pop	r17
     c2e:	0f 91       	pop	r16
     c30:	ff 90       	pop	r15
     c32:	ef 90       	pop	r14
     c34:	df 90       	pop	r13
     c36:	cf 90       	pop	r12
     c38:	bf 90       	pop	r11
     c3a:	af 90       	pop	r10
     c3c:	9f 90       	pop	r9
     c3e:	8f 90       	pop	r8
     c40:	7f 90       	pop	r7
     c42:	6f 90       	pop	r6
     c44:	5f 90       	pop	r5
     c46:	4f 90       	pop	r4
     c48:	3f 90       	pop	r3
     c4a:	2f 90       	pop	r2
     c4c:	08 95       	ret
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
     c4e:	e8 17       	cp	r30, r24
     c50:	f9 07       	cpc	r31, r25
     c52:	09 f0       	breq	.+2      	; 0xc56 <_ZN8frt_taskC1EPKchjP8emstream+0x144>
     c54:	8e cf       	rjmp	.-228    	; 0xb72 <_ZN8frt_taskC1EPKchjP8emstream+0x60>
     c56:	94 cf       	rjmp	.-216    	; 0xb80 <_ZN8frt_taskC1EPKchjP8emstream+0x6e>
     c58:	80 e0       	ldi	r24, 0x00	; 0
     c5a:	90 e0       	ldi	r25, 0x00	; 0
     c5c:	3e 01       	movw	r6, r28
     c5e:	08 94       	sec
     c60:	61 1c       	adc	r6, r1
     c62:	71 1c       	adc	r7, r1
     c64:	8f cf       	rjmp	.-226    	; 0xb84 <_ZN8frt_taskC1EPKchjP8emstream+0x72>
	// successfully
	if (p_serial != NULL)
	{
		if (task_status == pdPASS)
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
     c66:	c2 01       	movw	r24, r4
     c68:	6a e0       	ldi	r22, 0x0A	; 10
     c6a:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     c6e:	7c 01       	movw	r14, r24
     c70:	65 e9       	ldi	r22, 0x95	; 149
     c72:	72 e0       	ldi	r23, 0x02	; 2
     c74:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     c78:	c7 01       	movw	r24, r14
     c7a:	b3 01       	movw	r22, r6
     c7c:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     c80:	c7 01       	movw	r24, r14
     c82:	6a e0       	ldi	r22, 0x0A	; 10
     c84:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     c88:	7c 01       	movw	r14, r24
     c8a:	6b e9       	ldi	r22, 0x9B	; 155
     c8c:	72 e0       	ldi	r23, 0x02	; 2
     c8e:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
     c92:	c7 01       	movw	r24, r14
     c94:	6a e0       	ldi	r22, 0x0A	; 10
     c96:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     c9a:	7c 01       	movw	r14, r24
     c9c:	64 ea       	ldi	r22, 0xA4	; 164
     c9e:	72 e0       	ldi	r23, 0x02	; 2
     ca0:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     ca4:	c7 01       	movw	r24, r14
     ca6:	63 e0       	ldi	r22, 0x03	; 3
     ca8:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     cac:	f4 01       	movw	r30, r8
     cae:	62 85       	ldd	r22, Z+10	; 0x0a
     cb0:	73 85       	ldd	r23, Z+11	; 0x0b
     cb2:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <_ZN8emstreamlsEj>
     cb6:	62 e0       	ldi	r22, 0x02	; 2
     cb8:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     cbc:	66 e0       	ldi	r22, 0x06	; 6
     cbe:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     cc2:	ac cf       	rjmp	.-168    	; 0xc1c <_ZN8frt_taskC1EPKchjP8emstream+0x10a>

00000cc4 <_ZN8frt_task15emergency_resetEv>:
/** This method prints an error message and resets the processor. It should only be 
 *  used in cases of things going seriously to heck.
 */

void frt_task::emergency_reset (void)
{
     cc4:	ec 01       	movw	r28, r24
	*p_serial << PMS ("ERROR in task ") << get_name () << PMS ("Resetting") << endl;
     cc6:	8e 81       	ldd	r24, Y+6	; 0x06
     cc8:	9f 81       	ldd	r25, Y+7	; 0x07
     cca:	6a e0       	ldi	r22, 0x0A	; 10
     ccc:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     cd0:	8c 01       	movw	r16, r24
     cd2:	67 ec       	ldi	r22, 0xC7	; 199
     cd4:	72 e0       	ldi	r23, 0x02	; 2
     cd6:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
		*  terminated character array belonging to the task. 
		*  @return A pointer to the task's name
		*/
		const char* get_name (void)
		{
			return ((const char*)(pcTaskGetTaskName (handle)));
     cda:	8a 81       	ldd	r24, Y+2	; 0x02
     cdc:	9b 81       	ldd	r25, Y+3	; 0x03
     cde:	0e 94 18 15 	call	0x2a30	; 0x2a30 <pcTaskGetTaskName>
     ce2:	bc 01       	movw	r22, r24
     ce4:	c8 01       	movw	r24, r16
     ce6:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     cea:	c8 01       	movw	r24, r16
     cec:	6a e0       	ldi	r22, 0x0A	; 10
     cee:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     cf2:	ec 01       	movw	r28, r24
     cf4:	66 ed       	ldi	r22, 0xD6	; 214
     cf6:	72 e0       	ldi	r23, 0x02	; 2
     cf8:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     cfc:	ce 01       	movw	r24, r28
     cfe:	66 e0       	ldi	r22, 0x06	; 6
     d00:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
	wdt_enable (WDTO_120MS);
     d04:	2b e0       	ldi	r18, 0x0B	; 11
     d06:	88 e1       	ldi	r24, 0x18	; 24
     d08:	90 e0       	ldi	r25, 0x00	; 0
     d0a:	0f b6       	in	r0, 0x3f	; 63
     d0c:	f8 94       	cli
     d0e:	a8 95       	wdr
     d10:	80 93 60 00 	sts	0x0060, r24
     d14:	0f be       	out	0x3f, r0	; 63
     d16:	20 93 60 00 	sts	0x0060, r18
     d1a:	ff cf       	rjmp	.-2      	; 0xd1a <_ZN8frt_task15emergency_resetEv+0x56>

00000d1c <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
     d1c:	cf 92       	push	r12
     d1e:	df 92       	push	r13
     d20:	ef 92       	push	r14
     d22:	ff 92       	push	r15
     d24:	0f 93       	push	r16
     d26:	cf 93       	push	r28
     d28:	df 93       	push	r29
     d2a:	7c 01       	movw	r14, r24
     d2c:	6b 01       	movw	r12, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
     d2e:	c6 01       	movw	r24, r12
     d30:	6a e0       	ldi	r22, 0x0A	; 10
     d32:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     d36:	ec 01       	movw	r28, r24
     d38:	66 ef       	ldi	r22, 0xF6	; 246
     d3a:	72 e0       	ldi	r23, 0x02	; 2
     d3c:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     d40:	ce 01       	movw	r24, r28
     d42:	6a e0       	ldi	r22, 0x0A	; 10
     d44:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     d48:	ec 01       	movw	r28, r24
     d4a:	6b ef       	ldi	r22, 0xFB	; 251
     d4c:	72 e0       	ldi	r23, 0x02	; 2
     d4e:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
     d52:	f7 01       	movw	r30, r14
     d54:	82 81       	ldd	r24, Z+2	; 0x02
     d56:	93 81       	ldd	r25, Z+3	; 0x03
     d58:	0e 94 18 15 	call	0x2a30	; 0x2a30 <pcTaskGetTaskName>
     d5c:	bc 01       	movw	r22, r24
     d5e:	ce 01       	movw	r24, r28
     d60:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
				<< ATERM_NORM_INT << endl;
     d64:	ce 01       	movw	r24, r28
     d66:	6a e0       	ldi	r22, 0x0A	; 10
     d68:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     d6c:	ec 01       	movw	r28, r24
     d6e:	62 e0       	ldi	r22, 0x02	; 2
     d70:	73 e0       	ldi	r23, 0x03	; 3
     d72:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     d76:	ce 01       	movw	r24, r28
     d78:	66 e0       	ldi	r22, 0x06	; 6
     d7a:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
	{
		prev_task_pointer->print_stack_in_list (ser_device);
	}
}
     d7e:	f7 01       	movw	r30, r14
     d80:	62 85       	ldd	r22, Z+10	; 0x0a
     d82:	73 85       	ldd	r23, Z+11	; 0x0b
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
     d84:	80 85       	ldd	r24, Z+8	; 0x08
     d86:	91 85       	ldd	r25, Z+9	; 0x09
     d88:	9b 01       	movw	r18, r22
     d8a:	28 1b       	sub	r18, r24
     d8c:	39 0b       	sbc	r19, r25
     d8e:	c9 01       	movw	r24, r18
     d90:	a6 01       	movw	r20, r12
     d92:	21 e0       	ldi	r18, 0x01	; 1
     d94:	01 e1       	ldi	r16, 0x11	; 17
     d96:	0e 94 63 09 	call	0x12c6	; 0x12c6 <_Z15hex_dump_memoryPhS_P8emstreambh>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
     d9a:	f7 01       	movw	r30, r14
     d9c:	e4 80       	ldd	r14, Z+4	; 0x04
     d9e:	f5 80       	ldd	r15, Z+5	; 0x05
     da0:	e1 14       	cp	r14, r1
     da2:	f1 04       	cpc	r15, r1
     da4:	21 f6       	brne	.-120    	; 0xd2e <_ZN8frt_task19print_stack_in_listEP8emstream+0x12>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
	}
}
     da6:	df 91       	pop	r29
     da8:	cf 91       	pop	r28
     daa:	0f 91       	pop	r16
     dac:	ff 90       	pop	r15
     dae:	ef 90       	pop	r14
     db0:	df 90       	pop	r13
     db2:	cf 90       	pop	r12
     db4:	08 95       	ret

00000db6 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
     db6:	0f 93       	push	r16
     db8:	1f 93       	push	r17
     dba:	cf 93       	push	r28
     dbc:	df 93       	push	r29
     dbe:	8c 01       	movw	r16, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
     dc0:	80 91 aa 02 	lds	r24, 0x02AA
     dc4:	90 91 ab 02 	lds	r25, 0x02AB
     dc8:	00 97       	sbiw	r24, 0x00	; 0
     dca:	19 f0       	breq	.+6      	; 0xdd2 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
     dcc:	b8 01       	movw	r22, r16
     dce:	0e 94 8e 06 	call	0xd1c	; 0xd1c <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
     dd2:	c8 01       	movw	r24, r16
     dd4:	6a e0       	ldi	r22, 0x0A	; 10
     dd6:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     dda:	ec 01       	movw	r28, r24
     ddc:	60 ee       	ldi	r22, 0xE0	; 224
     dde:	72 e0       	ldi	r23, 0x02	; 2
     de0:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     de4:	ce 01       	movw	r24, r28
     de6:	6a e0       	ldi	r22, 0x0A	; 10
     de8:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     dec:	ec 01       	movw	r28, r24
     dee:	65 ee       	ldi	r22, 0xE5	; 229
     df0:	72 e0       	ldi	r23, 0x02	; 2
     df2:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     df6:	ce 01       	movw	r24, r28
     df8:	6a e0       	ldi	r22, 0x0A	; 10
     dfa:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     dfe:	ec 01       	movw	r28, r24
     e00:	60 ef       	ldi	r22, 0xF0	; 240
     e02:	72 e0       	ldi	r23, 0x02	; 2
     e04:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     e08:	ce 01       	movw	r24, r28
     e0a:	66 e0       	ldi	r22, 0x06	; 6
     e0c:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
     e10:	80 91 54 1a 	lds	r24, 0x1A54
     e14:	90 91 55 1a 	lds	r25, 0x1A55
     e18:	bc 01       	movw	r22, r24
     e1a:	6f 5f       	subi	r22, 0xFF	; 255
     e1c:	7f 4f       	sbci	r23, 0xFF	; 255
     e1e:	83 56       	subi	r24, 0x63	; 99
     e20:	90 40       	sbci	r25, 0x00	; 0
     e22:	a8 01       	movw	r20, r16
     e24:	21 e0       	ldi	r18, 0x01	; 1
     e26:	01 e1       	ldi	r16, 0x11	; 17
     e28:	0e 94 63 09 	call	0x12c6	; 0x12c6 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
     e2c:	df 91       	pop	r29
     e2e:	cf 91       	pop	r28
     e30:	1f 91       	pop	r17
     e32:	0f 91       	pop	r16
     e34:	08 95       	ret

00000e36 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
     e36:	0f 93       	push	r16
     e38:	1f 93       	push	r17
     e3a:	cf 93       	push	r28
     e3c:	df 93       	push	r29
     e3e:	8c 01       	movw	r16, r24
     e40:	eb 01       	movw	r28, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
     e42:	fc 01       	movw	r30, r24
     e44:	82 81       	ldd	r24, Z+2	; 0x02
     e46:	93 81       	ldd	r25, Z+3	; 0x03
     e48:	0e 94 18 15 	call	0x2a30	; 0x2a30 <pcTaskGetTaskName>
     e4c:	bc 01       	movw	r22, r24
     e4e:	ce 01       	movw	r24, r28
     e50:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
     e54:	e8 81       	ld	r30, Y
     e56:	f9 81       	ldd	r31, Y+1	; 0x01
     e58:	02 80       	ldd	r0, Z+2	; 0x02
     e5a:	f3 81       	ldd	r31, Z+3	; 0x03
     e5c:	e0 2d       	mov	r30, r0
     e5e:	ce 01       	movw	r24, r28
     e60:	69 e0       	ldi	r22, 0x09	; 9
     e62:	09 95       	icall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
     e64:	f8 01       	movw	r30, r16
     e66:	82 81       	ldd	r24, Z+2	; 0x02
     e68:	93 81       	ldd	r25, Z+3	; 0x03
     e6a:	0e 94 18 15 	call	0x2a30	; 0x2a30 <pcTaskGetTaskName>
     e6e:	dc 01       	movw	r26, r24
     e70:	0d 90       	ld	r0, X+
     e72:	00 20       	and	r0, r0
     e74:	e9 f7       	brne	.-6      	; 0xe70 <_ZN8frt_task12print_statusER8emstream+0x3a>
     e76:	11 97       	sbiw	r26, 0x01	; 1
     e78:	a8 1b       	sub	r26, r24
     e7a:	b9 0b       	sbc	r27, r25
     e7c:	a8 30       	cpi	r26, 0x08	; 8
     e7e:	b1 05       	cpc	r27, r1
     e80:	40 f4       	brcc	.+16     	; 0xe92 <_ZN8frt_task12print_statusER8emstream+0x5c>
	{
		ser_dev.putchar ('\t');
     e82:	e8 81       	ld	r30, Y
     e84:	f9 81       	ldd	r31, Y+1	; 0x01
     e86:	02 80       	ldd	r0, Z+2	; 0x02
     e88:	f3 81       	ldd	r31, Z+3	; 0x03
     e8a:	e0 2d       	mov	r30, r0
     e8c:	ce 01       	movw	r24, r28
     e8e:	69 e0       	ldi	r22, 0x09	; 9
     e90:	09 95       	icall
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
     e92:	f8 01       	movw	r30, r16
     e94:	82 81       	ldd	r24, Z+2	; 0x02
     e96:	93 81       	ldd	r25, Z+3	; 0x03
     e98:	0e 94 14 14 	call	0x2828	; 0x2828 <uxTaskPriorityGet>
     e9c:	68 2f       	mov	r22, r24
     e9e:	ce 01       	movw	r24, r28
     ea0:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <_ZN8emstreamlsEh>
     ea4:	6a e0       	ldi	r22, 0x0A	; 10
     ea6:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     eaa:	ec 01       	movw	r28, r24
     eac:	68 e0       	ldi	r22, 0x08	; 8
     eae:	73 e0       	ldi	r23, 0x03	; 3
     eb0:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
			<< get_state ()
     eb4:	ce 01       	movw	r24, r28
     eb6:	f8 01       	movw	r30, r16
     eb8:	64 85       	ldd	r22, Z+12	; 0x0c
     eba:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
     ebe:	6a e0       	ldi	r22, 0x0A	; 10
     ec0:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     ec4:	ec 01       	movw	r28, r24
     ec6:	6a e0       	ldi	r22, 0x0A	; 10
     ec8:	73 e0       	ldi	r23, 0x03	; 3
     eca:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     ece:	f8 01       	movw	r30, r16
     ed0:	82 81       	ldd	r24, Z+2	; 0x02
     ed2:	93 81       	ldd	r25, Z+3	; 0x03
     ed4:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <uxTaskGetStackHighWaterMark>
     ed8:	68 2f       	mov	r22, r24
     eda:	ce 01       	movw	r24, r28
     edc:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <_ZN8emstreamlsEh>
     ee0:	6a e0       	ldi	r22, 0x0A	; 10
     ee2:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     ee6:	ec 01       	movw	r28, r24
     ee8:	6c e0       	ldi	r22, 0x0C	; 12
     eea:	73 e0       	ldi	r23, 0x03	; 3
     eec:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
     ef0:	f8 01       	movw	r30, r16
     ef2:	60 85       	ldd	r22, Z+8	; 0x08
     ef4:	71 85       	ldd	r23, Z+9	; 0x09
     ef6:	ce 01       	movw	r24, r28
     ef8:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <_ZN8emstreamlsEj>
     efc:	6a e0       	ldi	r22, 0x0A	; 10
     efe:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     f02:	ec 01       	movw	r28, r24
     f04:	6e e0       	ldi	r22, 0x0E	; 14
     f06:	73 e0       	ldi	r23, 0x03	; 3
     f08:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
     f0c:	ce 01       	movw	r24, r28
     f0e:	6a e0       	ldi	r22, 0x0A	; 10
     f10:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     f14:	ec 01       	movw	r28, r24
     f16:	60 e1       	ldi	r22, 0x10	; 16
     f18:	73 e0       	ldi	r23, 0x03	; 3
     f1a:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
     f1e:	f8 01       	movw	r30, r16
     f20:	46 85       	ldd	r20, Z+14	; 0x0e
     f22:	57 85       	ldd	r21, Z+15	; 0x0f
     f24:	60 89       	ldd	r22, Z+16	; 0x10
     f26:	71 89       	ldd	r23, Z+17	; 0x11
     f28:	ce 01       	movw	r24, r28
     f2a:	0e 94 13 0b 	call	0x1626	; 0x1626 <_ZN8emstreamlsEm>
}
     f2e:	df 91       	pop	r29
     f30:	cf 91       	pop	r28
     f32:	1f 91       	pop	r17
     f34:	0f 91       	pop	r16
     f36:	08 95       	ret

00000f38 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
     f38:	0f 93       	push	r16
     f3a:	1f 93       	push	r17
     f3c:	cf 93       	push	r28
     f3e:	df 93       	push	r29
     f40:	ec 01       	movw	r28, r24
     f42:	8b 01       	movw	r16, r22
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
	a_task.print_status (ser_dev);
     f44:	e8 81       	ld	r30, Y
     f46:	f9 81       	ldd	r31, Y+1	; 0x01
     f48:	02 80       	ldd	r0, Z+2	; 0x02
     f4a:	f3 81       	ldd	r31, Z+3	; 0x03
     f4c:	e0 2d       	mov	r30, r0
     f4e:	ce 01       	movw	r24, r28
     f50:	b8 01       	movw	r22, r16
     f52:	09 95       	icall
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
	*ser_device << *this << endl;
     f54:	c8 01       	movw	r24, r16
     f56:	66 e0       	ldi	r22, 0x06	; 6
     f58:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
     f5c:	0c 80       	ldd	r0, Y+4	; 0x04
     f5e:	dd 81       	ldd	r29, Y+5	; 0x05
     f60:	c0 2d       	mov	r28, r0
     f62:	20 97       	sbiw	r28, 0x00	; 0
     f64:	79 f7       	brne	.-34     	; 0xf44 <_ZN8frt_task20print_status_in_listEP8emstream+0xc>
	{
		prev_task_pointer->print_status_in_list (ser_device);
	}
}
     f66:	df 91       	pop	r29
     f68:	cf 91       	pop	r28
     f6a:	1f 91       	pop	r17
     f6c:	0f 91       	pop	r16
     f6e:	08 95       	ret

00000f70 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
     f70:	cf 93       	push	r28
     f72:	df 93       	push	r29
     f74:	d8 2f       	mov	r29, r24
     f76:	c9 2f       	mov	r28, r25
     f78:	db 01       	movw	r26, r22
	a_task.print_status (ser_dev);
     f7a:	ed 91       	ld	r30, X+
     f7c:	fc 91       	ld	r31, X
     f7e:	02 80       	ldd	r0, Z+2	; 0x02
     f80:	f3 81       	ldd	r31, Z+3	; 0x03
     f82:	e0 2d       	mov	r30, r0
     f84:	cb 01       	movw	r24, r22
     f86:	6d 2f       	mov	r22, r29
     f88:	7c 2f       	mov	r23, r28
     f8a:	09 95       	icall
	return (ser_dev);
}
     f8c:	8d 2f       	mov	r24, r29
     f8e:	9c 2f       	mov	r25, r28
     f90:	df 91       	pop	r29
     f92:	cf 91       	pop	r28
     f94:	08 95       	ret

00000f96 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
     f96:	0f 93       	push	r16
     f98:	1f 93       	push	r17
     f9a:	cf 93       	push	r28
     f9c:	df 93       	push	r29
     f9e:	8c 01       	movw	r16, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
     fa0:	6a e0       	ldi	r22, 0x0A	; 10
     fa2:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     fa6:	ec 01       	movw	r28, r24
     fa8:	62 e1       	ldi	r22, 0x12	; 18
     faa:	73 e0       	ldi	r23, 0x03	; 3
     fac:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
     fb0:	ce 01       	movw	r24, r28
     fb2:	6a e0       	ldi	r22, 0x0A	; 10
     fb4:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     fb8:	ec 01       	movw	r28, r24
     fba:	6d e1       	ldi	r22, 0x1D	; 29
     fbc:	73 e0       	ldi	r23, 0x03	; 3
     fbe:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
     fc2:	ce 01       	movw	r24, r28
     fc4:	66 e0       	ldi	r22, 0x06	; 6
     fc6:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
     fca:	c8 01       	movw	r24, r16
     fcc:	6a e0       	ldi	r22, 0x0A	; 10
     fce:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     fd2:	ec 01       	movw	r28, r24
     fd4:	64 e2       	ldi	r22, 0x24	; 36
     fd6:	73 e0       	ldi	r23, 0x03	; 3
     fd8:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
     fdc:	ce 01       	movw	r24, r28
     fde:	6a e0       	ldi	r22, 0x0A	; 10
     fe0:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     fe4:	ec 01       	movw	r28, r24
     fe6:	65 e3       	ldi	r22, 0x35	; 53
     fe8:	73 e0       	ldi	r23, 0x03	; 3
     fea:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
     fee:	ce 01       	movw	r24, r28
     ff0:	6a e0       	ldi	r22, 0x0A	; 10
     ff2:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
     ff6:	ec 01       	movw	r28, r24
     ff8:	61 e4       	ldi	r22, 0x41	; 65
     ffa:	73 e0       	ldi	r23, 0x03	; 3
     ffc:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
    1000:	ce 01       	movw	r24, r28
    1002:	66 e0       	ldi	r22, 0x06	; 6
    1004:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    1008:	c8 01       	movw	r24, r16
    100a:	6a e0       	ldi	r22, 0x0A	; 10
    100c:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
    1010:	ec 01       	movw	r28, r24
    1012:	67 e4       	ldi	r22, 0x47	; 71
    1014:	73 e0       	ldi	r23, 0x03	; 3
    1016:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    101a:	ce 01       	movw	r24, r28
    101c:	6a e0       	ldi	r22, 0x0A	; 10
    101e:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
    1022:	ec 01       	movw	r28, r24
    1024:	68 e5       	ldi	r22, 0x58	; 88
    1026:	73 e0       	ldi	r23, 0x03	; 3
    1028:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    102c:	ce 01       	movw	r24, r28
    102e:	6a e0       	ldi	r22, 0x0A	; 10
    1030:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
    1034:	ec 01       	movw	r28, r24
    1036:	64 e6       	ldi	r22, 0x64	; 100
    1038:	73 e0       	ldi	r23, 0x03	; 3
    103a:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
    103e:	ce 01       	movw	r24, r28
    1040:	66 e0       	ldi	r22, 0x06	; 6
    1042:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    1046:	80 91 aa 02 	lds	r24, 0x02AA
    104a:	90 91 ab 02 	lds	r25, 0x02AB
    104e:	00 97       	sbiw	r24, 0x00	; 0
    1050:	19 f0       	breq	.+6      	; 0x1058 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    1052:	b8 01       	movw	r22, r16
    1054:	0e 94 9c 07 	call	0xf38	; 0xf38 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    1058:	c8 01       	movw	r24, r16
    105a:	6a e0       	ldi	r22, 0x0A	; 10
    105c:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
    1060:	ec 01       	movw	r28, r24
    1062:	6a e6       	ldi	r22, 0x6A	; 106
    1064:	73 e0       	ldi	r23, 0x03	; 3
    1066:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    106a:	0e 94 22 15 	call	0x2a44	; 0x2a44 <xTaskGetIdleTaskHandle>
    106e:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <uxTaskGetStackHighWaterMark>
    1072:	68 2f       	mov	r22, r24
    1074:	ce 01       	movw	r24, r28
    1076:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    107a:	6a e0       	ldi	r22, 0x0A	; 10
    107c:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
    1080:	ec 01       	movw	r28, r24
    1082:	65 e7       	ldi	r22, 0x75	; 117
    1084:	73 e0       	ldi	r23, 0x03	; 3
    1086:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
    108a:	ce 01       	movw	r24, r28
    108c:	64 e6       	ldi	r22, 0x64	; 100
    108e:	70 e0       	ldi	r23, 0x00	; 0
    1090:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <_ZN8emstreamlsEj>
    1094:	6a e0       	ldi	r22, 0x0A	; 10
    1096:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
    109a:	ec 01       	movw	r28, r24
    109c:	67 e7       	ldi	r22, 0x77	; 119
    109e:	73 e0       	ldi	r23, 0x03	; 3
    10a0:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    10a4:	ce 01       	movw	r24, r28
    10a6:	66 e0       	ldi	r22, 0x06	; 6
    10a8:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
}
    10ac:	df 91       	pop	r29
    10ae:	cf 91       	pop	r28
    10b0:	1f 91       	pop	r17
    10b2:	0f 91       	pop	r16
    10b4:	08 95       	ret

000010b6 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    10b6:	0f 93       	push	r16
    10b8:	cf 93       	push	r28
    10ba:	df 93       	push	r29
    10bc:	0f 92       	push	r0
    10be:	cd b7       	in	r28, 0x3d	; 61
    10c0:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    10c2:	fc 01       	movw	r30, r24
    10c4:	80 85       	ldd	r24, Z+8	; 0x08
    10c6:	91 85       	ldd	r25, Z+9	; 0x09
    10c8:	be 01       	movw	r22, r28
    10ca:	6f 5f       	subi	r22, 0xFF	; 255
    10cc:	7f 4f       	sbci	r23, 0xFF	; 255
    10ce:	2f ef       	ldi	r18, 0xFF	; 255
    10d0:	3f ef       	ldi	r19, 0xFF	; 255
    10d2:	a9 01       	movw	r20, r18
    10d4:	00 e0       	ldi	r16, 0x00	; 0
    10d6:	0e 94 65 11 	call	0x22ca	; 0x22ca <xQueueGenericReceive>
    10da:	81 30       	cpi	r24, 0x01	; 1
    10dc:	49 f4       	brne	.+18     	; 0x10f0 <_ZN14frt_text_queue7getcharEv+0x3a>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    10de:	89 81       	ldd	r24, Y+1	; 0x01
    10e0:	99 27       	eor	r25, r25
    10e2:	87 fd       	sbrc	r24, 7
    10e4:	90 95       	com	r25
}
    10e6:	0f 90       	pop	r0
    10e8:	df 91       	pop	r29
    10ea:	cf 91       	pop	r28
    10ec:	0f 91       	pop	r16
    10ee:	08 95       	ret
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    10f0:	8f ef       	ldi	r24, 0xFF	; 255
    10f2:	9f ef       	ldi	r25, 0xFF	; 255
    10f4:	f8 cf       	rjmp	.-16     	; 0x10e6 <_ZN14frt_text_queue7getcharEv+0x30>

000010f6 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    10f6:	fc 01       	movw	r30, r24
    10f8:	80 85       	ldd	r24, Z+8	; 0x08
    10fa:	91 85       	ldd	r25, Z+9	; 0x09
    10fc:	0e 94 6f 12 	call	0x24de	; 0x24de <uxQueueMessagesWaiting>
 *  function uxQueueMessagesWaiting(); if there's anything in the queue, the return 
 *  value from that function will be greater than zero. 
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
    1100:	91 e0       	ldi	r25, 0x01	; 1
    1102:	88 23       	and	r24, r24
    1104:	09 f4       	brne	.+2      	; 0x1108 <_ZN14frt_text_queue14check_for_charEv+0x12>
    1106:	90 e0       	ldi	r25, 0x00	; 0
	if (uxQueueMessagesWaiting (the_queue) == 0)
	{
		return (false);
	}
	return (true);
}
    1108:	89 2f       	mov	r24, r25
    110a:	08 95       	ret

0000110c <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    110c:	0f 93       	push	r16
    110e:	cf 93       	push	r28
    1110:	df 93       	push	r29
    1112:	0f 92       	push	r0
    1114:	cd b7       	in	r28, 0x3d	; 61
    1116:	de b7       	in	r29, 0x3e	; 62
    1118:	fc 01       	movw	r30, r24
    111a:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    111c:	22 85       	ldd	r18, Z+10	; 0x0a
    111e:	33 85       	ldd	r19, Z+11	; 0x0b
    1120:	44 85       	ldd	r20, Z+12	; 0x0c
    1122:	55 85       	ldd	r21, Z+13	; 0x0d
    1124:	80 85       	ldd	r24, Z+8	; 0x08
    1126:	91 85       	ldd	r25, Z+9	; 0x09
    1128:	be 01       	movw	r22, r28
    112a:	6f 5f       	subi	r22, 0xFF	; 255
    112c:	7f 4f       	sbci	r23, 0xFF	; 255
    112e:	00 e0       	ldi	r16, 0x00	; 0
    1130:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <xQueueGenericSend>
 *  become empty, give up in frustration and return false. 
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
    1134:	91 e0       	ldi	r25, 0x01	; 1
    1136:	88 23       	and	r24, r24
    1138:	09 f4       	brne	.+2      	; 0x113c <_ZN14frt_text_queue7putcharEc+0x30>
    113a:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    113c:	89 2f       	mov	r24, r25
    113e:	0f 90       	pop	r0
    1140:	df 91       	pop	r29
    1142:	cf 91       	pop	r28
    1144:	0f 91       	pop	r16
    1146:	08 95       	ret

00001148 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    1148:	8f 92       	push	r8
    114a:	9f 92       	push	r9
    114c:	af 92       	push	r10
    114e:	bf 92       	push	r11
    1150:	cf 92       	push	r12
    1152:	df 92       	push	r13
    1154:	ef 92       	push	r14
    1156:	ff 92       	push	r15
    1158:	0f 93       	push	r16
    115a:	1f 93       	push	r17
    115c:	cf 93       	push	r28
    115e:	df 93       	push	r29
    1160:	0f 92       	push	r0
    1162:	cd b7       	in	r28, 0x3d	; 61
    1164:	de b7       	in	r29, 0x3e	; 62
    1166:	4c 01       	movw	r8, r24
    1168:	5a 01       	movw	r10, r20
    116a:	68 01       	movw	r12, r16
    116c:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    116e:	69 83       	std	Y+1, r22	; 0x01
    1170:	0e 94 39 0a 	call	0x1472	; 0x1472 <_ZN8emstreamC1Ev>
    1174:	83 e6       	ldi	r24, 0x63	; 99
    1176:	92 e0       	ldi	r25, 0x02	; 2
    1178:	f4 01       	movw	r30, r8
    117a:	91 83       	std	Z+1, r25	; 0x01
    117c:	80 83       	st	Z, r24
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    117e:	b7 86       	std	Z+15, r11	; 0x0f
    1180:	a6 86       	std	Z+14, r10	; 0x0e

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    1182:	69 81       	ldd	r22, Y+1	; 0x01
    1184:	86 2f       	mov	r24, r22
    1186:	61 e0       	ldi	r22, 0x01	; 1
    1188:	40 e0       	ldi	r20, 0x00	; 0
    118a:	0e 94 17 10 	call	0x202e	; 0x202e <xQueueGenericCreate>
    118e:	f4 01       	movw	r30, r8
    1190:	91 87       	std	Z+9, r25	; 0x09
    1192:	80 87       	std	Z+8, r24	; 0x08

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    1194:	c2 86       	std	Z+10, r12	; 0x0a
    1196:	d3 86       	std	Z+11, r13	; 0x0b
    1198:	e4 86       	std	Z+12, r14	; 0x0c
    119a:	f5 86       	std	Z+13, r15	; 0x0d
}
    119c:	0f 90       	pop	r0
    119e:	df 91       	pop	r29
    11a0:	cf 91       	pop	r28
    11a2:	1f 91       	pop	r17
    11a4:	0f 91       	pop	r16
    11a6:	ff 90       	pop	r15
    11a8:	ef 90       	pop	r14
    11aa:	df 90       	pop	r13
    11ac:	cf 90       	pop	r12
    11ae:	bf 90       	pop	r11
    11b0:	af 90       	pop	r10
    11b2:	9f 90       	pop	r9
    11b4:	8f 90       	pop	r8
    11b6:	08 95       	ret

000011b8 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    11b8:	cf 92       	push	r12
    11ba:	df 92       	push	r13
    11bc:	ef 92       	push	r14
    11be:	ff 92       	push	r15
    11c0:	0f 93       	push	r16
    11c2:	1f 93       	push	r17
    11c4:	cf 93       	push	r28
    11c6:	df 93       	push	r29
    11c8:	cd b7       	in	r28, 0x3d	; 61
    11ca:	de b7       	in	r29, 0x3e	; 62
    11cc:	67 97       	sbiw	r28, 0x17	; 23
    11ce:	0f b6       	in	r0, 0x3f	; 63
    11d0:	f8 94       	cli
    11d2:	de bf       	out	0x3e, r29	; 62
    11d4:	0f be       	out	0x3f, r0	; 63
    11d6:	cd bf       	out	0x3d, r28	; 61
    11d8:	7c 01       	movw	r14, r24
    11da:	8b 01       	movw	r16, r22
		 *  computing the number of seconds. 
		 *  @return The number of whole seconds in the time stamp
		 */
		uint32_t get_seconds (void)
		{
			return (tick_count / configTICK_RATE_HZ);
    11dc:	db 01       	movw	r26, r22
    11de:	6d 91       	ld	r22, X+
    11e0:	7d 91       	ld	r23, X+
    11e2:	8d 91       	ld	r24, X+
    11e4:	9c 91       	ld	r25, X
    11e6:	28 ee       	ldi	r18, 0xE8	; 232
    11e8:	33 e0       	ldi	r19, 0x03	; 3
    11ea:	40 e0       	ldi	r20, 0x00	; 0
    11ec:	50 e0       	ldi	r21, 0x00	; 0
    11ee:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__udivmodsi4>
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    11f2:	c7 01       	movw	r24, r14
    11f4:	ba 01       	movw	r22, r20
    11f6:	a9 01       	movw	r20, r18
    11f8:	0e 94 13 0b 	call	0x1626	; 0x1626 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    11fc:	d7 01       	movw	r26, r14
    11fe:	ed 91       	ld	r30, X+
    1200:	fc 91       	ld	r31, X
    1202:	02 80       	ldd	r0, Z+2	; 0x02
    1204:	f3 81       	ldd	r31, Z+3	; 0x03
    1206:	e0 2d       	mov	r30, r0
    1208:	c7 01       	movw	r24, r14
    120a:	6e e2       	ldi	r22, 0x2E	; 46
    120c:	09 95       	icall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    120e:	c8 01       	movw	r24, r16
    1210:	0e 94 3d 19 	call	0x327a	; 0x327a <_ZN10time_stamp12get_microsecEv>
    1214:	8e 01       	movw	r16, r28
    1216:	09 5f       	subi	r16, 0xF9	; 249
    1218:	1f 4f       	sbci	r17, 0xFF	; 255
 *  @param stamp A reference to the time stamp to be displayed
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
    121a:	6e 01       	movw	r12, r28
    121c:	08 94       	sec
    121e:	c1 1c       	adc	r12, r1
    1220:	d1 1c       	adc	r13, r1

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    1222:	2a e0       	ldi	r18, 0x0A	; 10
    1224:	30 e0       	ldi	r19, 0x00	; 0
    1226:	40 e0       	ldi	r20, 0x00	; 0
    1228:	50 e0       	ldi	r21, 0x00	; 0
    122a:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <__divmodsi4>
    122e:	28 8b       	std	Y+16, r18	; 0x10
    1230:	39 8b       	std	Y+17, r19	; 0x11
    1232:	4a 8b       	std	Y+18, r20	; 0x12
    1234:	5b 8b       	std	Y+19, r21	; 0x13
    1236:	6c 8b       	std	Y+20, r22	; 0x14
    1238:	7d 8b       	std	Y+21, r23	; 0x15
    123a:	8e 8b       	std	Y+22, r24	; 0x16
    123c:	9f 8b       	std	Y+23, r25	; 0x17
    123e:	fe 01       	movw	r30, r28
    1240:	38 96       	adiw	r30, 0x08	; 8
    1242:	de 01       	movw	r26, r28
    1244:	50 96       	adiw	r26, 0x10	; 16
    1246:	88 e0       	ldi	r24, 0x08	; 8
    1248:	0d 90       	ld	r0, X+
    124a:	01 92       	st	Z+, r0
    124c:	81 50       	subi	r24, 0x01	; 1
    124e:	e1 f7       	brne	.-8      	; 0x1248 <_ZlsR8emstreamR10time_stamp+0x90>
    1250:	68 85       	ldd	r22, Y+8	; 0x08
    1252:	79 85       	ldd	r23, Y+9	; 0x09
    1254:	8a 85       	ldd	r24, Y+10	; 0x0a
    1256:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    1258:	2c 85       	ldd	r18, Y+12	; 0x0c
    125a:	20 5d       	subi	r18, 0xD0	; 208
    125c:	f8 01       	movw	r30, r16
    125e:	22 93       	st	-Z, r18
    1260:	8f 01       	movw	r16, r30
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    1262:	ec 15       	cp	r30, r12
    1264:	fd 05       	cpc	r31, r13
    1266:	e9 f6       	brne	.-70     	; 0x1222 <_ZlsR8emstreamR10time_stamp+0x6a>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    1268:	1f 82       	std	Y+7, r1	; 0x07
    126a:	c7 01       	movw	r24, r14
    126c:	bf 01       	movw	r22, r30
    126e:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    1272:	c7 01       	movw	r24, r14
    1274:	67 96       	adiw	r28, 0x17	; 23
    1276:	0f b6       	in	r0, 0x3f	; 63
    1278:	f8 94       	cli
    127a:	de bf       	out	0x3e, r29	; 62
    127c:	0f be       	out	0x3f, r0	; 63
    127e:	cd bf       	out	0x3d, r28	; 61
    1280:	df 91       	pop	r29
    1282:	cf 91       	pop	r28
    1284:	1f 91       	pop	r17
    1286:	0f 91       	pop	r16
    1288:	ff 90       	pop	r15
    128a:	ef 90       	pop	r14
    128c:	df 90       	pop	r13
    128e:	cf 90       	pop	r12
    1290:	08 95       	ret

00001292 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    1292:	cf 93       	push	r28
    1294:	df 93       	push	r29
    1296:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    1298:	0f b6       	in	r0, 0x3f	; 63
    129a:	f8 94       	cli
    129c:	0f 92       	push	r0

	// Now grab the hardware timer count. The tick count can't be updated, even if the
	// hardware timer overflows, because interrupts are disabled
	#if (defined TIMER5_COMPA_vect)
		hardware_count = TCNT5;
    129e:	80 91 24 01 	lds	r24, 0x0124
    12a2:	90 91 25 01 	lds	r25, 0x0125
    12a6:	9d 83       	std	Y+5, r25	; 0x05
    12a8:	8c 83       	std	Y+4, r24	; 0x04
	#else
		hardware_count = TCNT1;
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    12aa:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <xTaskGetTickCount>
    12ae:	dc 01       	movw	r26, r24
    12b0:	cb 01       	movw	r24, r22
    12b2:	88 83       	st	Y, r24
    12b4:	99 83       	std	Y+1, r25	; 0x01
    12b6:	aa 83       	std	Y+2, r26	; 0x02
    12b8:	bb 83       	std	Y+3, r27	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    12ba:	0f 90       	pop	r0
    12bc:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    12be:	ce 01       	movw	r24, r28
    12c0:	df 91       	pop	r29
    12c2:	cf 91       	pop	r28
    12c4:	08 95       	ret

000012c6 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    12c6:	4f 92       	push	r4
    12c8:	5f 92       	push	r5
    12ca:	6f 92       	push	r6
    12cc:	7f 92       	push	r7
    12ce:	9f 92       	push	r9
    12d0:	af 92       	push	r10
    12d2:	bf 92       	push	r11
    12d4:	cf 92       	push	r12
    12d6:	df 92       	push	r13
    12d8:	ef 92       	push	r14
    12da:	ff 92       	push	r15
    12dc:	0f 93       	push	r16
    12de:	1f 93       	push	r17
    12e0:	cf 93       	push	r28
    12e2:	df 93       	push	r29
    12e4:	6c 01       	movw	r12, r24
    12e6:	2b 01       	movw	r4, r22
    12e8:	7a 01       	movw	r14, r20
    12ea:	b2 2e       	mov	r11, r18
    12ec:	90 2e       	mov	r9, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    12ee:	ca 01       	movw	r24, r20
    12f0:	63 e0       	ldi	r22, 0x03	; 3
    12f2:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    12f6:	c4 14       	cp	r12, r4
    12f8:	d5 04       	cpc	r13, r5
    12fa:	08 f0       	brcs	.+2      	; 0x12fe <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    12fc:	62 c0       	rjmp	.+196    	; 0x13c2 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfc>
 *      enabled, bytes equal to the given number are displayed less brightly until the 
 *      first byte which isn't the given value is found. This highlights the used part 
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
    12fe:	86 01       	movw	r16, r12
    1300:	0c 5e       	subi	r16, 0xEC	; 236
    1302:	1f 4f       	sbci	r17, 0xFF	; 255
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
	uint8_t byte_count;                     // Counts through the bytes in a line
	uint8_t temp_byte;                      // Holds a byte temporarily and obviously
	bool found_changes = false;             // Becomes true when changed memory found
    1304:	aa 24       	eor	r10, r10
	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    1306:	36 01       	movw	r6, r12
    1308:	c7 01       	movw	r24, r14
    130a:	b6 01       	movw	r22, r12
    130c:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <_ZN8emstreamlsEj>
    1310:	6a e0       	ldi	r22, 0x0A	; 10
    1312:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
    1316:	6a e7       	ldi	r22, 0x7A	; 122
    1318:	73 e0       	ldi	r23, 0x03	; 3
    131a:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    131e:	bb 20       	and	r11, r11
    1320:	19 f0       	breq	.+6      	; 0x1328 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    1322:	aa 20       	and	r10, r10
    1324:	09 f0       	breq	.+2      	; 0x1328 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    1326:	61 c0       	rjmp	.+194    	; 0x13ea <_Z15hex_dump_memoryPhS_P8emstreambh+0x124>
 *      enabled, bytes equal to the given number are displayed less brightly until the 
 *      first byte which isn't the given value is found. This highlights the used part 
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
    1328:	e6 01       	movw	r28, r12
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    132a:	68 81       	ld	r22, Y
    132c:	bb 20       	and	r11, r11
    132e:	79 f0       	breq	.+30     	; 0x134e <_Z15hex_dump_memoryPhS_P8emstreambh+0x88>
    1330:	aa 20       	and	r10, r10
    1332:	69 f4       	brne	.+26     	; 0x134e <_Z15hex_dump_memoryPhS_P8emstreambh+0x88>
    1334:	69 15       	cp	r22, r9
    1336:	59 f0       	breq	.+22     	; 0x134e <_Z15hex_dump_memoryPhS_P8emstreambh+0x88>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    1338:	c7 01       	movw	r24, r14
    133a:	6a e0       	ldi	r22, 0x0A	; 10
    133c:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
    1340:	62 e8       	ldi	r22, 0x82	; 130
    1342:	73 e0       	ldi	r23, 0x03	; 3
    1344:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
    1348:	68 81       	ld	r22, Y
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    134a:	aa 24       	eor	r10, r10
    134c:	a3 94       	inc	r10
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    134e:	21 96       	adiw	r28, 0x01	; 1
    1350:	c7 01       	movw	r24, r14
    1352:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    1356:	dc 01       	movw	r26, r24
    1358:	ed 91       	ld	r30, X+
    135a:	fc 91       	ld	r31, X
    135c:	02 80       	ldd	r0, Z+2	; 0x02
    135e:	f3 81       	ldd	r31, Z+3	; 0x03
    1360:	e0 2d       	mov	r30, r0
    1362:	60 e2       	ldi	r22, 0x20	; 32
    1364:	09 95       	icall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    1366:	c0 17       	cp	r28, r16
    1368:	d1 07       	cpc	r29, r17
    136a:	f9 f6       	brne	.-66     	; 0x132a <_Z15hex_dump_memoryPhS_P8emstreambh+0x64>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    136c:	bb 20       	and	r11, r11
    136e:	31 f0       	breq	.+12     	; 0x137c <_Z15hex_dump_memoryPhS_P8emstreambh+0xb6>
    1370:	45 c0       	rjmp	.+138    	; 0x13fc <_Z15hex_dump_memoryPhS_P8emstreambh+0x136>
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
			if (temp_byte >= ' ' && temp_byte <= '~')
				p_ser_dev->putchar (temp_byte);
    1372:	c7 01       	movw	r24, r14
    1374:	09 95       	icall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    1376:	c0 16       	cp	r12, r16
    1378:	d1 06       	cpc	r13, r17
    137a:	a1 f0       	breq	.+40     	; 0x13a4 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			temp_byte = *start_address++;
    137c:	f6 01       	movw	r30, r12
    137e:	61 91       	ld	r22, Z+
    1380:	6f 01       	movw	r12, r30
			if (temp_byte >= ' ' && temp_byte <= '~')
    1382:	86 2f       	mov	r24, r22
    1384:	80 52       	subi	r24, 0x20	; 32
				p_ser_dev->putchar (temp_byte);
    1386:	d7 01       	movw	r26, r14
    1388:	ed 91       	ld	r30, X+
    138a:	fc 91       	ld	r31, X
    138c:	11 97       	sbiw	r26, 0x01	; 1
    138e:	02 80       	ldd	r0, Z+2	; 0x02
    1390:	f3 81       	ldd	r31, Z+3	; 0x03
    1392:	e0 2d       	mov	r30, r0
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
			if (temp_byte >= ' ' && temp_byte <= '~')
    1394:	8f 35       	cpi	r24, 0x5F	; 95
    1396:	68 f3       	brcs	.-38     	; 0x1372 <_Z15hex_dump_memoryPhS_P8emstreambh+0xac>
				p_ser_dev->putchar (temp_byte);
			else
				p_ser_dev->putchar ('.');
    1398:	c7 01       	movw	r24, r14
    139a:	6e e2       	ldi	r22, 0x2E	; 46
    139c:	09 95       	icall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    139e:	c0 16       	cp	r12, r16
    13a0:	d1 06       	cpc	r13, r17
    13a2:	61 f7       	brne	.-40     	; 0x137c <_Z15hex_dump_memoryPhS_P8emstreambh+0xb6>
 *      enabled, bytes equal to the given number are displayed less brightly until the 
 *      first byte which isn't the given value is found. This highlights the used part 
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
    13a4:	84 e1       	ldi	r24, 0x14	; 20
    13a6:	c8 2e       	mov	r12, r24
    13a8:	d1 2c       	mov	r13, r1
    13aa:	c6 0c       	add	r12, r6
    13ac:	d7 1c       	adc	r13, r7
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    13ae:	c7 01       	movw	r24, r14
    13b0:	66 e0       	ldi	r22, 0x06	; 6
    13b2:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
    13b6:	0c 5e       	subi	r16, 0xEC	; 236
    13b8:	1f 4f       	sbci	r17, 0xFF	; 255
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    13ba:	c4 14       	cp	r12, r4
    13bc:	d5 04       	cpc	r13, r5
    13be:	08 f4       	brcc	.+2      	; 0x13c2 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfc>
    13c0:	a2 cf       	rjmp	.-188    	; 0x1306 <_Z15hex_dump_memoryPhS_P8emstreambh+0x40>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    13c2:	c7 01       	movw	r24, r14
    13c4:	62 e0       	ldi	r22, 0x02	; 2
    13c6:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
}
    13ca:	df 91       	pop	r29
    13cc:	cf 91       	pop	r28
    13ce:	1f 91       	pop	r17
    13d0:	0f 91       	pop	r16
    13d2:	ff 90       	pop	r15
    13d4:	ef 90       	pop	r14
    13d6:	df 90       	pop	r13
    13d8:	cf 90       	pop	r12
    13da:	bf 90       	pop	r11
    13dc:	af 90       	pop	r10
    13de:	9f 90       	pop	r9
    13e0:	7f 90       	pop	r7
    13e2:	6f 90       	pop	r6
    13e4:	5f 90       	pop	r5
    13e6:	4f 90       	pop	r4
    13e8:	08 95       	ret

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
    13ea:	c7 01       	movw	r24, r14
    13ec:	6a e0       	ldi	r22, 0x0A	; 10
    13ee:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    13f2:	6d e7       	ldi	r22, 0x7D	; 125
    13f4:	73 e0       	ldi	r23, 0x03	; 3
    13f6:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
    13fa:	96 cf       	rjmp	.-212    	; 0x1328 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
		}

		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    13fc:	c7 01       	movw	r24, r14
    13fe:	6a e0       	ldi	r22, 0x0A	; 10
    1400:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
    1404:	ec 01       	movw	r28, r24
    1406:	67 e8       	ldi	r22, 0x87	; 135
    1408:	73 e0       	ldi	r23, 0x03	; 3
    140a:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    140e:	e8 81       	ld	r30, Y
    1410:	f9 81       	ldd	r31, Y+1	; 0x01
    1412:	02 80       	ldd	r0, Z+2	; 0x02
    1414:	f3 81       	ldd	r31, Z+3	; 0x03
    1416:	e0 2d       	mov	r30, r0
    1418:	ce 01       	movw	r24, r28
    141a:	60 e2       	ldi	r22, 0x20	; 32
    141c:	09 95       	icall
    141e:	ae cf       	rjmp	.-164    	; 0x137c <_Z15hex_dump_memoryPhS_P8emstreambh+0xb6>

00001420 <_Znwj>:
	*  @return A pointer to the memory area which has just been allocated
	*/

	void* operator new (size_t size)
	{
		return pvPortMalloc (size);
    1420:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <pvPortMalloc>
	}
    1424:	08 95       	ret

00001426 <_ZdlPv>:
	 *  @param ptr A pointer to the memory area whose contents are to be deleted
	 */

	void operator delete (void *ptr)
	{
		if (ptr) vPortFree (ptr);
    1426:	00 97       	sbiw	r24, 0x00	; 0
    1428:	11 f0       	breq	.+4      	; 0x142e <_ZdlPv+0x8>
    142a:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <vPortFree>
    142e:	08 95       	ret

00001430 <_Znaj>:
	 *  @return A pointer to the memory area which has just been allocated
	 */

	void* operator new[] (size_t size)
	{
		return pvPortMalloc (size);
    1430:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <pvPortMalloc>
	}
    1434:	08 95       	ret

00001436 <_ZdaPv>:
	 *  @param ptr A pointer to the memory area whose contents are to be deleted
	 */

	void operator delete[] (void *ptr)
	{
		if (ptr) vPortFree (ptr);
    1436:	00 97       	sbiw	r24, 0x00	; 0
    1438:	11 f0       	breq	.+4      	; 0x143e <_ZdaPv+0x8>
    143a:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <vPortFree>
    143e:	08 95       	ret

00001440 <__cxa_guard_acquire>:
 */
extern "C"
{
int __cxa_guard_acquire (__guard *g)
    {
    return !*(char *)(g);
    1440:	21 e0       	ldi	r18, 0x01	; 1
    1442:	30 e0       	ldi	r19, 0x00	; 0
    1444:	fc 01       	movw	r30, r24
    1446:	80 81       	ld	r24, Z
    1448:	88 23       	and	r24, r24
    144a:	11 f0       	breq	.+4      	; 0x1450 <__cxa_guard_acquire+0x10>
    144c:	20 e0       	ldi	r18, 0x00	; 0
    144e:	30 e0       	ldi	r19, 0x00	; 0
    }
    1450:	c9 01       	movw	r24, r18
    1452:	08 95       	ret

00001454 <__cxa_guard_release>:
 */
extern "C"
{
void __cxa_guard_release (__guard *g)
    {
    *(char *)g = 1;
    1454:	21 e0       	ldi	r18, 0x01	; 1
    1456:	fc 01       	movw	r30, r24
    1458:	20 83       	st	Z, r18
    }
    145a:	08 95       	ret

0000145c <__cxa_guard_abort>:
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
		(void)g;							// Shuts up a dumb compiler warning
    }
    145c:	08 95       	ret

0000145e <__cxa_pure_virtual>:

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    }
    145e:	08 95       	ret

00001460 <_ZN8emstream13ready_to_sendEv>:
 */

bool emstream::ready_to_send (void)
{
	return (true);                          // By default the port's always ready
}
    1460:	81 e0       	ldi	r24, 0x01	; 1
    1462:	08 95       	ret

00001464 <_ZN8emstream7getcharEv>:
 */

int16_t emstream::getchar (void)
{
	return ('\0');                          // Nothing to return, really
}
    1464:	80 e0       	ldi	r24, 0x00	; 0
    1466:	90 e0       	ldi	r25, 0x00	; 0
    1468:	08 95       	ret

0000146a <_ZN8emstream14check_for_charEv>:
 */

bool emstream::check_for_char (void)
{
	return (false);
}
    146a:	80 e0       	ldi	r24, 0x00	; 0
    146c:	08 95       	ret

0000146e <_ZN8emstream12transmit_nowEv>:
 *  need to respond to calls for immediate transmission. 
 */

void emstream::transmit_now (void)
{
}
    146e:	08 95       	ret

00001470 <_ZN8emstream12clear_screenEv>:
 *  classes which send things to displays should respond by clearing themselves.
 */

void emstream::clear_screen (void)
{
}
    1470:	08 95       	ret

00001472 <_ZN8emstreamC1Ev>:
//-------------------------------------------------------------------------------------
/** This constructor sets up the base serial port object. It sets the default base for
 *  the conversion of numbers to text and the default format for converting chars. 
 */

emstream::emstream (void)
    1472:	fc 01       	movw	r30, r24
    1474:	83 e7       	ldi	r24, 0x73	; 115
    1476:	92 e0       	ldi	r25, 0x02	; 2
    1478:	91 83       	std	Z+1, r25	; 0x01
    147a:	80 83       	st	Z, r24
{
	base = 10;                              // Numbers are shown as decimal by default
    147c:	8a e0       	ldi	r24, 0x0A	; 10
    147e:	82 83       	std	Z+2, r24	; 0x02
	print_ascii = false;                    // Print 8-bit chars as numbers by default
    1480:	13 82       	std	Z+3, r1	; 0x03
	precision = 3;                          // Print 3 digits after a decimal point
    1482:	83 e0       	ldi	r24, 0x03	; 3
    1484:	85 83       	std	Z+5, r24	; 0x05
	pgm_string = false;                     // Print strings from SRAM by default
    1486:	14 82       	std	Z+4, r1	; 0x04
	p_hex_receiver = NULL;                  // No hex packet receiver has been set up
    1488:	17 82       	std	Z+7, r1	; 0x07
    148a:	16 82       	std	Z+6, r1	; 0x06
}
    148c:	08 95       	ret

0000148e <_ZN8emstream4putsEPKc>:
 *  reached.
 *  @param p_string A pointer to the string which is to be printed
 */

void emstream::puts (const char* p_string)
{
    148e:	0f 93       	push	r16
    1490:	1f 93       	push	r17
    1492:	cf 93       	push	r28
    1494:	df 93       	push	r29
    1496:	8c 01       	movw	r16, r24
    1498:	eb 01       	movw	r28, r22
	char ch;                                // Temporary storage for a character

	// If the program-string variable is set, this string is to be found in program
	// memory rather than data memory
	if (pgm_string)
    149a:	dc 01       	movw	r26, r24
    149c:	14 96       	adiw	r26, 0x04	; 4
    149e:	8c 91       	ld	r24, X
    14a0:	14 97       	sbiw	r26, 0x04	; 4
    14a2:	88 23       	and	r24, r24
    14a4:	a1 f4       	brne	.+40     	; 0x14ce <_ZN8emstream4putsEPKc+0x40>
	}
	// If the program-string variable is not set, the string is in RAM and printed
	// in the normal way
	else
	{
		while (*p_string)
    14a6:	68 81       	ld	r22, Y
    14a8:	66 23       	and	r22, r22
    14aa:	61 f0       	breq	.+24     	; 0x14c4 <_ZN8emstream4putsEPKc+0x36>
 *  character until and end of string character (the null character, \c '\0') is 
 *  reached.
 *  @param p_string A pointer to the string which is to be printed
 */

void emstream::puts (const char* p_string)
    14ac:	21 96       	adiw	r28, 0x01	; 1
	// in the normal way
	else
	{
		while (*p_string)
		{
			putchar (*p_string++);
    14ae:	d8 01       	movw	r26, r16
    14b0:	ed 91       	ld	r30, X+
    14b2:	fc 91       	ld	r31, X
    14b4:	02 80       	ldd	r0, Z+2	; 0x02
    14b6:	f3 81       	ldd	r31, Z+3	; 0x03
    14b8:	e0 2d       	mov	r30, r0
    14ba:	c8 01       	movw	r24, r16
    14bc:	09 95       	icall
	}
	// If the program-string variable is not set, the string is in RAM and printed
	// in the normal way
	else
	{
		while (*p_string)
    14be:	69 91       	ld	r22, Y+
    14c0:	66 23       	and	r22, r22
    14c2:	a9 f7       	brne	.-22     	; 0x14ae <_ZN8emstream4putsEPKc+0x20>
		{
			putchar (*p_string++);
		}
	}
}
    14c4:	df 91       	pop	r29
    14c6:	cf 91       	pop	r28
    14c8:	1f 91       	pop	r17
    14ca:	0f 91       	pop	r16
    14cc:	08 95       	ret

	// If the program-string variable is set, this string is to be found in program
	// memory rather than data memory
	if (pgm_string)
	{
		pgm_string = false;
    14ce:	f8 01       	movw	r30, r16
    14d0:	14 82       	std	Z+4, r1	; 0x04
		while ((ch = pgm_read_byte_near (p_string++)))
    14d2:	fb 01       	movw	r30, r22
    14d4:	64 91       	lpm	r22, Z
    14d6:	66 23       	and	r22, r22
    14d8:	a9 f3       	breq	.-22     	; 0x14c4 <_ZN8emstream4putsEPKc+0x36>
    14da:	21 96       	adiw	r28, 0x01	; 1
		{
			putchar (ch);
    14dc:	f8 01       	movw	r30, r16
    14de:	a0 81       	ld	r26, Z
    14e0:	b1 81       	ldd	r27, Z+1	; 0x01
    14e2:	12 96       	adiw	r26, 0x02	; 2
    14e4:	ed 91       	ld	r30, X+
    14e6:	fc 91       	ld	r31, X
    14e8:	13 97       	sbiw	r26, 0x03	; 3
    14ea:	c8 01       	movw	r24, r16
    14ec:	09 95       	icall
	// If the program-string variable is set, this string is to be found in program
	// memory rather than data memory
	if (pgm_string)
	{
		pgm_string = false;
		while ((ch = pgm_read_byte_near (p_string++)))
    14ee:	fe 01       	movw	r30, r28
    14f0:	21 96       	adiw	r28, 0x01	; 1
    14f2:	64 91       	lpm	r22, Z
    14f4:	66 23       	and	r22, r22
    14f6:	91 f7       	brne	.-28     	; 0x14dc <_ZN8emstream4putsEPKc+0x4e>
		while (*p_string)
		{
			putchar (*p_string++);
		}
	}
}
    14f8:	df 91       	pop	r29
    14fa:	cf 91       	pop	r28
    14fc:	1f 91       	pop	r17
    14fe:	0f 91       	pop	r16
    1500:	08 95       	ret

00001502 <_Z12setprecisionh>:
{
	if (digits > 7)
	{
		digits = 7;
	}
	bts_glob_prec = digits;
    1502:	88 30       	cpi	r24, 0x08	; 8
    1504:	08 f0       	brcs	.+2      	; 0x1508 <_Z12setprecisionh+0x6>
    1506:	87 e0       	ldi	r24, 0x07	; 7
    1508:	80 93 7f 02 	sts	0x027F, r24

	return (manip_set_precision);
}
    150c:	89 e0       	ldi	r24, 0x09	; 9
    150e:	08 95       	ret

00001510 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    1510:	cf 93       	push	r28
    1512:	df 93       	push	r29
    1514:	ec 01       	movw	r28, r24
	switch (new_manip)
    1516:	64 30       	cpi	r22, 0x04	; 4
    1518:	09 f4       	brne	.+2      	; 0x151c <_ZN8emstreamlsE15ser_manipulator+0xc>
    151a:	48 c0       	rjmp	.+144    	; 0x15ac <_ZN8emstreamlsE15ser_manipulator+0x9c>
    151c:	65 30       	cpi	r22, 0x05	; 5
    151e:	d8 f0       	brcs	.+54     	; 0x1556 <_ZN8emstreamlsE15ser_manipulator+0x46>
    1520:	67 30       	cpi	r22, 0x07	; 7
    1522:	81 f1       	breq	.+96     	; 0x1584 <_ZN8emstreamlsE15ser_manipulator+0x74>
    1524:	68 30       	cpi	r22, 0x08	; 8
    1526:	10 f5       	brcc	.+68     	; 0x156c <_ZN8emstreamlsE15ser_manipulator+0x5c>
    1528:	65 30       	cpi	r22, 0x05	; 5
    152a:	51 f1       	breq	.+84     	; 0x1580 <_ZN8emstreamlsE15ser_manipulator+0x70>
    152c:	66 30       	cpi	r22, 0x06	; 6
    152e:	79 f4       	brne	.+30     	; 0x154e <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
			break;
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    1530:	e8 81       	ld	r30, Y
    1532:	f9 81       	ldd	r31, Y+1	; 0x01
    1534:	02 80       	ldd	r0, Z+2	; 0x02
    1536:	f3 81       	ldd	r31, Z+3	; 0x03
    1538:	e0 2d       	mov	r30, r0
    153a:	6d e0       	ldi	r22, 0x0D	; 13
    153c:	09 95       	icall
    153e:	e8 81       	ld	r30, Y
    1540:	f9 81       	ldd	r31, Y+1	; 0x01
    1542:	02 80       	ldd	r0, Z+2	; 0x02
    1544:	f3 81       	ldd	r31, Z+3	; 0x03
    1546:	e0 2d       	mov	r30, r0
    1548:	ce 01       	movw	r24, r28
    154a:	6a e0       	ldi	r22, 0x0A	; 10
    154c:	09 95       	icall
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    154e:	ce 01       	movw	r24, r28
    1550:	df 91       	pop	r29
    1552:	cf 91       	pop	r28
    1554:	08 95       	ret
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
	switch (new_manip)
    1556:	61 30       	cpi	r22, 0x01	; 1
    1558:	31 f1       	breq	.+76     	; 0x15a6 <_ZN8emstreamlsE15ser_manipulator+0x96>
    155a:	61 30       	cpi	r22, 0x01	; 1
    155c:	70 f0       	brcs	.+28     	; 0x157a <_ZN8emstreamlsE15ser_manipulator+0x6a>
    155e:	62 30       	cpi	r22, 0x02	; 2
    1560:	c1 f0       	breq	.+48     	; 0x1592 <_ZN8emstreamlsE15ser_manipulator+0x82>
    1562:	63 30       	cpi	r22, 0x03	; 3
    1564:	a1 f7       	brne	.-24     	; 0x154e <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (dec):                         // Print integers in decimal
			base = 10;
			break;
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    1566:	80 e1       	ldi	r24, 0x10	; 16
    1568:	8a 83       	std	Y+2, r24	; 0x02
			break;
    156a:	f1 cf       	rjmp	.-30     	; 0x154e <_ZN8emstreamlsE15ser_manipulator+0x3e>
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
	switch (new_manip)
    156c:	68 30       	cpi	r22, 0x08	; 8
    156e:	a1 f0       	breq	.+40     	; 0x1598 <_ZN8emstreamlsE15ser_manipulator+0x88>
    1570:	6a 30       	cpi	r22, 0x0A	; 10
    1572:	69 f7       	brne	.-38     	; 0x154e <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
			break;
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    1574:	81 e0       	ldi	r24, 0x01	; 1
    1576:	8c 83       	std	Y+4, r24	; 0x04
			break;
    1578:	ea cf       	rjmp	.-44     	; 0x154e <_ZN8emstreamlsE15ser_manipulator+0x3e>
emstream& emstream::operator<< (ser_manipulator new_manip)
{
	switch (new_manip)
	{
		case (bin):                         // Print integers in binary
			base = 2;
    157a:	82 e0       	ldi	r24, 0x02	; 2
    157c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    157e:	e7 cf       	rjmp	.-50     	; 0x154e <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
			break;
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    1580:	1b 82       	std	Y+3, r1	; 0x03
			break;
    1582:	e5 cf       	rjmp	.-54     	; 0x154e <_ZN8emstreamlsE15ser_manipulator+0x3e>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
			break;
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    1584:	e8 81       	ld	r30, Y
    1586:	f9 81       	ldd	r31, Y+1	; 0x01
    1588:	02 84       	ldd	r0, Z+10	; 0x0a
    158a:	f3 85       	ldd	r31, Z+11	; 0x0b
    158c:	e0 2d       	mov	r30, r0
    158e:	09 95       	icall
			break;
    1590:	de cf       	rjmp	.-68     	; 0x154e <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (oct):                         // Print integers in octal
			base = 8;
			break;
		case (dec):                         // Print integers in decimal
			base = 10;
    1592:	8a e0       	ldi	r24, 0x0A	; 10
    1594:	8a 83       	std	Y+2, r24	; 0x02
			break;
    1596:	db cf       	rjmp	.-74     	; 0x154e <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
			break;
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    1598:	e8 81       	ld	r30, Y
    159a:	f9 81       	ldd	r31, Y+1	; 0x01
    159c:	00 84       	ldd	r0, Z+8	; 0x08
    159e:	f1 85       	ldd	r31, Z+9	; 0x09
    15a0:	e0 2d       	mov	r30, r0
    15a2:	09 95       	icall
			break;
    15a4:	d4 cf       	rjmp	.-88     	; 0x154e <_ZN8emstreamlsE15ser_manipulator+0x3e>
	{
		case (bin):                         // Print integers in binary
			base = 2;
			break;
		case (oct):                         // Print integers in octal
			base = 8;
    15a6:	88 e0       	ldi	r24, 0x08	; 8
    15a8:	8a 83       	std	Y+2, r24	; 0x02
			break;
    15aa:	d1 cf       	rjmp	.-94     	; 0x154e <_ZN8emstreamlsE15ser_manipulator+0x3e>
			break;
		case (hex):                         // Print integers in hexadecimal
			base = 16;
			break;
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    15ac:	81 e0       	ldi	r24, 0x01	; 1
    15ae:	8b 83       	std	Y+3, r24	; 0x03
			break;
    15b0:	ce cf       	rjmp	.-100    	; 0x154e <_ZN8emstreamlsE15ser_manipulator+0x3e>

000015b2 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    15b2:	ff 92       	push	r15
    15b4:	0f 93       	push	r16
    15b6:	1f 93       	push	r17
    15b8:	cf 93       	push	r28
    15ba:	df 93       	push	r29
    15bc:	cd b7       	in	r28, 0x3d	; 61
    15be:	de b7       	in	r29, 0x3e	; 62
    15c0:	61 97       	sbiw	r28, 0x11	; 17
    15c2:	0f b6       	in	r0, 0x3f	; 63
    15c4:	f8 94       	cli
    15c6:	de bf       	out	0x3e, r29	; 62
    15c8:	0f be       	out	0x3f, r0	; 63
    15ca:	cd bf       	out	0x3d, r28	; 61
    15cc:	8c 01       	movw	r16, r24
    15ce:	f6 2e       	mov	r15, r22
	if (base == 16 || base == 8 || base == 2)
    15d0:	fc 01       	movw	r30, r24
    15d2:	42 81       	ldd	r20, Z+2	; 0x02
    15d4:	40 31       	cpi	r20, 0x10	; 16
    15d6:	99 f0       	breq	.+38     	; 0x15fe <_ZN8emstreamlsEj+0x4c>
    15d8:	48 30       	cpi	r20, 0x08	; 8
    15da:	89 f0       	breq	.+34     	; 0x15fe <_ZN8emstreamlsEj+0x4c>
    15dc:	42 30       	cpi	r20, 0x02	; 2
    15de:	79 f0       	breq	.+30     	; 0x15fe <_ZN8emstreamlsEj+0x4c>
		*this << parts.bits[1] << parts.bits[0];
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
    15e0:	86 2f       	mov	r24, r22
    15e2:	97 2f       	mov	r25, r23
    15e4:	be 01       	movw	r22, r28
    15e6:	6f 5f       	subi	r22, 0xFF	; 255
    15e8:	7f 4f       	sbci	r23, 0xFF	; 255
    15ea:	50 e0       	ldi	r21, 0x00	; 0
    15ec:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <utoa>
		puts (out_str);
    15f0:	c8 01       	movw	r24, r16
    15f2:	be 01       	movw	r22, r28
    15f4:	6f 5f       	subi	r22, 0xFF	; 255
    15f6:	7f 4f       	sbci	r23, 0xFF	; 255
    15f8:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
    15fc:	07 c0       	rjmp	.+14     	; 0x160c <_ZN8emstreamlsEj+0x5a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    15fe:	c8 01       	movw	r24, r16
    1600:	67 2f       	mov	r22, r23
    1602:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <_ZN8emstreamlsEh>
    1606:	6f 2d       	mov	r22, r15
    1608:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <_ZN8emstreamlsEh>
		utoa (num, out_str, base);
		puts (out_str);
	}

	return (*this);
}
    160c:	c8 01       	movw	r24, r16
    160e:	61 96       	adiw	r28, 0x11	; 17
    1610:	0f b6       	in	r0, 0x3f	; 63
    1612:	f8 94       	cli
    1614:	de bf       	out	0x3e, r29	; 62
    1616:	0f be       	out	0x3f, r0	; 63
    1618:	cd bf       	out	0x3d, r28	; 61
    161a:	df 91       	pop	r29
    161c:	cf 91       	pop	r28
    161e:	1f 91       	pop	r17
    1620:	0f 91       	pop	r16
    1622:	ff 90       	pop	r15
    1624:	08 95       	ret

00001626 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    1626:	ff 92       	push	r15
    1628:	0f 93       	push	r16
    162a:	1f 93       	push	r17
    162c:	cf 93       	push	r28
    162e:	df 93       	push	r29
    1630:	cd b7       	in	r28, 0x3d	; 61
    1632:	de b7       	in	r29, 0x3e	; 62
    1634:	a3 97       	sbiw	r28, 0x23	; 35
    1636:	0f b6       	in	r0, 0x3f	; 63
    1638:	f8 94       	cli
    163a:	de bf       	out	0x3e, r29	; 62
    163c:	0f be       	out	0x3f, r0	; 63
    163e:	cd bf       	out	0x3d, r28	; 61
    1640:	8c 01       	movw	r16, r24
    1642:	f6 2e       	mov	r15, r22
    1644:	37 2f       	mov	r19, r23
	if (base == 16 || base == 8 || base == 2)
    1646:	fc 01       	movw	r30, r24
    1648:	22 81       	ldd	r18, Z+2	; 0x02
    164a:	20 31       	cpi	r18, 0x10	; 16
    164c:	a1 f0       	breq	.+40     	; 0x1676 <_ZN8emstreamlsEm+0x50>
    164e:	28 30       	cpi	r18, 0x08	; 8
    1650:	91 f0       	breq	.+36     	; 0x1676 <_ZN8emstreamlsEm+0x50>
    1652:	22 30       	cpi	r18, 0x02	; 2
    1654:	81 f0       	breq	.+32     	; 0x1676 <_ZN8emstreamlsEm+0x50>
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
    1656:	ba 01       	movw	r22, r20
    1658:	8f 2d       	mov	r24, r15
    165a:	93 2f       	mov	r25, r19
    165c:	ae 01       	movw	r20, r28
    165e:	4f 5f       	subi	r20, 0xFF	; 255
    1660:	5f 4f       	sbci	r21, 0xFF	; 255
    1662:	30 e0       	ldi	r19, 0x00	; 0
    1664:	0e 94 bd 1b 	call	0x377a	; 0x377a <ultoa>
		puts (out_str);
    1668:	c8 01       	movw	r24, r16
    166a:	be 01       	movw	r22, r28
    166c:	6f 5f       	subi	r22, 0xFF	; 255
    166e:	7f 4f       	sbci	r23, 0xFF	; 255
    1670:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
    1674:	11 c0       	rjmp	.+34     	; 0x1698 <_ZN8emstreamlsEm+0x72>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    1676:	c8 01       	movw	r24, r16
    1678:	63 2f       	mov	r22, r19
    167a:	4b a3       	lds	r20, 0x5b
    167c:	5a a3       	lds	r21, 0x5a
    167e:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <_ZN8emstreamlsEh>
    1682:	6f 2d       	mov	r22, r15
    1684:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <_ZN8emstreamlsEh>
    1688:	5a a1       	lds	r21, 0x4a
    168a:	65 2f       	mov	r22, r21
    168c:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <_ZN8emstreamlsEh>
    1690:	4b a1       	lds	r20, 0x4b
    1692:	64 2f       	mov	r22, r20
    1694:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <_ZN8emstreamlsEh>
		ultoa ((long)num, out_str, base);
		puts (out_str);
	}

	return (*this);
}
    1698:	c8 01       	movw	r24, r16
    169a:	a3 96       	adiw	r28, 0x23	; 35
    169c:	0f b6       	in	r0, 0x3f	; 63
    169e:	f8 94       	cli
    16a0:	de bf       	out	0x3e, r29	; 62
    16a2:	0f be       	out	0x3f, r0	; 63
    16a4:	cd bf       	out	0x3d, r28	; 61
    16a6:	df 91       	pop	r29
    16a8:	cf 91       	pop	r28
    16aa:	1f 91       	pop	r17
    16ac:	0f 91       	pop	r16
    16ae:	ff 90       	pop	r15
    16b0:	08 95       	ret

000016b2 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    16b2:	cf 92       	push	r12
    16b4:	df 92       	push	r13
    16b6:	ef 92       	push	r14
    16b8:	ff 92       	push	r15
    16ba:	0f 93       	push	r16
    16bc:	1f 93       	push	r17
    16be:	cf 93       	push	r28
    16c0:	df 93       	push	r29
    16c2:	cd b7       	in	r28, 0x3d	; 61
    16c4:	de b7       	in	r29, 0x3e	; 62
    16c6:	29 97       	sbiw	r28, 0x09	; 9
    16c8:	0f b6       	in	r0, 0x3f	; 63
    16ca:	f8 94       	cli
    16cc:	de bf       	out	0x3e, r29	; 62
    16ce:	0f be       	out	0x3f, r0	; 63
    16d0:	cd bf       	out	0x3d, r28	; 61
    16d2:	6c 01       	movw	r12, r24
    16d4:	06 2f       	mov	r16, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    16d6:	dc 01       	movw	r26, r24
    16d8:	13 96       	adiw	r26, 0x03	; 3
    16da:	8c 91       	ld	r24, X
    16dc:	13 97       	sbiw	r26, 0x03	; 3
    16de:	88 23       	and	r24, r24
    16e0:	09 f0       	breq	.+2      	; 0x16e4 <_ZN8emstreamlsEh+0x32>
    16e2:	5e c0       	rjmp	.+188    	; 0x17a0 <_ZN8emstreamlsEh+0xee>
	{
		putchar (num);
	}
	else if (base == 2)
    16e4:	f6 01       	movw	r30, r12
    16e6:	42 81       	ldd	r20, Z+2	; 0x02
    16e8:	42 30       	cpi	r20, 0x02	; 2
    16ea:	e1 f1       	breq	.+120    	; 0x1764 <_ZN8emstreamlsEh+0xb2>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    16ec:	40 31       	cpi	r20, 0x10	; 16
    16ee:	f1 f0       	breq	.+60     	; 0x172c <_ZN8emstreamlsEh+0x7a>
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
    16f0:	86 2f       	mov	r24, r22
    16f2:	90 e0       	ldi	r25, 0x00	; 0
    16f4:	be 01       	movw	r22, r28
    16f6:	6f 5f       	subi	r22, 0xFF	; 255
    16f8:	7f 4f       	sbci	r23, 0xFF	; 255
    16fa:	50 e0       	ldi	r21, 0x00	; 0
    16fc:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <utoa>
		puts (out_str);
    1700:	c6 01       	movw	r24, r12
    1702:	be 01       	movw	r22, r28
    1704:	6f 5f       	subi	r22, 0xFF	; 255
    1706:	7f 4f       	sbci	r23, 0xFF	; 255
    1708:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    170c:	c6 01       	movw	r24, r12
    170e:	29 96       	adiw	r28, 0x09	; 9
    1710:	0f b6       	in	r0, 0x3f	; 63
    1712:	f8 94       	cli
    1714:	de bf       	out	0x3e, r29	; 62
    1716:	0f be       	out	0x3f, r0	; 63
    1718:	cd bf       	out	0x3d, r28	; 61
    171a:	df 91       	pop	r29
    171c:	cf 91       	pop	r28
    171e:	1f 91       	pop	r17
    1720:	0f 91       	pop	r16
    1722:	ff 90       	pop	r15
    1724:	ef 90       	pop	r14
    1726:	df 90       	pop	r13
    1728:	cf 90       	pop	r12
    172a:	08 95       	ret
			else             putchar ('0');
		}
	}
	else if (base == 16)
	{
		temp_char = (num >> 4) & 0x0F;
    172c:	62 95       	swap	r22
    172e:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    1730:	01 90       	ld	r0, Z+
    1732:	f0 81       	ld	r31, Z
    1734:	e0 2d       	mov	r30, r0
    1736:	02 80       	ldd	r0, Z+2	; 0x02
    1738:	f3 81       	ldd	r31, Z+3	; 0x03
    173a:	e0 2d       	mov	r30, r0
    173c:	6a 30       	cpi	r22, 0x0A	; 10
    173e:	c0 f5       	brcc	.+112    	; 0x17b0 <_ZN8emstreamlsEh+0xfe>
    1740:	60 5d       	subi	r22, 0xD0	; 208
    1742:	c6 01       	movw	r24, r12
    1744:	09 95       	icall
		temp_char = num & 0x0F;
    1746:	0f 70       	andi	r16, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    1748:	d6 01       	movw	r26, r12
    174a:	ed 91       	ld	r30, X+
    174c:	fc 91       	ld	r31, X
    174e:	11 97       	sbiw	r26, 0x01	; 1
    1750:	02 80       	ldd	r0, Z+2	; 0x02
    1752:	f3 81       	ldd	r31, Z+3	; 0x03
    1754:	e0 2d       	mov	r30, r0
    1756:	60 2f       	mov	r22, r16
    1758:	0a 30       	cpi	r16, 0x0A	; 10
    175a:	60 f1       	brcs	.+88     	; 0x17b4 <_ZN8emstreamlsEh+0x102>
    175c:	69 5c       	subi	r22, 0xC9	; 201
    175e:	c6 01       	movw	r24, r12
    1760:	09 95       	icall
    1762:	d4 cf       	rjmp	.-88     	; 0x170c <_ZN8emstreamlsEh+0x5a>

	if (print_ascii)
	{
		putchar (num);
	}
	else if (base == 2)
    1764:	88 e0       	ldi	r24, 0x08	; 8
    1766:	e8 2e       	mov	r14, r24
    1768:	f1 2c       	mov	r15, r1
    176a:	10 e8       	ldi	r17, 0x80	; 128
    176c:	0a c0       	rjmp	.+20     	; 0x1782 <_ZN8emstreamlsEh+0xd0>
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    176e:	c6 01       	movw	r24, r12
    1770:	61 e3       	ldi	r22, 0x31	; 49
    1772:	09 95       	icall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    1774:	16 95       	lsr	r17
    1776:	08 94       	sec
    1778:	e1 08       	sbc	r14, r1
    177a:	f1 08       	sbc	r15, r1
    177c:	e1 14       	cp	r14, r1
    177e:	f1 04       	cpc	r15, r1
    1780:	29 f2       	breq	.-118    	; 0x170c <_ZN8emstreamlsEh+0x5a>
		{
			if (num & bmask) putchar ('1');
    1782:	81 2f       	mov	r24, r17
    1784:	80 23       	and	r24, r16
    1786:	d6 01       	movw	r26, r12
    1788:	ed 91       	ld	r30, X+
    178a:	fc 91       	ld	r31, X
    178c:	11 97       	sbiw	r26, 0x01	; 1
    178e:	02 80       	ldd	r0, Z+2	; 0x02
    1790:	f3 81       	ldd	r31, Z+3	; 0x03
    1792:	e0 2d       	mov	r30, r0
    1794:	88 23       	and	r24, r24
    1796:	59 f7       	brne	.-42     	; 0x176e <_ZN8emstreamlsEh+0xbc>
			else             putchar ('0');
    1798:	c6 01       	movw	r24, r12
    179a:	60 e3       	ldi	r22, 0x30	; 48
    179c:	09 95       	icall
    179e:	ea cf       	rjmp	.-44     	; 0x1774 <_ZN8emstreamlsEh+0xc2>
{
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
	{
		putchar (num);
    17a0:	ed 91       	ld	r30, X+
    17a2:	fc 91       	ld	r31, X
    17a4:	02 80       	ldd	r0, Z+2	; 0x02
    17a6:	f3 81       	ldd	r31, Z+3	; 0x03
    17a8:	e0 2d       	mov	r30, r0
    17aa:	c6 01       	movw	r24, r12
    17ac:	09 95       	icall
    17ae:	ae cf       	rjmp	.-164    	; 0x170c <_ZN8emstreamlsEh+0x5a>
		}
	}
	else if (base == 16)
	{
		temp_char = (num >> 4) & 0x0F;
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    17b0:	69 5c       	subi	r22, 0xC9	; 201
    17b2:	c7 cf       	rjmp	.-114    	; 0x1742 <_ZN8emstreamlsEh+0x90>
		temp_char = num & 0x0F;
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    17b4:	60 5d       	subi	r22, 0xD0	; 208
    17b6:	d3 cf       	rjmp	.-90     	; 0x175e <_ZN8emstreamlsEh+0xac>

000017b8 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    17b8:	fc 01       	movw	r30, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    17ba:	a2 85       	ldd	r26, Z+10	; 0x0a
    17bc:	b3 85       	ldd	r27, Z+11	; 0x0b
    17be:	8c 91       	ld	r24, X
    17c0:	36 85       	ldd	r19, Z+14	; 0x0e
    17c2:	83 23       	and	r24, r19
    17c4:	41 f4       	brne	.+16     	; 0x17d6 <_ZN5rs2327putcharEc+0x1e>
    17c6:	81 e2       	ldi	r24, 0x21	; 33
    17c8:	9e e4       	ldi	r25, 0x4E	; 78
    17ca:	02 c0       	rjmp	.+4      	; 0x17d0 <_ZN5rs2327putcharEc+0x18>
    17cc:	01 97       	sbiw	r24, 0x01	; 1
	{
		if (count > UART_TX_TOUT)
    17ce:	69 f0       	breq	.+26     	; 0x17ea <_ZN5rs2327putcharEc+0x32>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    17d0:	2c 91       	ld	r18, X
    17d2:	23 23       	and	r18, r19
    17d4:	d9 f3       	breq	.-10     	; 0x17cc <_ZN5rs2327putcharEc+0x14>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    17d6:	8c 91       	ld	r24, X
    17d8:	90 89       	ldd	r25, Z+16	; 0x10
    17da:	89 2b       	or	r24, r25
    17dc:	8c 93       	st	X, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    17de:	00 84       	ldd	r0, Z+8	; 0x08
    17e0:	f1 85       	ldd	r31, Z+9	; 0x09
    17e2:	e0 2d       	mov	r30, r0
    17e4:	60 83       	st	Z, r22
	return (true);
    17e6:	81 e0       	ldi	r24, 0x01	; 1
    17e8:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    17ea:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    17ec:	08 95       	ret

000017ee <_ZN5rs2327getcharEv>:
{
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	#ifdef UCSR0A  // If this is a dual-port chip
		if (port_num == 0)
    17ee:	fc 01       	movw	r30, r24
    17f0:	81 89       	ldd	r24, Z+17	; 0x11
    17f2:	88 23       	and	r24, r24
    17f4:	09 f5       	brne	.+66     	; 0x1838 <_ZN5rs2327getcharEv+0x4a>
    17f6:	20 91 b4 02 	lds	r18, 0x02B4
    17fa:	30 91 b5 02 	lds	r19, 0x02B5
		{
			while (rcv0_read_index == rcv0_write_index);
    17fe:	80 91 b2 02 	lds	r24, 0x02B2
    1802:	90 91 b3 02 	lds	r25, 0x02B3
    1806:	28 17       	cp	r18, r24
    1808:	39 07       	cpc	r19, r25
    180a:	c1 f1       	breq	.+112    	; 0x187c <_ZN5rs2327getcharEv+0x8e>
			recv_char = rcv0_buffer[rcv0_read_index];
    180c:	e0 91 b6 02 	lds	r30, 0x02B6
    1810:	f0 91 b7 02 	lds	r31, 0x02B7
    1814:	e2 0f       	add	r30, r18
    1816:	f3 1f       	adc	r31, r19
    1818:	80 81       	ld	r24, Z
			if (++rcv0_read_index >= RSINT_BUF_SIZE)
    181a:	2f 5f       	subi	r18, 0xFF	; 255
    181c:	3f 4f       	sbci	r19, 0xFF	; 255
    181e:	30 93 b5 02 	sts	0x02B5, r19
    1822:	20 93 b4 02 	sts	0x02B4, r18
    1826:	20 32       	cpi	r18, 0x20	; 32
    1828:	31 05       	cpc	r19, r1
    182a:	20 f0       	brcs	.+8      	; 0x1834 <_ZN5rs2327getcharEv+0x46>
				rcv0_read_index = 0;
    182c:	10 92 b5 02 	sts	0x02B5, r1
    1830:	10 92 b4 02 	sts	0x02B4, r1
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
	#endif

	return (recv_char);
}
    1834:	90 e0       	ldi	r25, 0x00	; 0
    1836:	08 95       	ret
		if (port_num == 0)
		{
			while (rcv0_read_index == rcv0_write_index);
			recv_char = rcv0_buffer[rcv0_read_index];
			if (++rcv0_read_index >= RSINT_BUF_SIZE)
				rcv0_read_index = 0;
    1838:	20 91 ae 02 	lds	r18, 0x02AE
    183c:	30 91 af 02 	lds	r19, 0x02AF
		}
		else  // This is port 1 of a dual-port chip
		{
		#if defined UCSR1A
			while (rcv1_read_index == rcv1_write_index);
    1840:	80 91 ac 02 	lds	r24, 0x02AC
    1844:	90 91 ad 02 	lds	r25, 0x02AD
    1848:	82 17       	cp	r24, r18
    184a:	93 07       	cpc	r25, r19
    184c:	b1 f0       	breq	.+44     	; 0x187a <_ZN5rs2327getcharEv+0x8c>
			recv_char = rcv1_buffer[rcv1_read_index];
    184e:	e0 91 b0 02 	lds	r30, 0x02B0
    1852:	f0 91 b1 02 	lds	r31, 0x02B1
    1856:	e2 0f       	add	r30, r18
    1858:	f3 1f       	adc	r31, r19
    185a:	80 81       	ld	r24, Z
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
    185c:	2f 5f       	subi	r18, 0xFF	; 255
    185e:	3f 4f       	sbci	r19, 0xFF	; 255
    1860:	30 93 af 02 	sts	0x02AF, r19
    1864:	20 93 ae 02 	sts	0x02AE, r18
    1868:	20 32       	cpi	r18, 0x20	; 32
    186a:	31 05       	cpc	r19, r1
    186c:	18 f3       	brcs	.-58     	; 0x1834 <_ZN5rs2327getcharEv+0x46>
				rcv1_read_index = 0;
    186e:	10 92 af 02 	sts	0x02AF, r1
    1872:	10 92 ae 02 	sts	0x02AE, r1
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
	#endif

	return (recv_char);
}
    1876:	90 e0       	ldi	r25, 0x00	; 0
    1878:	08 95       	ret
    187a:	ff cf       	rjmp	.-2      	; 0x187a <_ZN5rs2327getcharEv+0x8c>
    187c:	ff cf       	rjmp	.-2      	; 0x187c <_ZN5rs2327getcharEv+0x8e>

0000187e <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    187e:	dc 01       	movw	r26, r24
    1880:	ed 91       	ld	r30, X+
    1882:	fc 91       	ld	r31, X
    1884:	02 80       	ldd	r0, Z+2	; 0x02
    1886:	f3 81       	ldd	r31, Z+3	; 0x03
    1888:	e0 2d       	mov	r30, r0
    188a:	6c e0       	ldi	r22, 0x0C	; 12
    188c:	09 95       	icall
}
    188e:	08 95       	ret

00001890 <_ZN5rs23214check_for_charEv>:
 */

bool rs232::check_for_char (void)
{
	#ifdef UCSR1A							// If this is a dual-port chip
		if (port_num == 0)
    1890:	fc 01       	movw	r30, r24
    1892:	81 89       	ldd	r24, Z+17	; 0x11
    1894:	88 23       	and	r24, r24
    1896:	69 f0       	breq	.+26     	; 0x18b2 <_ZN5rs23214check_for_charEv+0x22>
			return (rcv0_read_index != rcv0_write_index);
		else
			return (rcv1_read_index != rcv1_write_index);
    1898:	81 e0       	ldi	r24, 0x01	; 1
    189a:	40 91 ae 02 	lds	r20, 0x02AE
    189e:	50 91 af 02 	lds	r21, 0x02AF
    18a2:	20 91 ac 02 	lds	r18, 0x02AC
    18a6:	30 91 ad 02 	lds	r19, 0x02AD
    18aa:	42 17       	cp	r20, r18
    18ac:	53 07       	cpc	r21, r19
    18ae:	79 f0       	breq	.+30     	; 0x18ce <_ZN5rs23214check_for_charEv+0x3e>
	#else									// This chip has only one serial port
		return (rcv0_read_index != rcv0_write_index);
	#endif
}
    18b0:	08 95       	ret

bool rs232::check_for_char (void)
{
	#ifdef UCSR1A							// If this is a dual-port chip
		if (port_num == 0)
			return (rcv0_read_index != rcv0_write_index);
    18b2:	81 e0       	ldi	r24, 0x01	; 1
    18b4:	40 91 b4 02 	lds	r20, 0x02B4
    18b8:	50 91 b5 02 	lds	r21, 0x02B5
    18bc:	20 91 b2 02 	lds	r18, 0x02B2
    18c0:	30 91 b3 02 	lds	r19, 0x02B3
    18c4:	42 17       	cp	r20, r18
    18c6:	53 07       	cpc	r21, r19
    18c8:	99 f7       	brne	.-26     	; 0x18b0 <_ZN5rs23214check_for_charEv+0x20>
    18ca:	80 e0       	ldi	r24, 0x00	; 0
    18cc:	08 95       	ret
		else
			return (rcv1_read_index != rcv1_write_index);
    18ce:	80 e0       	ldi	r24, 0x00	; 0
	#else									// This chip has only one serial port
		return (rcv0_read_index != rcv0_write_index);
	#endif
}
    18d0:	08 95       	ret

000018d2 <_ZN5rs232C1Ejh>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

rs232::rs232 (uint16_t baud_rate, uint8_t port_number)
    18d2:	ff 92       	push	r15
    18d4:	0f 93       	push	r16
    18d6:	1f 93       	push	r17
    18d8:	cf 93       	push	r28
    18da:	df 93       	push	r29
    18dc:	ec 01       	movw	r28, r24
    18de:	8b 01       	movw	r16, r22
    18e0:	f4 2e       	mov	r15, r20
	: emstream (), base232 (baud_rate, port_number)
    18e2:	0e 94 39 0a 	call	0x1472	; 0x1472 <_ZN8emstreamC1Ev>
    18e6:	ce 01       	movw	r24, r28
    18e8:	08 96       	adiw	r24, 0x08	; 8
    18ea:	b8 01       	movw	r22, r16
    18ec:	4f 2d       	mov	r20, r15
    18ee:	0e 94 7b 19 	call	0x32f6	; 0x32f6 <_ZN7base232C1Ejh>
    18f2:	84 e8       	ldi	r24, 0x84	; 132
    18f4:	92 e0       	ldi	r25, 0x02	; 2
    18f6:	99 83       	std	Y+1, r25	; 0x01
    18f8:	88 83       	st	Y, r24
{
	// Save the number of the serial port, 0 or 1
	port_num = port_number;
    18fa:	f9 8a       	std	Y+17, r15	; 0x11

	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A // Serial port number 0
		if (port_number == 0)
    18fc:	ff 20       	and	r15, r15
    18fe:	d9 f0       	breq	.+54     	; 0x1936 <_ZN5rs232C1Ejh+0x64>
			rcv0_write_index = 0;
		}
		else  // Serial port number 1
		{
		#if defined UCSR1A
			UCSR1B |= (1 << RXCIE1);		// Receive complete interrupt enable
    1900:	80 91 c9 00 	lds	r24, 0x00C9
    1904:	80 68       	ori	r24, 0x80	; 128
    1906:	80 93 c9 00 	sts	0x00C9, r24

			// Allocate some memory for the receiver buffer and reset the indices
			rcv1_buffer = new uint8_t[RSINT_BUF_SIZE];
    190a:	80 e2       	ldi	r24, 0x20	; 32
    190c:	90 e0       	ldi	r25, 0x00	; 0
    190e:	0e 94 18 0a 	call	0x1430	; 0x1430 <_Znaj>
    1912:	90 93 b1 02 	sts	0x02B1, r25
    1916:	80 93 b0 02 	sts	0x02B0, r24
			rcv1_read_index = 0;
    191a:	10 92 af 02 	sts	0x02AF, r1
    191e:	10 92 ae 02 	sts	0x02AE, r1
			rcv1_write_index = 0;
    1922:	10 92 ad 02 	sts	0x02AD, r1
    1926:	10 92 ac 02 	sts	0x02AC, r1
	// use the XBee radio module
	#ifdef XIPHOS_HACKS
		if (port_number == 1)
			PORTD |= 0x04;
	#endif
}
    192a:	df 91       	pop	r29
    192c:	cf 91       	pop	r28
    192e:	1f 91       	pop	r17
    1930:	0f 91       	pop	r16
    1932:	ff 90       	pop	r15
    1934:	08 95       	ret
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A // Serial port number 0
		if (port_number == 0)
		{
			UCSR0B |= (1 << RXCIE0);		// Receive complete interrupt enable
    1936:	80 91 c1 00 	lds	r24, 0x00C1
    193a:	80 68       	ori	r24, 0x80	; 128
    193c:	80 93 c1 00 	sts	0x00C1, r24

			// Allocate some memory for the receiver buffer and reset the indices
			rcv0_buffer = new uint8_t[RSINT_BUF_SIZE];
    1940:	80 e2       	ldi	r24, 0x20	; 32
    1942:	90 e0       	ldi	r25, 0x00	; 0
    1944:	0e 94 18 0a 	call	0x1430	; 0x1430 <_Znaj>
    1948:	90 93 b7 02 	sts	0x02B7, r25
    194c:	80 93 b6 02 	sts	0x02B6, r24
			rcv0_read_index = 0;
    1950:	10 92 b5 02 	sts	0x02B5, r1
    1954:	10 92 b4 02 	sts	0x02B4, r1
			rcv0_write_index = 0;
    1958:	10 92 b3 02 	sts	0x02B3, r1
    195c:	10 92 b2 02 	sts	0x02B2, r1
	// use the XBee radio module
	#ifdef XIPHOS_HACKS
		if (port_number == 1)
			PORTD |= 0x04;
	#endif
}
    1960:	df 91       	pop	r29
    1962:	cf 91       	pop	r28
    1964:	1f 91       	pop	r17
    1966:	0f 91       	pop	r16
    1968:	ff 90       	pop	r15
    196a:	08 95       	ret

0000196c <__vector_25>:
 *  This interrupt service routine runs whenever a character has been received by the
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

ISR (RSI_CHAR_RECV_INT_0)
{
    196c:	1f 92       	push	r1
    196e:	0f 92       	push	r0
    1970:	0f b6       	in	r0, 0x3f	; 63
    1972:	0f 92       	push	r0
    1974:	0b b6       	in	r0, 0x3b	; 59
    1976:	0f 92       	push	r0
    1978:	11 24       	eor	r1, r1
    197a:	2f 93       	push	r18
    197c:	3f 93       	push	r19
    197e:	8f 93       	push	r24
    1980:	9f 93       	push	r25
    1982:	ef 93       	push	r30
    1984:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	#if defined UCSR0A  // If this is a dual-serial-port chip (ATmega324P, 128, etc.)
		rcv0_buffer[rcv0_write_index] = UDR0;
    1986:	20 91 c6 00 	lds	r18, 0x00C6
    198a:	e0 91 b6 02 	lds	r30, 0x02B6
    198e:	f0 91 b7 02 	lds	r31, 0x02B7
    1992:	80 91 b2 02 	lds	r24, 0x02B2
    1996:	90 91 b3 02 	lds	r25, 0x02B3
    199a:	e8 0f       	add	r30, r24
    199c:	f9 1f       	adc	r31, r25
    199e:	20 83       	st	Z, r18
	#else  // If this chip has only a single serial port (ATmega8, 32, etc.)
		rcv0_buffer[rcv0_write_index] = UDR;
	#endif

	// Increment the write pointer
	if (++rcv0_write_index >= RSINT_BUF_SIZE)
    19a0:	80 91 b2 02 	lds	r24, 0x02B2
    19a4:	90 91 b3 02 	lds	r25, 0x02B3
    19a8:	01 96       	adiw	r24, 0x01	; 1
    19aa:	90 93 b3 02 	sts	0x02B3, r25
    19ae:	80 93 b2 02 	sts	0x02B2, r24
    19b2:	80 32       	cpi	r24, 0x20	; 32
    19b4:	91 05       	cpc	r25, r1
    19b6:	30 f0       	brcs	.+12     	; 0x19c4 <__vector_25+0x58>
		rcv0_write_index = 0;
    19b8:	10 92 b3 02 	sts	0x02B3, r1
    19bc:	10 92 b2 02 	sts	0x02B2, r1
    19c0:	80 e0       	ldi	r24, 0x00	; 0
    19c2:	90 e0       	ldi	r25, 0x00	; 0

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
    19c4:	20 91 b4 02 	lds	r18, 0x02B4
    19c8:	30 91 b5 02 	lds	r19, 0x02B5
    19cc:	28 17       	cp	r18, r24
    19ce:	39 07       	cpc	r19, r25
    19d0:	69 f0       	breq	.+26     	; 0x19ec <__vector_25+0x80>
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
}
    19d2:	ff 91       	pop	r31
    19d4:	ef 91       	pop	r30
    19d6:	9f 91       	pop	r25
    19d8:	8f 91       	pop	r24
    19da:	3f 91       	pop	r19
    19dc:	2f 91       	pop	r18
    19de:	0f 90       	pop	r0
    19e0:	0b be       	out	0x3b, r0	; 59
    19e2:	0f 90       	pop	r0
    19e4:	0f be       	out	0x3f, r0	; 63
    19e6:	0f 90       	pop	r0
    19e8:	1f 90       	pop	r1
    19ea:	18 95       	reti

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
    19ec:	01 96       	adiw	r24, 0x01	; 1
    19ee:	90 93 b5 02 	sts	0x02B5, r25
    19f2:	80 93 b4 02 	sts	0x02B4, r24
    19f6:	80 32       	cpi	r24, 0x20	; 32
    19f8:	91 05       	cpc	r25, r1
    19fa:	58 f3       	brcs	.-42     	; 0x19d2 <__vector_25+0x66>
			rcv0_read_index = 0;
    19fc:	10 92 b5 02 	sts	0x02B5, r1
    1a00:	10 92 b4 02 	sts	0x02B4, r1
    1a04:	e6 cf       	rjmp	.-52     	; 0x19d2 <__vector_25+0x66>

00001a06 <__vector_36>:
	/** This interrupt service routine runs whenever a character has been received by the
	*  first serial port (number 0).  It saves that character into the receiver buffer.
	*/

	ISR (RSI_CHAR_RECV_INT_1)
	{
    1a06:	1f 92       	push	r1
    1a08:	0f 92       	push	r0
    1a0a:	0f b6       	in	r0, 0x3f	; 63
    1a0c:	0f 92       	push	r0
    1a0e:	0b b6       	in	r0, 0x3b	; 59
    1a10:	0f 92       	push	r0
    1a12:	11 24       	eor	r1, r1
    1a14:	2f 93       	push	r18
    1a16:	3f 93       	push	r19
    1a18:	8f 93       	push	r24
    1a1a:	9f 93       	push	r25
    1a1c:	ef 93       	push	r30
    1a1e:	ff 93       	push	r31
		// Read the character from the serial port receiver buffer
		rcv1_buffer[rcv1_write_index] = UDR1;
    1a20:	20 91 ce 00 	lds	r18, 0x00CE
    1a24:	e0 91 b0 02 	lds	r30, 0x02B0
    1a28:	f0 91 b1 02 	lds	r31, 0x02B1
    1a2c:	80 91 ac 02 	lds	r24, 0x02AC
    1a30:	90 91 ad 02 	lds	r25, 0x02AD
    1a34:	e8 0f       	add	r30, r24
    1a36:	f9 1f       	adc	r31, r25
    1a38:	20 83       	st	Z, r18

		// Increment the write pointer
		if (++rcv1_write_index >= RSINT_BUF_SIZE)
    1a3a:	80 91 ac 02 	lds	r24, 0x02AC
    1a3e:	90 91 ad 02 	lds	r25, 0x02AD
    1a42:	01 96       	adiw	r24, 0x01	; 1
    1a44:	90 93 ad 02 	sts	0x02AD, r25
    1a48:	80 93 ac 02 	sts	0x02AC, r24
    1a4c:	80 32       	cpi	r24, 0x20	; 32
    1a4e:	91 05       	cpc	r25, r1
    1a50:	30 f0       	brcs	.+12     	; 0x1a5e <__vector_36+0x58>
			rcv1_write_index = 0;
    1a52:	10 92 ad 02 	sts	0x02AD, r1
    1a56:	10 92 ac 02 	sts	0x02AC, r1
    1a5a:	80 e0       	ldi	r24, 0x00	; 0
    1a5c:	90 e0       	ldi	r25, 0x00	; 0

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
    1a5e:	20 91 ae 02 	lds	r18, 0x02AE
    1a62:	30 91 af 02 	lds	r19, 0x02AF
    1a66:	28 17       	cp	r18, r24
    1a68:	39 07       	cpc	r19, r25
    1a6a:	69 f0       	breq	.+26     	; 0x1a86 <__vector_36+0x80>
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
				rcv1_read_index = 0;
	}
    1a6c:	ff 91       	pop	r31
    1a6e:	ef 91       	pop	r30
    1a70:	9f 91       	pop	r25
    1a72:	8f 91       	pop	r24
    1a74:	3f 91       	pop	r19
    1a76:	2f 91       	pop	r18
    1a78:	0f 90       	pop	r0
    1a7a:	0b be       	out	0x3b, r0	; 59
    1a7c:	0f 90       	pop	r0
    1a7e:	0f be       	out	0x3f, r0	; 63
    1a80:	0f 90       	pop	r0
    1a82:	1f 90       	pop	r1
    1a84:	18 95       	reti

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
    1a86:	01 96       	adiw	r24, 0x01	; 1
    1a88:	90 93 af 02 	sts	0x02AF, r25
    1a8c:	80 93 ae 02 	sts	0x02AE, r24
    1a90:	80 32       	cpi	r24, 0x20	; 32
    1a92:	91 05       	cpc	r25, r1
    1a94:	58 f3       	brcs	.-42     	; 0x1a6c <__vector_36+0x66>
				rcv1_read_index = 0;
    1a96:	10 92 af 02 	sts	0x02AF, r1
    1a9a:	10 92 ae 02 	sts	0x02AE, r1
    1a9e:	e6 cf       	rjmp	.-52     	; 0x1a6c <__vector_36+0x66>

00001aa0 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1aa0:	0f 93       	push	r16
    1aa2:	1f 93       	push	r17
    1aa4:	cf 93       	push	r28
    1aa6:	df 93       	push	r29
    1aa8:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1aaa:	0e 94 ec 14 	call	0x29d8	; 0x29d8 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    1aae:	c0 91 b8 02 	lds	r28, 0x02B8
    1ab2:	d0 91 b9 02 	lds	r29, 0x02B9
    1ab6:	0c 0f       	add	r16, r28
    1ab8:	1d 1f       	adc	r17, r29
    1aba:	87 e1       	ldi	r24, 0x17	; 23
    1abc:	08 33       	cpi	r16, 0x38	; 56
    1abe:	18 07       	cpc	r17, r24
    1ac0:	88 f4       	brcc	.+34     	; 0x1ae4 <pvPortMalloc+0x44>
    1ac2:	c0 17       	cp	r28, r16
    1ac4:	d1 07       	cpc	r29, r17
    1ac6:	70 f4       	brcc	.+28     	; 0x1ae4 <pvPortMalloc+0x44>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1ac8:	c6 54       	subi	r28, 0x46	; 70
    1aca:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
    1acc:	10 93 b9 02 	sts	0x02B9, r17
    1ad0:	00 93 b8 02 	sts	0x02B8, r16
		}	
	}
	xTaskResumeAll();
    1ad4:	0e 94 19 16 	call	0x2c32	; 0x2c32 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    1ad8:	ce 01       	movw	r24, r28
    1ada:	df 91       	pop	r29
    1adc:	cf 91       	pop	r28
    1ade:	1f 91       	pop	r17
    1ae0:	0f 91       	pop	r16
    1ae2:	08 95       	ret
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    1ae4:	c0 e0       	ldi	r28, 0x00	; 0
    1ae6:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    1ae8:	0e 94 19 16 	call	0x2c32	; 0x2c32 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    1aec:	ce 01       	movw	r24, r28
    1aee:	df 91       	pop	r29
    1af0:	cf 91       	pop	r28
    1af2:	1f 91       	pop	r17
    1af4:	0f 91       	pop	r16
    1af6:	08 95       	ret

00001af8 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    1af8:	08 95       	ret

00001afa <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1afa:	10 92 b9 02 	sts	0x02B9, r1
    1afe:	10 92 b8 02 	sts	0x02B8, r1
}
    1b02:	08 95       	ret

00001b04 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    1b04:	88 e3       	ldi	r24, 0x38	; 56
    1b06:	97 e1       	ldi	r25, 0x17	; 23
    1b08:	20 91 b8 02 	lds	r18, 0x02B8
    1b0c:	30 91 b9 02 	lds	r19, 0x02B9
    1b10:	82 1b       	sub	r24, r18
    1b12:	93 0b       	sbc	r25, r19
}
    1b14:	08 95       	ret

00001b16 <pxPortInitialiseStack>:
	// variable here which holds the address of the top of the stack. It will be
	// grabbed by the task's wrapper object just after xTaskCreate() is called so that
	// the task object knows where its stack is. The stack can then be dumped to a
	// serial port (as a hex printout) for debugging purposes. 
	#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
		portStackTopForTask = (size_t)pxTopOfStack;
    1b16:	90 93 55 1a 	sts	0x1A55, r25
    1b1a:	80 93 54 1a 	sts	0x1A54, r24
	#endif

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1b1e:	21 e1       	ldi	r18, 0x11	; 17
    1b20:	fc 01       	movw	r30, r24
    1b22:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    1b24:	31 97       	sbiw	r30, 0x01	; 1
    1b26:	32 e2       	ldi	r19, 0x22	; 34
    1b28:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    1b2a:	fc 01       	movw	r30, r24
    1b2c:	32 97       	sbiw	r30, 0x02	; 2
    1b2e:	a3 e3       	ldi	r26, 0x33	; 51
    1b30:	a0 83       	st	Z, r26
	pxTopOfStack--;
#else
	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1b32:	fc 01       	movw	r30, r24
    1b34:	33 97       	sbiw	r30, 0x03	; 3
    1b36:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1b38:	fc 01       	movw	r30, r24
    1b3a:	34 97       	sbiw	r30, 0x04	; 4
    1b3c:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    1b3e:	fc 01       	movw	r30, r24
    1b40:	35 97       	sbiw	r30, 0x05	; 5
    1b42:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1b44:	fc 01       	movw	r30, r24
    1b46:	36 97       	sbiw	r30, 0x06	; 6
    1b48:	60 e8       	ldi	r22, 0x80	; 128
    1b4a:	60 83       	st	Z, r22
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
	pxTopOfStack--;
#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    1b4c:	fc 01       	movw	r30, r24
    1b4e:	37 97       	sbiw	r30, 0x07	; 7
    1b50:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    1b52:	fc 01       	movw	r30, r24
    1b54:	38 97       	sbiw	r30, 0x08	; 8
    1b56:	62 e0       	ldi	r22, 0x02	; 2
    1b58:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    1b5a:	fc 01       	movw	r30, r24
    1b5c:	39 97       	sbiw	r30, 0x09	; 9
    1b5e:	63 e0       	ldi	r22, 0x03	; 3
    1b60:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1b62:	fc 01       	movw	r30, r24
    1b64:	3a 97       	sbiw	r30, 0x0a	; 10
    1b66:	64 e0       	ldi	r22, 0x04	; 4
    1b68:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1b6a:	fc 01       	movw	r30, r24
    1b6c:	3b 97       	sbiw	r30, 0x0b	; 11
    1b6e:	65 e0       	ldi	r22, 0x05	; 5
    1b70:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    1b72:	fc 01       	movw	r30, r24
    1b74:	3c 97       	sbiw	r30, 0x0c	; 12
    1b76:	66 e0       	ldi	r22, 0x06	; 6
    1b78:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    1b7a:	fc 01       	movw	r30, r24
    1b7c:	3d 97       	sbiw	r30, 0x0d	; 13
    1b7e:	67 e0       	ldi	r22, 0x07	; 7
    1b80:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1b82:	fc 01       	movw	r30, r24
    1b84:	3e 97       	sbiw	r30, 0x0e	; 14
    1b86:	68 e0       	ldi	r22, 0x08	; 8
    1b88:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1b8a:	fc 01       	movw	r30, r24
    1b8c:	3f 97       	sbiw	r30, 0x0f	; 15
    1b8e:	69 e0       	ldi	r22, 0x09	; 9
    1b90:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1b92:	fc 01       	movw	r30, r24
    1b94:	70 97       	sbiw	r30, 0x10	; 16
    1b96:	60 e1       	ldi	r22, 0x10	; 16
    1b98:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1b9a:	fc 01       	movw	r30, r24
    1b9c:	71 97       	sbiw	r30, 0x11	; 17
    1b9e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1ba0:	fc 01       	movw	r30, r24
    1ba2:	72 97       	sbiw	r30, 0x12	; 18
    1ba4:	22 e1       	ldi	r18, 0x12	; 18
    1ba6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1ba8:	fc 01       	movw	r30, r24
    1baa:	73 97       	sbiw	r30, 0x13	; 19
    1bac:	23 e1       	ldi	r18, 0x13	; 19
    1bae:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1bb0:	fc 01       	movw	r30, r24
    1bb2:	74 97       	sbiw	r30, 0x14	; 20
    1bb4:	24 e1       	ldi	r18, 0x14	; 20
    1bb6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1bb8:	fc 01       	movw	r30, r24
    1bba:	75 97       	sbiw	r30, 0x15	; 21
    1bbc:	25 e1       	ldi	r18, 0x15	; 21
    1bbe:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1bc0:	fc 01       	movw	r30, r24
    1bc2:	76 97       	sbiw	r30, 0x16	; 22
    1bc4:	26 e1       	ldi	r18, 0x16	; 22
    1bc6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1bc8:	fc 01       	movw	r30, r24
    1bca:	77 97       	sbiw	r30, 0x17	; 23
    1bcc:	27 e1       	ldi	r18, 0x17	; 23
    1bce:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1bd0:	fc 01       	movw	r30, r24
    1bd2:	78 97       	sbiw	r30, 0x18	; 24
    1bd4:	28 e1       	ldi	r18, 0x18	; 24
    1bd6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    1bd8:	fc 01       	movw	r30, r24
    1bda:	79 97       	sbiw	r30, 0x19	; 25
    1bdc:	29 e1       	ldi	r18, 0x19	; 25
    1bde:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1be0:	fc 01       	movw	r30, r24
    1be2:	7a 97       	sbiw	r30, 0x1a	; 26
    1be4:	20 e2       	ldi	r18, 0x20	; 32
    1be6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1be8:	fc 01       	movw	r30, r24
    1bea:	7b 97       	sbiw	r30, 0x1b	; 27
    1bec:	21 e2       	ldi	r18, 0x21	; 33
    1bee:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    1bf0:	fc 01       	movw	r30, r24
    1bf2:	7c 97       	sbiw	r30, 0x1c	; 28
    1bf4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1bf6:	fc 01       	movw	r30, r24
    1bf8:	7d 97       	sbiw	r30, 0x1d	; 29
    1bfa:	23 e2       	ldi	r18, 0x23	; 35
    1bfc:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1bfe:	fc 01       	movw	r30, r24
    1c00:	7e 97       	sbiw	r30, 0x1e	; 30
    1c02:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1c04:	fc 01       	movw	r30, r24
    1c06:	7f 97       	sbiw	r30, 0x1f	; 31
    1c08:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1c0a:	fc 01       	movw	r30, r24
    1c0c:	b0 97       	sbiw	r30, 0x20	; 32
    1c0e:	26 e2       	ldi	r18, 0x26	; 38
    1c10:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    1c12:	fc 01       	movw	r30, r24
    1c14:	b1 97       	sbiw	r30, 0x21	; 33
    1c16:	27 e2       	ldi	r18, 0x27	; 39
    1c18:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    1c1a:	fc 01       	movw	r30, r24
    1c1c:	b2 97       	sbiw	r30, 0x22	; 34
    1c1e:	28 e2       	ldi	r18, 0x28	; 40
    1c20:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    1c22:	fc 01       	movw	r30, r24
    1c24:	b3 97       	sbiw	r30, 0x23	; 35
    1c26:	29 e2       	ldi	r18, 0x29	; 41
    1c28:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    1c2a:	fc 01       	movw	r30, r24
    1c2c:	b4 97       	sbiw	r30, 0x24	; 36
    1c2e:	20 e3       	ldi	r18, 0x30	; 48
    1c30:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    1c32:	fc 01       	movw	r30, r24
    1c34:	b5 97       	sbiw	r30, 0x25	; 37
    1c36:	21 e3       	ldi	r18, 0x31	; 49
    1c38:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1c3a:	86 97       	sbiw	r24, 0x26	; 38
}
    1c3c:	08 95       	ret

00001c3e <xPortStartScheduler>:

	// Use the highest numbered timer available on a given AVR processor, because the
	// lower numbered timers are hooked up to useful things such as PWM's
	#if (defined TIMER5_COMPA_vect)             // Use Timer 5 on ATmega1280/1281
		#define RT_VECT TIMER5_COMPA_vect
		OCR5AH = compare_match.byte[1];         // Set high byte of compare match
    1c3e:	87 e0       	ldi	r24, 0x07	; 7
    1c40:	80 93 29 01 	sts	0x0129, r24
		OCR5AL = compare_match.byte[0];         // register, then low byte
    1c44:	8f ec       	ldi	r24, 0xCF	; 207
    1c46:	80 93 28 01 	sts	0x0128, r24
		TCCR5B = (1 << CS51) | (1 << WGM52);    // Prescale F_CPU / 8, clear on match
    1c4a:	8a e0       	ldi	r24, 0x0A	; 10
    1c4c:	80 93 21 01 	sts	0x0121, r24
		TIMSK5 |= (1 << OCIE5A);                // Enable the timer interrupt
    1c50:	e3 e7       	ldi	r30, 0x73	; 115
    1c52:	f0 e0       	ldi	r31, 0x00	; 0
    1c54:	80 81       	ld	r24, Z
    1c56:	82 60       	ori	r24, 0x02	; 2
    1c58:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1c5a:	a0 91 f2 19 	lds	r26, 0x19F2
    1c5e:	b0 91 f3 19 	lds	r27, 0x19F3
    1c62:	cd 91       	ld	r28, X+
    1c64:	cd bf       	out	0x3d, r28	; 61
    1c66:	dd 91       	ld	r29, X+
    1c68:	de bf       	out	0x3e, r29	; 62
    1c6a:	ff 91       	pop	r31
    1c6c:	ef 91       	pop	r30
    1c6e:	df 91       	pop	r29
    1c70:	cf 91       	pop	r28
    1c72:	bf 91       	pop	r27
    1c74:	af 91       	pop	r26
    1c76:	9f 91       	pop	r25
    1c78:	8f 91       	pop	r24
    1c7a:	7f 91       	pop	r23
    1c7c:	6f 91       	pop	r22
    1c7e:	5f 91       	pop	r21
    1c80:	4f 91       	pop	r20
    1c82:	3f 91       	pop	r19
    1c84:	2f 91       	pop	r18
    1c86:	1f 91       	pop	r17
    1c88:	0f 91       	pop	r16
    1c8a:	ff 90       	pop	r15
    1c8c:	ef 90       	pop	r14
    1c8e:	df 90       	pop	r13
    1c90:	cf 90       	pop	r12
    1c92:	bf 90       	pop	r11
    1c94:	af 90       	pop	r10
    1c96:	9f 90       	pop	r9
    1c98:	8f 90       	pop	r8
    1c9a:	7f 90       	pop	r7
    1c9c:	6f 90       	pop	r6
    1c9e:	5f 90       	pop	r5
    1ca0:	4f 90       	pop	r4
    1ca2:	3f 90       	pop	r3
    1ca4:	2f 90       	pop	r2
    1ca6:	1f 90       	pop	r1
    1ca8:	0f 90       	pop	r0
    1caa:	0f be       	out	0x3f, r0	; 63
    1cac:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1cae:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1cb0:	81 e0       	ldi	r24, 0x01	; 1
    1cb2:	08 95       	ret

00001cb4 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1cb4:	08 95       	ret

00001cb6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1cb6:	0f 92       	push	r0
    1cb8:	0f b6       	in	r0, 0x3f	; 63
    1cba:	f8 94       	cli
    1cbc:	0f 92       	push	r0
    1cbe:	1f 92       	push	r1
    1cc0:	11 24       	eor	r1, r1
    1cc2:	2f 92       	push	r2
    1cc4:	3f 92       	push	r3
    1cc6:	4f 92       	push	r4
    1cc8:	5f 92       	push	r5
    1cca:	6f 92       	push	r6
    1ccc:	7f 92       	push	r7
    1cce:	8f 92       	push	r8
    1cd0:	9f 92       	push	r9
    1cd2:	af 92       	push	r10
    1cd4:	bf 92       	push	r11
    1cd6:	cf 92       	push	r12
    1cd8:	df 92       	push	r13
    1cda:	ef 92       	push	r14
    1cdc:	ff 92       	push	r15
    1cde:	0f 93       	push	r16
    1ce0:	1f 93       	push	r17
    1ce2:	2f 93       	push	r18
    1ce4:	3f 93       	push	r19
    1ce6:	4f 93       	push	r20
    1ce8:	5f 93       	push	r21
    1cea:	6f 93       	push	r22
    1cec:	7f 93       	push	r23
    1cee:	8f 93       	push	r24
    1cf0:	9f 93       	push	r25
    1cf2:	af 93       	push	r26
    1cf4:	bf 93       	push	r27
    1cf6:	cf 93       	push	r28
    1cf8:	df 93       	push	r29
    1cfa:	ef 93       	push	r30
    1cfc:	ff 93       	push	r31
    1cfe:	a0 91 f2 19 	lds	r26, 0x19F2
    1d02:	b0 91 f3 19 	lds	r27, 0x19F3
    1d06:	0d b6       	in	r0, 0x3d	; 61
    1d08:	0d 92       	st	X+, r0
    1d0a:	0e b6       	in	r0, 0x3e	; 62
    1d0c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1d0e:	0e 94 33 17 	call	0x2e66	; 0x2e66 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1d12:	a0 91 f2 19 	lds	r26, 0x19F2
    1d16:	b0 91 f3 19 	lds	r27, 0x19F3
    1d1a:	cd 91       	ld	r28, X+
    1d1c:	cd bf       	out	0x3d, r28	; 61
    1d1e:	dd 91       	ld	r29, X+
    1d20:	de bf       	out	0x3e, r29	; 62
    1d22:	ff 91       	pop	r31
    1d24:	ef 91       	pop	r30
    1d26:	df 91       	pop	r29
    1d28:	cf 91       	pop	r28
    1d2a:	bf 91       	pop	r27
    1d2c:	af 91       	pop	r26
    1d2e:	9f 91       	pop	r25
    1d30:	8f 91       	pop	r24
    1d32:	7f 91       	pop	r23
    1d34:	6f 91       	pop	r22
    1d36:	5f 91       	pop	r21
    1d38:	4f 91       	pop	r20
    1d3a:	3f 91       	pop	r19
    1d3c:	2f 91       	pop	r18
    1d3e:	1f 91       	pop	r17
    1d40:	0f 91       	pop	r16
    1d42:	ff 90       	pop	r15
    1d44:	ef 90       	pop	r14
    1d46:	df 90       	pop	r13
    1d48:	cf 90       	pop	r12
    1d4a:	bf 90       	pop	r11
    1d4c:	af 90       	pop	r10
    1d4e:	9f 90       	pop	r9
    1d50:	8f 90       	pop	r8
    1d52:	7f 90       	pop	r7
    1d54:	6f 90       	pop	r6
    1d56:	5f 90       	pop	r5
    1d58:	4f 90       	pop	r4
    1d5a:	3f 90       	pop	r3
    1d5c:	2f 90       	pop	r2
    1d5e:	1f 90       	pop	r1
    1d60:	0f 90       	pop	r0
    1d62:	0f be       	out	0x3f, r0	; 63
    1d64:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1d66:	08 95       	ret

00001d68 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1d68:	0f 92       	push	r0
    1d6a:	0f b6       	in	r0, 0x3f	; 63
    1d6c:	f8 94       	cli
    1d6e:	0f 92       	push	r0
    1d70:	1f 92       	push	r1
    1d72:	11 24       	eor	r1, r1
    1d74:	2f 92       	push	r2
    1d76:	3f 92       	push	r3
    1d78:	4f 92       	push	r4
    1d7a:	5f 92       	push	r5
    1d7c:	6f 92       	push	r6
    1d7e:	7f 92       	push	r7
    1d80:	8f 92       	push	r8
    1d82:	9f 92       	push	r9
    1d84:	af 92       	push	r10
    1d86:	bf 92       	push	r11
    1d88:	cf 92       	push	r12
    1d8a:	df 92       	push	r13
    1d8c:	ef 92       	push	r14
    1d8e:	ff 92       	push	r15
    1d90:	0f 93       	push	r16
    1d92:	1f 93       	push	r17
    1d94:	2f 93       	push	r18
    1d96:	3f 93       	push	r19
    1d98:	4f 93       	push	r20
    1d9a:	5f 93       	push	r21
    1d9c:	6f 93       	push	r22
    1d9e:	7f 93       	push	r23
    1da0:	8f 93       	push	r24
    1da2:	9f 93       	push	r25
    1da4:	af 93       	push	r26
    1da6:	bf 93       	push	r27
    1da8:	cf 93       	push	r28
    1daa:	df 93       	push	r29
    1dac:	ef 93       	push	r30
    1dae:	ff 93       	push	r31
    1db0:	a0 91 f2 19 	lds	r26, 0x19F2
    1db4:	b0 91 f3 19 	lds	r27, 0x19F3
    1db8:	0d b6       	in	r0, 0x3d	; 61
    1dba:	0d 92       	st	X+, r0
    1dbc:	0e b6       	in	r0, 0x3e	; 62
    1dbe:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1dc0:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskIncrementTick>
	vTaskSwitchContext();
    1dc4:	0e 94 33 17 	call	0x2e66	; 0x2e66 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1dc8:	a0 91 f2 19 	lds	r26, 0x19F2
    1dcc:	b0 91 f3 19 	lds	r27, 0x19F3
    1dd0:	cd 91       	ld	r28, X+
    1dd2:	cd bf       	out	0x3d, r28	; 61
    1dd4:	dd 91       	ld	r29, X+
    1dd6:	de bf       	out	0x3e, r29	; 62
    1dd8:	ff 91       	pop	r31
    1dda:	ef 91       	pop	r30
    1ddc:	df 91       	pop	r29
    1dde:	cf 91       	pop	r28
    1de0:	bf 91       	pop	r27
    1de2:	af 91       	pop	r26
    1de4:	9f 91       	pop	r25
    1de6:	8f 91       	pop	r24
    1de8:	7f 91       	pop	r23
    1dea:	6f 91       	pop	r22
    1dec:	5f 91       	pop	r21
    1dee:	4f 91       	pop	r20
    1df0:	3f 91       	pop	r19
    1df2:	2f 91       	pop	r18
    1df4:	1f 91       	pop	r17
    1df6:	0f 91       	pop	r16
    1df8:	ff 90       	pop	r15
    1dfa:	ef 90       	pop	r14
    1dfc:	df 90       	pop	r13
    1dfe:	cf 90       	pop	r12
    1e00:	bf 90       	pop	r11
    1e02:	af 90       	pop	r10
    1e04:	9f 90       	pop	r9
    1e06:	8f 90       	pop	r8
    1e08:	7f 90       	pop	r7
    1e0a:	6f 90       	pop	r6
    1e0c:	5f 90       	pop	r5
    1e0e:	4f 90       	pop	r4
    1e10:	3f 90       	pop	r3
    1e12:	2f 90       	pop	r2
    1e14:	1f 90       	pop	r1
    1e16:	0f 90       	pop	r0
    1e18:	0f be       	out	0x3f, r0	; 63
    1e1a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1e1c:	08 95       	ret

00001e1e <__vector_47>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1e1e:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1e22:	18 95       	reti

00001e24 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1e24:	cf 93       	push	r28
    1e26:	df 93       	push	r29
    1e28:	fc 01       	movw	r30, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1e2a:	a0 81       	ld	r26, Z
    1e2c:	b1 81       	ldd	r27, Z+1	; 0x01
    1e2e:	10 97       	sbiw	r26, 0x00	; 0
    1e30:	89 f0       	breq	.+34     	; 0x1e54 <prvCopyDataFromQueue+0x30>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1e32:	40 a1       	lds	r20, 0x40
    1e34:	26 81       	ldd	r18, Z+6	; 0x06
    1e36:	37 81       	ldd	r19, Z+7	; 0x07
    1e38:	24 0f       	add	r18, r20
    1e3a:	31 1d       	adc	r19, r1
    1e3c:	37 83       	std	Z+7, r19	; 0x07
    1e3e:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1e40:	c2 81       	ldd	r28, Z+2	; 0x02
    1e42:	d3 81       	ldd	r29, Z+3	; 0x03
    1e44:	2c 17       	cp	r18, r28
    1e46:	3d 07       	cpc	r19, r29
    1e48:	40 f4       	brcc	.+16     	; 0x1e5a <prvCopyDataFromQueue+0x36>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1e4a:	cb 01       	movw	r24, r22
    1e4c:	b9 01       	movw	r22, r18
    1e4e:	50 e0       	ldi	r21, 0x00	; 0
    1e50:	0e 94 9e 1b 	call	0x373c	; 0x373c <memcpy>
	}
}
    1e54:	df 91       	pop	r29
    1e56:	cf 91       	pop	r28
    1e58:	08 95       	ret
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1e5a:	b7 83       	std	Z+7, r27	; 0x07
    1e5c:	a6 83       	std	Z+6, r26	; 0x06
    1e5e:	9d 01       	movw	r18, r26
    1e60:	f4 cf       	rjmp	.-24     	; 0x1e4a <prvCopyDataFromQueue+0x26>

00001e62 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1e62:	0f 93       	push	r16
    1e64:	1f 93       	push	r17
    1e66:	cf 93       	push	r28
    1e68:	df 93       	push	r29
    1e6a:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1e6c:	0f b6       	in	r0, 0x3f	; 63
    1e6e:	f8 94       	cli
    1e70:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1e72:	8a a1       	lds	r24, 0x4a
    1e74:	18 16       	cp	r1, r24
    1e76:	dc f4       	brge	.+54     	; 0x1eae <prvUnlockQueue+0x4c>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e78:	8b 89       	ldd	r24, Y+19	; 0x13
    1e7a:	88 23       	and	r24, r24
    1e7c:	c1 f0       	breq	.+48     	; 0x1eae <prvUnlockQueue+0x4c>
    1e7e:	8e 01       	movw	r16, r28
    1e80:	0d 5e       	subi	r16, 0xED	; 237
    1e82:	1f 4f       	sbci	r17, 0xFF	; 255
    1e84:	08 c0       	rjmp	.+16     	; 0x1e96 <prvUnlockQueue+0x34>
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
				}

				--( pxQueue->xTxLock );
    1e86:	8a a1       	lds	r24, 0x4a
    1e88:	81 50       	subi	r24, 0x01	; 1
    1e8a:	8a a3       	lds	r24, 0x5a
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1e8c:	18 16       	cp	r1, r24
    1e8e:	7c f4       	brge	.+30     	; 0x1eae <prvUnlockQueue+0x4c>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e90:	8b 89       	ldd	r24, Y+19	; 0x13
    1e92:	88 23       	and	r24, r24
    1e94:	61 f0       	breq	.+24     	; 0x1eae <prvUnlockQueue+0x4c>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e96:	c8 01       	movw	r24, r16
    1e98:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <xTaskRemoveFromEventList>
    1e9c:	88 23       	and	r24, r24
    1e9e:	99 f3       	breq	.-26     	; 0x1e86 <prvUnlockQueue+0x24>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1ea0:	0e 94 77 18 	call	0x30ee	; 0x30ee <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1ea4:	8a a1       	lds	r24, 0x4a
    1ea6:	81 50       	subi	r24, 0x01	; 1
    1ea8:	8a a3       	lds	r24, 0x5a
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1eaa:	18 16       	cp	r1, r24
    1eac:	8c f3       	brlt	.-30     	; 0x1e90 <prvUnlockQueue+0x2e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1eae:	8f ef       	ldi	r24, 0xFF	; 255
    1eb0:	8a a3       	lds	r24, 0x5a
	}
	taskEXIT_CRITICAL();
    1eb2:	0f 90       	pop	r0
    1eb4:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1eb6:	0f b6       	in	r0, 0x3f	; 63
    1eb8:	f8 94       	cli
    1eba:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1ebc:	89 a1       	lds	r24, 0x49
    1ebe:	18 16       	cp	r1, r24
    1ec0:	dc f4       	brge	.+54     	; 0x1ef8 <prvUnlockQueue+0x96>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ec2:	88 85       	ldd	r24, Y+8	; 0x08
    1ec4:	88 23       	and	r24, r24
    1ec6:	c1 f0       	breq	.+48     	; 0x1ef8 <prvUnlockQueue+0x96>
    1ec8:	8e 01       	movw	r16, r28
    1eca:	08 5f       	subi	r16, 0xF8	; 248
    1ecc:	1f 4f       	sbci	r17, 0xFF	; 255
    1ece:	08 c0       	rjmp	.+16     	; 0x1ee0 <prvUnlockQueue+0x7e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					vTaskMissedYield();
				}

				--( pxQueue->xRxLock );
    1ed0:	89 a1       	lds	r24, 0x49
    1ed2:	81 50       	subi	r24, 0x01	; 1
    1ed4:	89 a3       	lds	r24, 0x59
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1ed6:	18 16       	cp	r1, r24
    1ed8:	7c f4       	brge	.+30     	; 0x1ef8 <prvUnlockQueue+0x96>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1eda:	88 85       	ldd	r24, Y+8	; 0x08
    1edc:	88 23       	and	r24, r24
    1ede:	61 f0       	breq	.+24     	; 0x1ef8 <prvUnlockQueue+0x96>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ee0:	c8 01       	movw	r24, r16
    1ee2:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <xTaskRemoveFromEventList>
    1ee6:	88 23       	and	r24, r24
    1ee8:	99 f3       	breq	.-26     	; 0x1ed0 <prvUnlockQueue+0x6e>
				{
					vTaskMissedYield();
    1eea:	0e 94 77 18 	call	0x30ee	; 0x30ee <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1eee:	89 a1       	lds	r24, 0x49
    1ef0:	81 50       	subi	r24, 0x01	; 1
    1ef2:	89 a3       	lds	r24, 0x59
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1ef4:	18 16       	cp	r1, r24
    1ef6:	8c f3       	brlt	.-30     	; 0x1eda <prvUnlockQueue+0x78>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1ef8:	8f ef       	ldi	r24, 0xFF	; 255
    1efa:	89 a3       	lds	r24, 0x59
	}
	taskEXIT_CRITICAL();
    1efc:	0f 90       	pop	r0
    1efe:	0f be       	out	0x3f, r0	; 63
}
    1f00:	df 91       	pop	r29
    1f02:	cf 91       	pop	r28
    1f04:	1f 91       	pop	r17
    1f06:	0f 91       	pop	r16
    1f08:	08 95       	ret

00001f0a <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1f0a:	cf 93       	push	r28
    1f0c:	df 93       	push	r29
    1f0e:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1f10:	28 a1       	lds	r18, 0x48
    1f12:	22 23       	and	r18, r18
    1f14:	59 f4       	brne	.+22     	; 0x1f2c <prvCopyDataToQueue+0x22>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1f16:	88 81       	ld	r24, Y
    1f18:	99 81       	ldd	r25, Y+1	; 0x01
    1f1a:	00 97       	sbiw	r24, 0x00	; 0
    1f1c:	09 f4       	brne	.+2      	; 0x1f20 <prvCopyDataToQueue+0x16>
    1f1e:	46 c0       	rjmp	.+140    	; 0x1fac <prvCopyDataToQueue+0xa2>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1f20:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1f22:	8f 5f       	subi	r24, 0xFF	; 255
    1f24:	8e 8f       	std	Y+30, r24	; 0x1e
}
    1f26:	df 91       	pop	r29
    1f28:	cf 91       	pop	r28
    1f2a:	08 95       	ret
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1f2c:	44 23       	and	r20, r20
    1f2e:	e1 f4       	brne	.+56     	; 0x1f68 <prvCopyDataToQueue+0x5e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1f30:	8c 81       	ldd	r24, Y+4	; 0x04
    1f32:	9d 81       	ldd	r25, Y+5	; 0x05
    1f34:	42 2f       	mov	r20, r18
    1f36:	50 e0       	ldi	r21, 0x00	; 0
    1f38:	0e 94 9e 1b 	call	0x373c	; 0x373c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1f3c:	28 a1       	lds	r18, 0x48
    1f3e:	8c 81       	ldd	r24, Y+4	; 0x04
    1f40:	9d 81       	ldd	r25, Y+5	; 0x05
    1f42:	82 0f       	add	r24, r18
    1f44:	91 1d       	adc	r25, r1
    1f46:	9d 83       	std	Y+5, r25	; 0x05
    1f48:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1f4a:	2a 81       	ldd	r18, Y+2	; 0x02
    1f4c:	3b 81       	ldd	r19, Y+3	; 0x03
    1f4e:	82 17       	cp	r24, r18
    1f50:	93 07       	cpc	r25, r19
    1f52:	30 f3       	brcs	.-52     	; 0x1f20 <prvCopyDataToQueue+0x16>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1f54:	88 81       	ld	r24, Y
    1f56:	99 81       	ldd	r25, Y+1	; 0x01
    1f58:	9d 83       	std	Y+5, r25	; 0x05
    1f5a:	8c 83       	std	Y+4, r24	; 0x04
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1f5c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1f5e:	8f 5f       	subi	r24, 0xFF	; 255
    1f60:	8e 8f       	std	Y+30, r24	; 0x1e
}
    1f62:	df 91       	pop	r29
    1f64:	cf 91       	pop	r28
    1f66:	08 95       	ret
			pxQueue->pcWriteTo = pxQueue->pcHead;
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1f68:	8e 81       	ldd	r24, Y+6	; 0x06
    1f6a:	9f 81       	ldd	r25, Y+7	; 0x07
    1f6c:	42 2f       	mov	r20, r18
    1f6e:	50 e0       	ldi	r21, 0x00	; 0
    1f70:	0e 94 9e 1b 	call	0x373c	; 0x373c <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1f74:	48 a1       	lds	r20, 0x48
    1f76:	50 e0       	ldi	r21, 0x00	; 0
    1f78:	50 95       	com	r21
    1f7a:	41 95       	neg	r20
    1f7c:	5f 4f       	sbci	r21, 0xFF	; 255
    1f7e:	8e 81       	ldd	r24, Y+6	; 0x06
    1f80:	9f 81       	ldd	r25, Y+7	; 0x07
    1f82:	84 0f       	add	r24, r20
    1f84:	95 1f       	adc	r25, r21
    1f86:	9f 83       	std	Y+7, r25	; 0x07
    1f88:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1f8a:	28 81       	ld	r18, Y
    1f8c:	39 81       	ldd	r19, Y+1	; 0x01
    1f8e:	82 17       	cp	r24, r18
    1f90:	93 07       	cpc	r25, r19
    1f92:	30 f6       	brcc	.-116    	; 0x1f20 <prvCopyDataToQueue+0x16>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1f94:	8a 81       	ldd	r24, Y+2	; 0x02
    1f96:	9b 81       	ldd	r25, Y+3	; 0x03
    1f98:	84 0f       	add	r24, r20
    1f9a:	95 1f       	adc	r25, r21
    1f9c:	9f 83       	std	Y+7, r25	; 0x07
    1f9e:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1fa0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1fa2:	8f 5f       	subi	r24, 0xFF	; 255
    1fa4:	8e 8f       	std	Y+30, r24	; 0x1e
}
    1fa6:	df 91       	pop	r29
    1fa8:	cf 91       	pop	r28
    1faa:	08 95       	ret
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1fac:	8a 81       	ldd	r24, Y+2	; 0x02
    1fae:	9b 81       	ldd	r25, Y+3	; 0x03
    1fb0:	0e 94 fe 18 	call	0x31fc	; 0x31fc <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    1fb4:	1b 82       	std	Y+3, r1	; 0x03
    1fb6:	1a 82       	std	Y+2, r1	; 0x02
    1fb8:	b3 cf       	rjmp	.-154    	; 0x1f20 <prvCopyDataToQueue+0x16>

00001fba <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    1fba:	cf 93       	push	r28
    1fbc:	df 93       	push	r29
    1fbe:	ec 01       	movw	r28, r24

	configASSERT( pxQueue );

	/* If the queue being reset has already been used (has not just been
	created), then only reset the queue if its event lists are empty. */
	if( xNewQueue != pdTRUE )
    1fc0:	61 30       	cpi	r22, 0x01	; 1
    1fc2:	51 f0       	breq	.+20     	; 0x1fd8 <xQueueGenericReset+0x1e>
	{
		if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1fc4:	9b 89       	ldd	r25, Y+19	; 0x13
		{
			xReturn = pdFAIL;
		}

		if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1fc6:	88 85       	ldd	r24, Y+8	; 0x08
    1fc8:	88 23       	and	r24, r24
    1fca:	21 f0       	breq	.+8      	; 0x1fd4 <xQueueGenericReset+0x1a>
		{
			xReturn = pdFAIL;
		}
	}

	if( xReturn == pdPASS )
    1fcc:	80 e0       	ldi	r24, 0x00	; 0
		vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
		vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
	}

	return xReturn;
}
    1fce:	df 91       	pop	r29
    1fd0:	cf 91       	pop	r28
    1fd2:	08 95       	ret
		{
			xReturn = pdFAIL;
		}
	}

	if( xReturn == pdPASS )
    1fd4:	99 23       	and	r25, r25
    1fd6:	d1 f7       	brne	.-12     	; 0x1fcc <xQueueGenericReset+0x12>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1fd8:	48 81       	ld	r20, Y
    1fda:	59 81       	ldd	r21, Y+1	; 0x01
    1fdc:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1fde:	68 a1       	lds	r22, 0x48
    1fe0:	86 9f       	mul	r24, r22
    1fe2:	90 01       	movw	r18, r0
    1fe4:	11 24       	eor	r1, r1
    1fe6:	24 0f       	add	r18, r20
    1fe8:	35 1f       	adc	r19, r21
    1fea:	3b 83       	std	Y+3, r19	; 0x03
    1fec:	2a 83       	std	Y+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1fee:	1e 8e       	std	Y+30, r1	; 0x1e
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1ff0:	5d 83       	std	Y+5, r21	; 0x05
    1ff2:	4c 83       	std	Y+4, r20	; 0x04
		}
	}

	if( xReturn == pdPASS )
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1ff4:	70 e0       	ldi	r23, 0x00	; 0
    1ff6:	90 e0       	ldi	r25, 0x00	; 0
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    1ff8:	01 97       	sbiw	r24, 0x01	; 1
    1ffa:	68 9f       	mul	r22, r24
    1ffc:	90 01       	movw	r18, r0
    1ffe:	69 9f       	mul	r22, r25
    2000:	30 0d       	add	r19, r0
    2002:	78 9f       	mul	r23, r24
    2004:	30 0d       	add	r19, r0
    2006:	11 24       	eor	r1, r1
    2008:	24 0f       	add	r18, r20
    200a:	35 1f       	adc	r19, r21
    200c:	3f 83       	std	Y+7, r19	; 0x07
    200e:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    2010:	8f ef       	ldi	r24, 0xFF	; 255
    2012:	89 a3       	lds	r24, 0x59
		pxQueue->xTxLock = queueUNLOCKED;
    2014:	8a a3       	lds	r24, 0x5a

		/* Ensure the event queues start with the correct state. */
		vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2016:	ce 01       	movw	r24, r28
    2018:	08 96       	adiw	r24, 0x08	; 8
    201a:	0e 94 13 1a 	call	0x3426	; 0x3426 <vListInitialise>
		vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    201e:	ce 01       	movw	r24, r28
    2020:	43 96       	adiw	r24, 0x13	; 19
    2022:	0e 94 13 1a 	call	0x3426	; 0x3426 <vListInitialise>
    2026:	81 e0       	ldi	r24, 0x01	; 1
	}

	return xReturn;
}
    2028:	df 91       	pop	r29
    202a:	cf 91       	pop	r28
    202c:	08 95       	ret

0000202e <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    202e:	0f 93       	push	r16
    2030:	1f 93       	push	r17
    2032:	cf 93       	push	r28
    2034:	df 93       	push	r29
    2036:	18 2f       	mov	r17, r24
    2038:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    203a:	88 23       	and	r24, r24
    203c:	f1 f0       	breq	.+60     	; 0x207a <xQueueGenericCreate+0x4c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    203e:	83 e2       	ldi	r24, 0x23	; 35
    2040:	90 e0       	ldi	r25, 0x00	; 0
    2042:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <pvPortMalloc>
    2046:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    2048:	00 97       	sbiw	r24, 0x00	; 0
    204a:	b9 f0       	breq	.+46     	; 0x207a <xQueueGenericCreate+0x4c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    204c:	10 9f       	mul	r17, r16
    204e:	90 01       	movw	r18, r0
    2050:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    2052:	c9 01       	movw	r24, r18
    2054:	01 96       	adiw	r24, 0x01	; 1
    2056:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <pvPortMalloc>
    205a:	99 83       	std	Y+1, r25	; 0x01
    205c:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    205e:	00 97       	sbiw	r24, 0x00	; 0
    2060:	99 f0       	breq	.+38     	; 0x2088 <xQueueGenericCreate+0x5a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    2062:	1f 8f       	std	Y+31, r17	; 0x1f
				pxNewQueue->uxItemSize = uxItemSize;
    2064:	08 a3       	lds	r16, 0x58
				xQueueGenericReset( pxNewQueue, pdTRUE );
    2066:	ce 01       	movw	r24, r28
    2068:	61 e0       	ldi	r22, 0x01	; 1
    206a:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <xQueueGenericReset>
    206e:	ce 01       	movw	r24, r28
	}

	configASSERT( xReturn );

	return xReturn;
}
    2070:	df 91       	pop	r29
    2072:	cf 91       	pop	r28
    2074:	1f 91       	pop	r17
    2076:	0f 91       	pop	r16
    2078:	08 95       	ret

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    207a:	80 e0       	ldi	r24, 0x00	; 0
    207c:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    207e:	df 91       	pop	r29
    2080:	cf 91       	pop	r28
    2082:	1f 91       	pop	r17
    2084:	0f 91       	pop	r16
    2086:	08 95       	ret
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    2088:	ce 01       	movw	r24, r28
    208a:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    208e:	80 e0       	ldi	r24, 0x00	; 0
    2090:	90 e0       	ldi	r25, 0x00	; 0
    2092:	ee cf       	rjmp	.-36     	; 0x2070 <xQueueGenericCreate+0x42>

00002094 <xQueueGetMutexHolder>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void* xQueueGetMutexHolder( xQueueHandle xSemaphore )
	{
    2094:	fc 01       	movw	r30, r24
		/* This function is called by xSemaphoreGetMutexHolder(), and should not
		be called directly.  Note:  This is is a good way of determining if the
		calling task is the mutex holder, but not a good way of determining the
		identity of the mutex holder, as the holder may change between the 
		following critical section exiting and the function returning. */
		taskENTER_CRITICAL();
    2096:	0f b6       	in	r0, 0x3f	; 63
    2098:	f8 94       	cli
    209a:	0f 92       	push	r0
		{
			if( xSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
    209c:	80 81       	ld	r24, Z
    209e:	91 81       	ldd	r25, Z+1	; 0x01
    20a0:	00 97       	sbiw	r24, 0x00	; 0
    20a2:	29 f4       	brne	.+10     	; 0x20ae <xQueueGetMutexHolder+0x1a>
			{
				pxReturn = ( void * ) xSemaphore->pxMutexHolder;
    20a4:	82 81       	ldd	r24, Z+2	; 0x02
    20a6:	93 81       	ldd	r25, Z+3	; 0x03
			else
			{
				pxReturn = NULL;
			}
		}
		taskEXIT_CRITICAL();
    20a8:	0f 90       	pop	r0
    20aa:	0f be       	out	0x3f, r0	; 63
		
		return pxReturn;
	}
    20ac:	08 95       	ret
			{
				pxReturn = ( void * ) xSemaphore->pxMutexHolder;
			}
			else
			{
				pxReturn = NULL;
    20ae:	80 e0       	ldi	r24, 0x00	; 0
    20b0:	90 e0       	ldi	r25, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    20b2:	0f 90       	pop	r0
    20b4:	0f be       	out	0x3f, r0	; 63
		
		return pxReturn;
	}
    20b6:	08 95       	ret

000020b8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    20b8:	af 92       	push	r10
    20ba:	bf 92       	push	r11
    20bc:	cf 92       	push	r12
    20be:	df 92       	push	r13
    20c0:	ef 92       	push	r14
    20c2:	ff 92       	push	r15
    20c4:	0f 93       	push	r16
    20c6:	cf 93       	push	r28
    20c8:	df 93       	push	r29
    20ca:	cd b7       	in	r28, 0x3d	; 61
    20cc:	de b7       	in	r29, 0x3e	; 62
    20ce:	29 97       	sbiw	r28, 0x09	; 9
    20d0:	0f b6       	in	r0, 0x3f	; 63
    20d2:	f8 94       	cli
    20d4:	de bf       	out	0x3e, r29	; 62
    20d6:	0f be       	out	0x3f, r0	; 63
    20d8:	cd bf       	out	0x3d, r28	; 61
    20da:	7c 01       	movw	r14, r24
    20dc:	5b 01       	movw	r10, r22
    20de:	2e 83       	std	Y+6, r18	; 0x06
    20e0:	3f 83       	std	Y+7, r19	; 0x07
    20e2:	48 87       	std	Y+8, r20	; 0x08
    20e4:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    20e6:	20 e0       	ldi	r18, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    20e8:	e8 e0       	ldi	r30, 0x08	; 8
    20ea:	ce 2e       	mov	r12, r30
    20ec:	d1 2c       	mov	r13, r1
    20ee:	c8 0e       	add	r12, r24
    20f0:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    20f2:	0f b6       	in	r0, 0x3f	; 63
    20f4:	f8 94       	cli
    20f6:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    20f8:	f7 01       	movw	r30, r14
    20fa:	96 8d       	ldd	r25, Z+30	; 0x1e
    20fc:	87 8d       	ldd	r24, Z+31	; 0x1f
    20fe:	98 17       	cp	r25, r24
    2100:	08 f4       	brcc	.+2      	; 0x2104 <xQueueGenericSend+0x4c>
    2102:	56 c0       	rjmp	.+172    	; 0x21b0 <xQueueGenericSend+0xf8>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2104:	8e 81       	ldd	r24, Y+6	; 0x06
    2106:	9f 81       	ldd	r25, Y+7	; 0x07
    2108:	a8 85       	ldd	r26, Y+8	; 0x08
    210a:	b9 85       	ldd	r27, Y+9	; 0x09
    210c:	00 97       	sbiw	r24, 0x00	; 0
    210e:	a1 05       	cpc	r26, r1
    2110:	b1 05       	cpc	r27, r1
    2112:	09 f4       	brne	.+2      	; 0x2116 <xQueueGenericSend+0x5e>
    2114:	69 c0       	rjmp	.+210    	; 0x21e8 <xQueueGenericSend+0x130>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    2116:	22 23       	and	r18, r18
    2118:	69 f1       	breq	.+90     	; 0x2174 <xQueueGenericSend+0xbc>
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    211a:	0f 90       	pop	r0
    211c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    211e:	0e 94 ec 14 	call	0x29d8	; 0x29d8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2122:	0f b6       	in	r0, 0x3f	; 63
    2124:	f8 94       	cli
    2126:	0f 92       	push	r0
    2128:	f7 01       	movw	r30, r14
    212a:	81 a1       	lds	r24, 0x41
    212c:	8f 3f       	cpi	r24, 0xFF	; 255
    212e:	39 f1       	breq	.+78     	; 0x217e <xQueueGenericSend+0xc6>
    2130:	f7 01       	movw	r30, r14
    2132:	82 a1       	lds	r24, 0x42
    2134:	8f 3f       	cpi	r24, 0xFF	; 255
    2136:	41 f1       	breq	.+80     	; 0x2188 <xQueueGenericSend+0xd0>
    2138:	0f 90       	pop	r0
    213a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    213c:	ce 01       	movw	r24, r28
    213e:	01 96       	adiw	r24, 0x01	; 1
    2140:	be 01       	movw	r22, r28
    2142:	6a 5f       	subi	r22, 0xFA	; 250
    2144:	7f 4f       	sbci	r23, 0xFF	; 255
    2146:	0e 94 10 18 	call	0x3020	; 0x3020 <xTaskCheckForTimeOut>
    214a:	88 23       	and	r24, r24
    214c:	09 f0       	breq	.+2      	; 0x2150 <xQueueGenericSend+0x98>
    214e:	50 c0       	rjmp	.+160    	; 0x21f0 <xQueueGenericSend+0x138>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2150:	0f b6       	in	r0, 0x3f	; 63
    2152:	f8 94       	cli
    2154:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2156:	f7 01       	movw	r30, r14
    2158:	96 8d       	ldd	r25, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    215a:	0f 90       	pop	r0
    215c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    215e:	f7 01       	movw	r30, r14
    2160:	87 8d       	ldd	r24, Z+31	; 0x1f
    2162:	98 17       	cp	r25, r24
    2164:	99 f0       	breq	.+38     	; 0x218c <xQueueGenericSend+0xd4>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2166:	c7 01       	movw	r24, r14
    2168:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    216c:	0e 94 19 16 	call	0x2c32	; 0x2c32 <xTaskResumeAll>
			( void ) xTaskResumeAll();

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2170:	21 e0       	ldi	r18, 0x01	; 1
    2172:	bf cf       	rjmp	.-130    	; 0x20f2 <xQueueGenericSend+0x3a>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2174:	ce 01       	movw	r24, r28
    2176:	01 96       	adiw	r24, 0x01	; 1
    2178:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <vTaskSetTimeOutState>
    217c:	ce cf       	rjmp	.-100    	; 0x211a <xQueueGenericSend+0x62>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    217e:	11 a2       	lds	r17, 0x91
    2180:	f7 01       	movw	r30, r14
    2182:	82 a1       	lds	r24, 0x42
    2184:	8f 3f       	cpi	r24, 0xFF	; 255
    2186:	c1 f6       	brne	.-80     	; 0x2138 <xQueueGenericSend+0x80>
    2188:	12 a2       	lds	r17, 0x92
    218a:	d6 cf       	rjmp	.-84     	; 0x2138 <xQueueGenericSend+0x80>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    218c:	4e 81       	ldd	r20, Y+6	; 0x06
    218e:	5f 81       	ldd	r21, Y+7	; 0x07
    2190:	68 85       	ldd	r22, Y+8	; 0x08
    2192:	79 85       	ldd	r23, Y+9	; 0x09
    2194:	c6 01       	movw	r24, r12
    2196:	0e 94 87 17 	call	0x2f0e	; 0x2f0e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    219a:	c7 01       	movw	r24, r14
    219c:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    21a0:	0e 94 19 16 	call	0x2c32	; 0x2c32 <xTaskResumeAll>
    21a4:	88 23       	and	r24, r24
    21a6:	21 f7       	brne	.-56     	; 0x2170 <xQueueGenericSend+0xb8>
				{
					portYIELD_WITHIN_API();
    21a8:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <vPortYield>
			( void ) xTaskResumeAll();

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    21ac:	21 e0       	ldi	r18, 0x01	; 1
    21ae:	a1 cf       	rjmp	.-190    	; 0x20f2 <xQueueGenericSend+0x3a>
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    21b0:	c7 01       	movw	r24, r14
    21b2:	b5 01       	movw	r22, r10
    21b4:	40 2f       	mov	r20, r16
    21b6:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    21ba:	f7 01       	movw	r30, r14
    21bc:	83 89       	ldd	r24, Z+19	; 0x13
    21be:	88 23       	and	r24, r24
    21c0:	f1 f4       	brne	.+60     	; 0x21fe <xQueueGenericSend+0x146>
						takes care of that. */
						portYIELD_WITHIN_API();
					}
				}

				taskEXIT_CRITICAL();
    21c2:	0f 90       	pop	r0
    21c4:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    21c6:	81 e0       	ldi	r24, 0x01	; 1
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    21c8:	29 96       	adiw	r28, 0x09	; 9
    21ca:	0f b6       	in	r0, 0x3f	; 63
    21cc:	f8 94       	cli
    21ce:	de bf       	out	0x3e, r29	; 62
    21d0:	0f be       	out	0x3f, r0	; 63
    21d2:	cd bf       	out	0x3d, r28	; 61
    21d4:	df 91       	pop	r29
    21d6:	cf 91       	pop	r28
    21d8:	0f 91       	pop	r16
    21da:	ff 90       	pop	r15
    21dc:	ef 90       	pop	r14
    21de:	df 90       	pop	r13
    21e0:	cf 90       	pop	r12
    21e2:	bf 90       	pop	r11
    21e4:	af 90       	pop	r10
    21e6:	08 95       	ret
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    21e8:	0f 90       	pop	r0
    21ea:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    21ec:	80 e0       	ldi	r24, 0x00	; 0
    21ee:	ec cf       	rjmp	.-40     	; 0x21c8 <xQueueGenericSend+0x110>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    21f0:	c7 01       	movw	r24, r14
    21f2:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    21f6:	0e 94 19 16 	call	0x2c32	; 0x2c32 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    21fa:	80 e0       	ldi	r24, 0x00	; 0
    21fc:	e5 cf       	rjmp	.-54     	; 0x21c8 <xQueueGenericSend+0x110>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    21fe:	c7 01       	movw	r24, r14
    2200:	43 96       	adiw	r24, 0x13	; 19
    2202:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <xTaskRemoveFromEventList>
    2206:	81 30       	cpi	r24, 0x01	; 1
    2208:	e1 f6       	brne	.-72     	; 0x21c2 <xQueueGenericSend+0x10a>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    220a:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <vPortYield>
    220e:	d9 cf       	rjmp	.-78     	; 0x21c2 <xQueueGenericSend+0x10a>

00002210 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    2210:	0f 93       	push	r16
    2212:	cf 93       	push	r28
    2214:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    2216:	83 e2       	ldi	r24, 0x23	; 35
    2218:	90 e0       	ldi	r25, 0x00	; 0
    221a:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <pvPortMalloc>
    221e:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    2220:	00 97       	sbiw	r24, 0x00	; 0
    2222:	01 f1       	breq	.+64     	; 0x2264 <xQueueCreateMutex+0x54>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    2224:	1b 82       	std	Y+3, r1	; 0x03
    2226:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    2228:	19 82       	std	Y+1, r1	; 0x01
    222a:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    222c:	1d 82       	std	Y+5, r1	; 0x05
    222e:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    2230:	1f 82       	std	Y+7, r1	; 0x07
    2232:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    2234:	1e 8e       	std	Y+30, r1	; 0x1e
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    2236:	81 e0       	ldi	r24, 0x01	; 1
    2238:	8f 8f       	std	Y+31, r24	; 0x1f
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    223a:	18 a2       	lds	r17, 0x98
			pxNewQueue->xRxLock = queueUNLOCKED;
    223c:	8f ef       	ldi	r24, 0xFF	; 255
    223e:	89 a3       	lds	r24, 0x59
			pxNewQueue->xTxLock = queueUNLOCKED;
    2240:	8a a3       	lds	r24, 0x5a
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    2242:	ce 01       	movw	r24, r28
    2244:	08 96       	adiw	r24, 0x08	; 8
    2246:	0e 94 13 1a 	call	0x3426	; 0x3426 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    224a:	ce 01       	movw	r24, r28
    224c:	43 96       	adiw	r24, 0x13	; 19
    224e:	0e 94 13 1a 	call	0x3426	; 0x3426 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    2252:	ce 01       	movw	r24, r28
    2254:	60 e0       	ldi	r22, 0x00	; 0
    2256:	70 e0       	ldi	r23, 0x00	; 0
    2258:	20 e0       	ldi	r18, 0x00	; 0
    225a:	30 e0       	ldi	r19, 0x00	; 0
    225c:	a9 01       	movw	r20, r18
    225e:	00 e0       	ldi	r16, 0x00	; 0
    2260:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    2264:	ce 01       	movw	r24, r28
    2266:	df 91       	pop	r29
    2268:	cf 91       	pop	r28
    226a:	0f 91       	pop	r16
    226c:	08 95       	ret

0000226e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    226e:	0f 93       	push	r16
    2270:	1f 93       	push	r17
    2272:	cf 93       	push	r28
    2274:	df 93       	push	r29
    2276:	ec 01       	movw	r28, r24
    2278:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    227a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    227c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    227e:	98 17       	cp	r25, r24
    2280:	30 f0       	brcs	.+12     	; 0x228e <xQueueGenericSendFromISR+0x20>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2282:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2284:	df 91       	pop	r29
    2286:	cf 91       	pop	r28
    2288:	1f 91       	pop	r17
    228a:	0f 91       	pop	r16
    228c:	08 95       	ret
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    228e:	ce 01       	movw	r24, r28
    2290:	42 2f       	mov	r20, r18
    2292:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2296:	8a a1       	lds	r24, 0x4a
    2298:	8f 3f       	cpi	r24, 0xFF	; 255
    229a:	41 f0       	breq	.+16     	; 0x22ac <xQueueGenericSendFromISR+0x3e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    229c:	8f 5f       	subi	r24, 0xFF	; 255
    229e:	8a a3       	lds	r24, 0x5a
			}

			xReturn = pdPASS;
    22a0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    22a2:	df 91       	pop	r29
    22a4:	cf 91       	pop	r28
    22a6:	1f 91       	pop	r17
    22a8:	0f 91       	pop	r16
    22aa:	08 95       	ret

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22ac:	8b 89       	ldd	r24, Y+19	; 0x13
    22ae:	88 23       	and	r24, r24
    22b0:	11 f4       	brne	.+4      	; 0x22b6 <xQueueGenericSendFromISR+0x48>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    22b2:	81 e0       	ldi	r24, 0x01	; 1
    22b4:	e7 cf       	rjmp	.-50     	; 0x2284 <xQueueGenericSendFromISR+0x16>
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    22b6:	ce 01       	movw	r24, r28
    22b8:	43 96       	adiw	r24, 0x13	; 19
    22ba:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <xTaskRemoveFromEventList>
    22be:	88 23       	and	r24, r24
    22c0:	c1 f3       	breq	.-16     	; 0x22b2 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    22c2:	81 e0       	ldi	r24, 0x01	; 1
    22c4:	f8 01       	movw	r30, r16
    22c6:	80 83       	st	Z, r24
    22c8:	dd cf       	rjmp	.-70     	; 0x2284 <xQueueGenericSendFromISR+0x16>

000022ca <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    22ca:	af 92       	push	r10
    22cc:	bf 92       	push	r11
    22ce:	df 92       	push	r13
    22d0:	ef 92       	push	r14
    22d2:	ff 92       	push	r15
    22d4:	0f 93       	push	r16
    22d6:	1f 93       	push	r17
    22d8:	cf 93       	push	r28
    22da:	df 93       	push	r29
    22dc:	cd b7       	in	r28, 0x3d	; 61
    22de:	de b7       	in	r29, 0x3e	; 62
    22e0:	29 97       	sbiw	r28, 0x09	; 9
    22e2:	0f b6       	in	r0, 0x3f	; 63
    22e4:	f8 94       	cli
    22e6:	de bf       	out	0x3e, r29	; 62
    22e8:	0f be       	out	0x3f, r0	; 63
    22ea:	cd bf       	out	0x3d, r28	; 61
    22ec:	7c 01       	movw	r14, r24
    22ee:	5b 01       	movw	r10, r22
    22f0:	2e 83       	std	Y+6, r18	; 0x06
    22f2:	3f 83       	std	Y+7, r19	; 0x07
    22f4:	48 87       	std	Y+8, r20	; 0x08
    22f6:	59 87       	std	Y+9, r21	; 0x09
    22f8:	d0 2e       	mov	r13, r16
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    22fa:	20 e0       	ldi	r18, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    22fc:	8c 01       	movw	r16, r24
    22fe:	0d 5e       	subi	r16, 0xED	; 237
    2300:	1f 4f       	sbci	r17, 0xFF	; 255
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2302:	0f b6       	in	r0, 0x3f	; 63
    2304:	f8 94       	cli
    2306:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2308:	f7 01       	movw	r30, r14
    230a:	86 8d       	ldd	r24, Z+30	; 0x1e
    230c:	88 23       	and	r24, r24
    230e:	09 f0       	breq	.+2      	; 0x2312 <xQueueGenericReceive+0x48>
    2310:	6a c0       	rjmp	.+212    	; 0x23e6 <xQueueGenericReceive+0x11c>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2312:	8e 81       	ldd	r24, Y+6	; 0x06
    2314:	9f 81       	ldd	r25, Y+7	; 0x07
    2316:	a8 85       	ldd	r26, Y+8	; 0x08
    2318:	b9 85       	ldd	r27, Y+9	; 0x09
    231a:	00 97       	sbiw	r24, 0x00	; 0
    231c:	a1 05       	cpc	r26, r1
    231e:	b1 05       	cpc	r27, r1
    2320:	09 f4       	brne	.+2      	; 0x2324 <xQueueGenericReceive+0x5a>
    2322:	7e c0       	rjmp	.+252    	; 0x2420 <xQueueGenericReceive+0x156>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    2324:	22 23       	and	r18, r18
    2326:	09 f4       	brne	.+2      	; 0x232a <xQueueGenericReceive+0x60>
    2328:	3f c0       	rjmp	.+126    	; 0x23a8 <xQueueGenericReceive+0xde>
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    232a:	0f 90       	pop	r0
    232c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    232e:	0e 94 ec 14 	call	0x29d8	; 0x29d8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2332:	0f b6       	in	r0, 0x3f	; 63
    2334:	f8 94       	cli
    2336:	0f 92       	push	r0
    2338:	f7 01       	movw	r30, r14
    233a:	81 a1       	lds	r24, 0x41
    233c:	8f 3f       	cpi	r24, 0xFF	; 255
    233e:	09 f4       	brne	.+2      	; 0x2342 <xQueueGenericReceive+0x78>
    2340:	3f c0       	rjmp	.+126    	; 0x23c0 <xQueueGenericReceive+0xf6>
    2342:	f7 01       	movw	r30, r14
    2344:	82 a1       	lds	r24, 0x42
    2346:	8f 3f       	cpi	r24, 0xFF	; 255
    2348:	09 f4       	brne	.+2      	; 0x234c <xQueueGenericReceive+0x82>
    234a:	40 c0       	rjmp	.+128    	; 0x23cc <xQueueGenericReceive+0x102>
    234c:	0f 90       	pop	r0
    234e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2350:	ce 01       	movw	r24, r28
    2352:	01 96       	adiw	r24, 0x01	; 1
    2354:	be 01       	movw	r22, r28
    2356:	6a 5f       	subi	r22, 0xFA	; 250
    2358:	7f 4f       	sbci	r23, 0xFF	; 255
    235a:	0e 94 10 18 	call	0x3020	; 0x3020 <xTaskCheckForTimeOut>
    235e:	88 23       	and	r24, r24
    2360:	09 f0       	breq	.+2      	; 0x2364 <xQueueGenericReceive+0x9a>
    2362:	71 c0       	rjmp	.+226    	; 0x2446 <xQueueGenericReceive+0x17c>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2364:	0f b6       	in	r0, 0x3f	; 63
    2366:	f8 94       	cli
    2368:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    236a:	f7 01       	movw	r30, r14
    236c:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    236e:	0f 90       	pop	r0
    2370:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2372:	88 23       	and	r24, r24
    2374:	f1 f4       	brne	.+60     	; 0x23b2 <xQueueGenericReceive+0xe8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2376:	f7 01       	movw	r30, r14
    2378:	80 81       	ld	r24, Z
    237a:	91 81       	ldd	r25, Z+1	; 0x01
    237c:	00 97       	sbiw	r24, 0x00	; 0
    237e:	41 f1       	breq	.+80     	; 0x23d0 <xQueueGenericReceive+0x106>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2380:	4e 81       	ldd	r20, Y+6	; 0x06
    2382:	5f 81       	ldd	r21, Y+7	; 0x07
    2384:	68 85       	ldd	r22, Y+8	; 0x08
    2386:	79 85       	ldd	r23, Y+9	; 0x09
    2388:	c8 01       	movw	r24, r16
    238a:	0e 94 87 17 	call	0x2f0e	; 0x2f0e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    238e:	c7 01       	movw	r24, r14
    2390:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2394:	0e 94 19 16 	call	0x2c32	; 0x2c32 <xTaskResumeAll>
    2398:	88 23       	and	r24, r24
    239a:	11 f0       	breq	.+4      	; 0x23a0 <xQueueGenericReceive+0xd6>
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    239c:	21 e0       	ldi	r18, 0x01	; 1
    239e:	b1 cf       	rjmp	.-158    	; 0x2302 <xQueueGenericReceive+0x38>

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
				{
					portYIELD_WITHIN_API();
    23a0:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <vPortYield>
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    23a4:	21 e0       	ldi	r18, 0x01	; 1
    23a6:	ad cf       	rjmp	.-166    	; 0x2302 <xQueueGenericReceive+0x38>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    23a8:	ce 01       	movw	r24, r28
    23aa:	01 96       	adiw	r24, 0x01	; 1
    23ac:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <vTaskSetTimeOutState>
    23b0:	bc cf       	rjmp	.-136    	; 0x232a <xQueueGenericReceive+0x60>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    23b2:	c7 01       	movw	r24, r14
    23b4:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    23b8:	0e 94 19 16 	call	0x2c32	; 0x2c32 <xTaskResumeAll>
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    23bc:	21 e0       	ldi	r18, 0x01	; 1
    23be:	a1 cf       	rjmp	.-190    	; 0x2302 <xQueueGenericReceive+0x38>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
    23c0:	11 a2       	lds	r17, 0x91
    23c2:	f7 01       	movw	r30, r14
    23c4:	82 a1       	lds	r24, 0x42
    23c6:	8f 3f       	cpi	r24, 0xFF	; 255
    23c8:	09 f0       	breq	.+2      	; 0x23cc <xQueueGenericReceive+0x102>
    23ca:	c0 cf       	rjmp	.-128    	; 0x234c <xQueueGenericReceive+0x82>
    23cc:	12 a2       	lds	r17, 0x92
    23ce:	be cf       	rjmp	.-132    	; 0x234c <xQueueGenericReceive+0x82>

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
					{
						portENTER_CRITICAL();
    23d0:	0f b6       	in	r0, 0x3f	; 63
    23d2:	f8 94       	cli
    23d4:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    23d6:	f7 01       	movw	r30, r14
    23d8:	82 81       	ldd	r24, Z+2	; 0x02
    23da:	93 81       	ldd	r25, Z+3	; 0x03
    23dc:	0e 94 98 18 	call	0x3130	; 0x3130 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    23e0:	0f 90       	pop	r0
    23e2:	0f be       	out	0x3f, r0	; 63
    23e4:	cd cf       	rjmp	.-102    	; 0x2380 <xQueueGenericReceive+0xb6>
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    23e6:	06 81       	ldd	r16, Z+6	; 0x06
    23e8:	17 81       	ldd	r17, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    23ea:	c7 01       	movw	r24, r14
    23ec:	b5 01       	movw	r22, r10
    23ee:	0e 94 12 0f 	call	0x1e24	; 0x1e24 <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    23f2:	f7 01       	movw	r30, r14
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    23f4:	dd 20       	and	r13, r13
    23f6:	71 f5       	brne	.+92     	; 0x2454 <xQueueGenericReceive+0x18a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    23f8:	86 8d       	ldd	r24, Z+30	; 0x1e
    23fa:	81 50       	subi	r24, 0x01	; 1
    23fc:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    23fe:	80 81       	ld	r24, Z
    2400:	91 81       	ldd	r25, Z+1	; 0x01
    2402:	00 97       	sbiw	r24, 0x00	; 0
    2404:	b9 f1       	breq	.+110    	; 0x2474 <xQueueGenericReceive+0x1aa>
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2406:	f7 01       	movw	r30, r14
    2408:	80 85       	ldd	r24, Z+8	; 0x08
    240a:	88 23       	and	r24, r24
    240c:	41 f1       	breq	.+80     	; 0x245e <xQueueGenericReceive+0x194>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    240e:	c7 01       	movw	r24, r14
    2410:	08 96       	adiw	r24, 0x08	; 8
    2412:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <xTaskRemoveFromEventList>
    2416:	81 30       	cpi	r24, 0x01	; 1
    2418:	11 f5       	brne	.+68     	; 0x245e <xQueueGenericReceive+0x194>
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    241a:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <vPortYield>
    241e:	1f c0       	rjmp	.+62     	; 0x245e <xQueueGenericReceive+0x194>
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2420:	0f 90       	pop	r0
    2422:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2424:	80 e0       	ldi	r24, 0x00	; 0
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    2426:	29 96       	adiw	r28, 0x09	; 9
    2428:	0f b6       	in	r0, 0x3f	; 63
    242a:	f8 94       	cli
    242c:	de bf       	out	0x3e, r29	; 62
    242e:	0f be       	out	0x3f, r0	; 63
    2430:	cd bf       	out	0x3d, r28	; 61
    2432:	df 91       	pop	r29
    2434:	cf 91       	pop	r28
    2436:	1f 91       	pop	r17
    2438:	0f 91       	pop	r16
    243a:	ff 90       	pop	r15
    243c:	ef 90       	pop	r14
    243e:	df 90       	pop	r13
    2440:	bf 90       	pop	r11
    2442:	af 90       	pop	r10
    2444:	08 95       	ret
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2446:	c7 01       	movw	r24, r14
    2448:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    244c:	0e 94 19 16 	call	0x2c32	; 0x2c32 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2450:	80 e0       	ldi	r24, 0x00	; 0
    2452:	e9 cf       	rjmp	.-46     	; 0x2426 <xQueueGenericReceive+0x15c>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    2454:	17 83       	std	Z+7, r17	; 0x07
    2456:	06 83       	std	Z+6, r16	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2458:	83 89       	ldd	r24, Z+19	; 0x13
    245a:	88 23       	and	r24, r24
    245c:	21 f4       	brne	.+8      	; 0x2466 <xQueueGenericReceive+0x19c>
						}
					}

				}

				taskEXIT_CRITICAL();
    245e:	0f 90       	pop	r0
    2460:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2462:	81 e0       	ldi	r24, 0x01	; 1
    2464:	e0 cf       	rjmp	.-64     	; 0x2426 <xQueueGenericReceive+0x15c>
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2466:	c7 01       	movw	r24, r14
    2468:	43 96       	adiw	r24, 0x13	; 19
    246a:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <xTaskRemoveFromEventList>
    246e:	88 23       	and	r24, r24
    2470:	b1 f3       	breq	.-20     	; 0x245e <xQueueGenericReceive+0x194>
    2472:	d3 cf       	rjmp	.-90     	; 0x241a <xQueueGenericReceive+0x150>
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    2474:	0e 94 93 18 	call	0x3126	; 0x3126 <xTaskGetCurrentTaskHandle>
    2478:	f7 01       	movw	r30, r14
    247a:	93 83       	std	Z+3, r25	; 0x03
    247c:	82 83       	std	Z+2, r24	; 0x02
    247e:	c3 cf       	rjmp	.-122    	; 0x2406 <xQueueGenericReceive+0x13c>

00002480 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    2480:	0f 93       	push	r16
    2482:	1f 93       	push	r17
    2484:	cf 93       	push	r28
    2486:	df 93       	push	r29
    2488:	ec 01       	movw	r28, r24
    248a:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    248c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    248e:	88 23       	and	r24, r24
    2490:	31 f4       	brne	.+12     	; 0x249e <xQueueReceiveFromISR+0x1e>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    2492:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2494:	df 91       	pop	r29
    2496:	cf 91       	pop	r28
    2498:	1f 91       	pop	r17
    249a:	0f 91       	pop	r16
    249c:	08 95       	ret
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    249e:	ce 01       	movw	r24, r28
    24a0:	0e 94 12 0f 	call	0x1e24	; 0x1e24 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    24a4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    24a6:	81 50       	subi	r24, 0x01	; 1
    24a8:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    24aa:	89 a1       	lds	r24, 0x49
    24ac:	8f 3f       	cpi	r24, 0xFF	; 255
    24ae:	41 f0       	breq	.+16     	; 0x24c0 <xQueueReceiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    24b0:	8f 5f       	subi	r24, 0xFF	; 255
    24b2:	89 a3       	lds	r24, 0x59
			}

			xReturn = pdPASS;
    24b4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    24b6:	df 91       	pop	r29
    24b8:	cf 91       	pop	r28
    24ba:	1f 91       	pop	r17
    24bc:	0f 91       	pop	r16
    24be:	08 95       	ret
			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24c0:	88 85       	ldd	r24, Y+8	; 0x08
    24c2:	88 23       	and	r24, r24
    24c4:	11 f4       	brne	.+4      	; 0x24ca <xQueueReceiveFromISR+0x4a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    24c6:	81 e0       	ldi	r24, 0x01	; 1
    24c8:	e5 cf       	rjmp	.-54     	; 0x2494 <xQueueReceiveFromISR+0x14>
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    24ca:	ce 01       	movw	r24, r28
    24cc:	08 96       	adiw	r24, 0x08	; 8
    24ce:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <xTaskRemoveFromEventList>
    24d2:	88 23       	and	r24, r24
    24d4:	c1 f3       	breq	.-16     	; 0x24c6 <xQueueReceiveFromISR+0x46>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    24d6:	81 e0       	ldi	r24, 0x01	; 1
    24d8:	f8 01       	movw	r30, r16
    24da:	80 83       	st	Z, r24
    24dc:	db cf       	rjmp	.-74     	; 0x2494 <xQueueReceiveFromISR+0x14>

000024de <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    24de:	0f b6       	in	r0, 0x3f	; 63
    24e0:	f8 94       	cli
    24e2:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    24e4:	fc 01       	movw	r30, r24
    24e6:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    24e8:	0f 90       	pop	r0
    24ea:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    24ec:	08 95       	ret

000024ee <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    24ee:	fc 01       	movw	r30, r24
    24f0:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    24f2:	08 95       	ret

000024f4 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    24f4:	cf 93       	push	r28
    24f6:	df 93       	push	r29
    24f8:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    24fa:	88 81       	ld	r24, Y
    24fc:	99 81       	ldd	r25, Y+1	; 0x01
    24fe:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <vPortFree>
	vPortFree( pxQueue );
    2502:	ce 01       	movw	r24, r28
    2504:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <vPortFree>
}
    2508:	df 91       	pop	r29
    250a:	cf 91       	pop	r28
    250c:	08 95       	ret

0000250e <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    250e:	fc 01       	movw	r30, r24
    2510:	96 8d       	ldd	r25, Z+30	; 0x1e
    2512:	81 e0       	ldi	r24, 0x01	; 1
    2514:	91 11       	cpse	r25, r1
    2516:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    2518:	08 95       	ret

0000251a <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    251a:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    251c:	26 8d       	ldd	r18, Z+30	; 0x1e
    251e:	81 e0       	ldi	r24, 0x01	; 1
    2520:	97 8d       	ldd	r25, Z+31	; 0x1f
    2522:	29 13       	cpse	r18, r25
    2524:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    2526:	08 95       	ret

00002528 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    2528:	80 91 03 1a 	lds	r24, 0x1A03
    252c:	82 30       	cpi	r24, 0x02	; 2
    252e:	e0 f3       	brcs	.-8      	; 0x2528 <prvIdleTask>
			{
				taskYIELD();
    2530:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <vPortYield>
    2534:	f9 cf       	rjmp	.-14     	; 0x2528 <prvIdleTask>

00002536 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    2536:	cf 92       	push	r12
    2538:	df 92       	push	r13
    253a:	ef 92       	push	r14
    253c:	ff 92       	push	r15
    253e:	6b 01       	movw	r12, r22
    2540:	7c 01       	movw	r14, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2542:	e0 91 f2 19 	lds	r30, 0x19F2
    2546:	f0 91 f3 19 	lds	r31, 0x19F3
    254a:	62 83       	std	Z+2, r22	; 0x02
    254c:	73 83       	std	Z+3, r23	; 0x03
    254e:	84 83       	std	Z+4, r24	; 0x04
    2550:	95 83       	std	Z+5, r25	; 0x05

	if( xTimeToWake < xTickCount )
    2552:	80 91 fa 19 	lds	r24, 0x19FA
    2556:	90 91 fb 19 	lds	r25, 0x19FB
    255a:	a0 91 fc 19 	lds	r26, 0x19FC
    255e:	b0 91 fd 19 	lds	r27, 0x19FD
    2562:	c8 16       	cp	r12, r24
    2564:	d9 06       	cpc	r13, r25
    2566:	ea 06       	cpc	r14, r26
    2568:	fb 06       	cpc	r15, r27
    256a:	30 f1       	brcs	.+76     	; 0x25b8 <prvAddCurrentTaskToDelayedList+0x82>
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    256c:	80 91 01 1a 	lds	r24, 0x1A01
    2570:	90 91 02 1a 	lds	r25, 0x1A02
    2574:	60 91 f2 19 	lds	r22, 0x19F2
    2578:	70 91 f3 19 	lds	r23, 0x19F3
    257c:	6e 5f       	subi	r22, 0xFE	; 254
    257e:	7f 4f       	sbci	r23, 0xFF	; 255
    2580:	0e 94 4f 1a 	call	0x349e	; 0x349e <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    2584:	80 91 95 02 	lds	r24, 0x0295
    2588:	90 91 96 02 	lds	r25, 0x0296
    258c:	a0 91 97 02 	lds	r26, 0x0297
    2590:	b0 91 98 02 	lds	r27, 0x0298
    2594:	c8 16       	cp	r12, r24
    2596:	d9 06       	cpc	r13, r25
    2598:	ea 06       	cpc	r14, r26
    259a:	fb 06       	cpc	r15, r27
    259c:	40 f4       	brcc	.+16     	; 0x25ae <prvAddCurrentTaskToDelayedList+0x78>
		{
			xNextTaskUnblockTime = xTimeToWake;
    259e:	c0 92 95 02 	sts	0x0295, r12
    25a2:	d0 92 96 02 	sts	0x0296, r13
    25a6:	e0 92 97 02 	sts	0x0297, r14
    25aa:	f0 92 98 02 	sts	0x0298, r15
		}
	}
}
    25ae:	ff 90       	pop	r15
    25b0:	ef 90       	pop	r14
    25b2:	df 90       	pop	r13
    25b4:	cf 90       	pop	r12
    25b6:	08 95       	ret
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25b8:	80 91 ff 19 	lds	r24, 0x19FF
    25bc:	90 91 00 1a 	lds	r25, 0x1A00
    25c0:	60 91 f2 19 	lds	r22, 0x19F2
    25c4:	70 91 f3 19 	lds	r23, 0x19F3
    25c8:	6e 5f       	subi	r22, 0xFE	; 254
    25ca:	7f 4f       	sbci	r23, 0xFF	; 255
    25cc:	0e 94 4f 1a 	call	0x349e	; 0x349e <vListInsert>
		if( xTimeToWake < xNextTaskUnblockTime )
		{
			xNextTaskUnblockTime = xTimeToWake;
		}
	}
}
    25d0:	ff 90       	pop	r15
    25d2:	ef 90       	pop	r14
    25d4:	df 90       	pop	r13
    25d6:	cf 90       	pop	r12
    25d8:	08 95       	ret

000025da <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    25da:	4f 92       	push	r4
    25dc:	5f 92       	push	r5
    25de:	6f 92       	push	r6
    25e0:	7f 92       	push	r7
    25e2:	8f 92       	push	r8
    25e4:	9f 92       	push	r9
    25e6:	af 92       	push	r10
    25e8:	bf 92       	push	r11
    25ea:	cf 92       	push	r12
    25ec:	df 92       	push	r13
    25ee:	ef 92       	push	r14
    25f0:	ff 92       	push	r15
    25f2:	0f 93       	push	r16
    25f4:	1f 93       	push	r17
    25f6:	cf 93       	push	r28
    25f8:	df 93       	push	r29
    25fa:	2c 01       	movw	r4, r24
    25fc:	4b 01       	movw	r8, r22
    25fe:	5a 01       	movw	r10, r20
    2600:	39 01       	movw	r6, r18
    2602:	d0 2f       	mov	r29, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2604:	88 e2       	ldi	r24, 0x28	; 40
    2606:	90 e0       	ldi	r25, 0x00	; 0
    2608:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <pvPortMalloc>
    260c:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    260e:	00 97       	sbiw	r24, 0x00	; 0
    2610:	09 f4       	brne	.+2      	; 0x2614 <xTaskGenericCreate+0x3a>
    2612:	ba c0       	rjmp	.+372    	; 0x2788 <xTaskGenericCreate+0x1ae>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2614:	c1 14       	cp	r12, r1
    2616:	d1 04       	cpc	r13, r1
    2618:	09 f4       	brne	.+2      	; 0x261c <xTaskGenericCreate+0x42>
    261a:	f7 c0       	rjmp	.+494    	; 0x280a <xTaskGenericCreate+0x230>
    261c:	fc 01       	movw	r30, r24
    261e:	d4 8e       	std	Z+28, r13	; 0x1c
    2620:	c3 8e       	std	Z+27, r12	; 0x1b
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    2622:	c6 01       	movw	r24, r12
    2624:	61 e1       	ldi	r22, 0x11	; 17
    2626:	70 e0       	ldi	r23, 0x00	; 0
    2628:	a5 01       	movw	r20, r10
    262a:	0e 94 a7 1b 	call	0x374e	; 0x374e <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    262e:	c5 01       	movw	r24, r10
    2630:	01 97       	sbiw	r24, 0x01	; 1
    2632:	f8 01       	movw	r30, r16
    2634:	c3 8c       	ldd	r12, Z+27	; 0x1b
    2636:	d4 8c       	ldd	r13, Z+28	; 0x1c
    2638:	c8 0e       	add	r12, r24
    263a:	d9 1e       	adc	r13, r25
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    263c:	c8 01       	movw	r24, r16
    263e:	4d 96       	adiw	r24, 0x1d	; 29
    2640:	b4 01       	movw	r22, r8
    2642:	4a e0       	ldi	r20, 0x0A	; 10
    2644:	50 e0       	ldi	r21, 0x00	; 0
    2646:	0e 94 ae 1b 	call	0x375c	; 0x375c <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    264a:	f8 01       	movw	r30, r16
    264c:	16 a2       	lds	r17, 0x96
    264e:	cd 2f       	mov	r28, r29
    2650:	d4 30       	cpi	r29, 0x04	; 4
    2652:	08 f0       	brcs	.+2      	; 0x2656 <xTaskGenericCreate+0x7c>
    2654:	93 c0       	rjmp	.+294    	; 0x277c <xTaskGenericCreate+0x1a2>
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    2656:	f8 01       	movw	r30, r16
    2658:	c2 8f       	std	Z+26, r28	; 0x1a
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    265a:	c7 a3       	lds	r28, 0x57
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    265c:	b2 e0       	ldi	r27, 0x02	; 2
    265e:	ab 2e       	mov	r10, r27
    2660:	b1 2c       	mov	r11, r1
    2662:	a0 0e       	add	r10, r16
    2664:	b1 1e       	adc	r11, r17
    2666:	c5 01       	movw	r24, r10
    2668:	0e 94 24 1a 	call	0x3448	; 0x3448 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    266c:	c8 01       	movw	r24, r16
    266e:	0e 96       	adiw	r24, 0x0e	; 14
    2670:	0e 94 24 1a 	call	0x3448	; 0x3448 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2674:	f8 01       	movw	r30, r16
    2676:	13 87       	std	Z+11, r17	; 0x0b
    2678:	02 87       	std	Z+10, r16	; 0x0a

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    267a:	84 e0       	ldi	r24, 0x04	; 4
    267c:	90 e0       	ldi	r25, 0x00	; 0
    267e:	a0 e0       	ldi	r26, 0x00	; 0
    2680:	b0 e0       	ldi	r27, 0x00	; 0
    2682:	8c 1b       	sub	r24, r28
    2684:	91 09       	sbc	r25, r1
    2686:	a1 09       	sbc	r26, r1
    2688:	b1 09       	sbc	r27, r1
    268a:	86 87       	std	Z+14, r24	; 0x0e
    268c:	97 87       	std	Z+15, r25	; 0x0f
    268e:	a0 8b       	std	Z+16, r26	; 0x10
    2690:	b1 8b       	std	Z+17, r27	; 0x11
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2692:	17 8b       	std	Z+23, r17	; 0x17
    2694:	06 8b       	std	Z+22, r16	; 0x16
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2696:	c6 01       	movw	r24, r12
    2698:	b2 01       	movw	r22, r4
    269a:	a3 01       	movw	r20, r6
    269c:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <pxPortInitialiseStack>
    26a0:	f8 01       	movw	r30, r16
    26a2:	91 83       	std	Z+1, r25	; 0x01
    26a4:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    26a6:	e1 14       	cp	r14, r1
    26a8:	f1 04       	cpc	r15, r1
    26aa:	19 f0       	breq	.+6      	; 0x26b2 <xTaskGenericCreate+0xd8>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    26ac:	f7 01       	movw	r30, r14
    26ae:	11 83       	std	Z+1, r17	; 0x01
    26b0:	00 83       	st	Z, r16
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    26b2:	0f b6       	in	r0, 0x3f	; 63
    26b4:	f8 94       	cli
    26b6:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    26b8:	80 91 fe 19 	lds	r24, 0x19FE
    26bc:	8f 5f       	subi	r24, 0xFF	; 255
    26be:	80 93 fe 19 	sts	0x19FE, r24
			if( pxCurrentTCB == NULL )
    26c2:	80 91 f2 19 	lds	r24, 0x19F2
    26c6:	90 91 f3 19 	lds	r25, 0x19F3
    26ca:	00 97       	sbiw	r24, 0x00	; 0
    26cc:	09 f4       	brne	.+2      	; 0x26d0 <xTaskGenericCreate+0xf6>
    26ce:	5e c0       	rjmp	.+188    	; 0x278c <xTaskGenericCreate+0x1b2>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    26d0:	80 91 f8 19 	lds	r24, 0x19F8
    26d4:	88 23       	and	r24, r24
    26d6:	59 f4       	brne	.+22     	; 0x26ee <xTaskGenericCreate+0x114>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    26d8:	e0 91 f2 19 	lds	r30, 0x19F2
    26dc:	f0 91 f3 19 	lds	r31, 0x19F3
    26e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    26e2:	d8 17       	cp	r29, r24
    26e4:	20 f0       	brcs	.+8      	; 0x26ee <xTaskGenericCreate+0x114>
					{
						pxCurrentTCB = pxNewTCB;
    26e6:	10 93 f3 19 	sts	0x19F3, r17
    26ea:	00 93 f2 19 	sts	0x19F2, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    26ee:	f8 01       	movw	r30, r16
    26f0:	22 8d       	ldd	r18, Z+26	; 0x1a
    26f2:	80 91 50 1a 	lds	r24, 0x1A50
    26f6:	82 17       	cp	r24, r18
    26f8:	10 f4       	brcc	.+4      	; 0x26fe <xTaskGenericCreate+0x124>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    26fa:	20 93 50 1a 	sts	0x1A50, r18
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    26fe:	80 91 51 1a 	lds	r24, 0x1A51
    2702:	8f 5f       	subi	r24, 0xFF	; 255
    2704:	80 93 51 1a 	sts	0x1A51, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    2708:	80 91 f9 19 	lds	r24, 0x19F9
    270c:	82 17       	cp	r24, r18
    270e:	98 f1       	brcs	.+102    	; 0x2776 <xTaskGenericCreate+0x19c>
    2710:	30 e0       	ldi	r19, 0x00	; 0
    2712:	c9 01       	movw	r24, r18
    2714:	88 0f       	add	r24, r24
    2716:	99 1f       	adc	r25, r25
    2718:	a9 01       	movw	r20, r18
    271a:	44 0f       	add	r20, r20
    271c:	55 1f       	adc	r21, r21
    271e:	44 0f       	add	r20, r20
    2720:	55 1f       	adc	r21, r21
    2722:	44 0f       	add	r20, r20
    2724:	55 1f       	adc	r21, r21
    2726:	84 0f       	add	r24, r20
    2728:	95 1f       	adc	r25, r21
    272a:	82 0f       	add	r24, r18
    272c:	93 1f       	adc	r25, r19
    272e:	8d 5f       	subi	r24, 0xFD	; 253
    2730:	95 4e       	sbci	r25, 0xE5	; 229
    2732:	b5 01       	movw	r22, r10
    2734:	0e 94 28 1a 	call	0x3450	; 0x3450 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    2738:	0f 90       	pop	r0
    273a:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    273c:	80 91 f8 19 	lds	r24, 0x19F8
    2740:	88 23       	and	r24, r24
    2742:	39 f0       	breq	.+14     	; 0x2752 <xTaskGenericCreate+0x178>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2744:	e0 91 f2 19 	lds	r30, 0x19F2
    2748:	f0 91 f3 19 	lds	r31, 0x19F3
    274c:	82 8d       	ldd	r24, Z+26	; 0x1a
    274e:	8d 17       	cp	r24, r29
    2750:	b8 f0       	brcs	.+46     	; 0x2780 <xTaskGenericCreate+0x1a6>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    2752:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    2754:	df 91       	pop	r29
    2756:	cf 91       	pop	r28
    2758:	1f 91       	pop	r17
    275a:	0f 91       	pop	r16
    275c:	ff 90       	pop	r15
    275e:	ef 90       	pop	r14
    2760:	df 90       	pop	r13
    2762:	cf 90       	pop	r12
    2764:	bf 90       	pop	r11
    2766:	af 90       	pop	r10
    2768:	9f 90       	pop	r9
    276a:	8f 90       	pop	r8
    276c:	7f 90       	pop	r7
    276e:	6f 90       	pop	r6
    2770:	5f 90       	pop	r5
    2772:	4f 90       	pop	r4
    2774:	08 95       	ret
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );
    2776:	20 93 f9 19 	sts	0x19F9, r18
    277a:	ca cf       	rjmp	.-108    	; 0x2710 <xTaskGenericCreate+0x136>
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    277c:	c3 e0       	ldi	r28, 0x03	; 3
    277e:	6b cf       	rjmp	.-298    	; 0x2656 <xTaskGenericCreate+0x7c>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
			{
				portYIELD_WITHIN_API();
    2780:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    2784:	81 e0       	ldi	r24, 0x01	; 1
    2786:	e6 cf       	rjmp	.-52     	; 0x2754 <xTaskGenericCreate+0x17a>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2788:	8f ef       	ldi	r24, 0xFF	; 255
    278a:	e4 cf       	rjmp	.-56     	; 0x2754 <xTaskGenericCreate+0x17a>
			uxCurrentNumberOfTasks++;
			if( pxCurrentTCB == NULL )
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    278c:	10 93 f3 19 	sts	0x19F3, r17
    2790:	00 93 f2 19 	sts	0x19F2, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2794:	80 91 fe 19 	lds	r24, 0x19FE
    2798:	81 30       	cpi	r24, 0x01	; 1
    279a:	09 f0       	breq	.+2      	; 0x279e <xTaskGenericCreate+0x1c4>
    279c:	a8 cf       	rjmp	.-176    	; 0x26ee <xTaskGenericCreate+0x114>
    279e:	cc 24       	eor	r12, r12
    27a0:	dd 24       	eor	r13, r13
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    27a2:	c6 01       	movw	r24, r12
    27a4:	88 0f       	add	r24, r24
    27a6:	99 1f       	adc	r25, r25
    27a8:	96 01       	movw	r18, r12
    27aa:	22 0f       	add	r18, r18
    27ac:	33 1f       	adc	r19, r19
    27ae:	22 0f       	add	r18, r18
    27b0:	33 1f       	adc	r19, r19
    27b2:	22 0f       	add	r18, r18
    27b4:	33 1f       	adc	r19, r19
    27b6:	82 0f       	add	r24, r18
    27b8:	93 1f       	adc	r25, r19
    27ba:	8c 0d       	add	r24, r12
    27bc:	9d 1d       	adc	r25, r13
    27be:	8d 5f       	subi	r24, 0xFD	; 253
    27c0:	95 4e       	sbci	r25, 0xE5	; 229
    27c2:	0e 94 13 1a 	call	0x3426	; 0x3426 <vListInitialise>
    27c6:	08 94       	sec
    27c8:	c1 1c       	adc	r12, r1
    27ca:	d1 1c       	adc	r13, r1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    27cc:	f4 e0       	ldi	r31, 0x04	; 4
    27ce:	cf 16       	cp	r12, r31
    27d0:	d1 04       	cpc	r13, r1
    27d2:	39 f7       	brne	.-50     	; 0x27a2 <xTaskGenericCreate+0x1c8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    27d4:	7f e2       	ldi	r23, 0x2F	; 47
    27d6:	e7 2e       	mov	r14, r23
    27d8:	7a e1       	ldi	r23, 0x1A	; 26
    27da:	f7 2e       	mov	r15, r23
    27dc:	c7 01       	movw	r24, r14
    27de:	0e 94 13 1a 	call	0x3426	; 0x3426 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    27e2:	ea e3       	ldi	r30, 0x3A	; 58
    27e4:	ce 2e       	mov	r12, r30
    27e6:	ea e1       	ldi	r30, 0x1A	; 26
    27e8:	de 2e       	mov	r13, r30
    27ea:	c6 01       	movw	r24, r12
    27ec:	0e 94 13 1a 	call	0x3426	; 0x3426 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    27f0:	85 e4       	ldi	r24, 0x45	; 69
    27f2:	9a e1       	ldi	r25, 0x1A	; 26
    27f4:	0e 94 13 1a 	call	0x3426	; 0x3426 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    27f8:	f0 92 02 1a 	sts	0x1A02, r15
    27fc:	e0 92 01 1a 	sts	0x1A01, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2800:	d0 92 00 1a 	sts	0x1A00, r13
    2804:	c0 92 ff 19 	sts	0x19FF, r12
    2808:	72 cf       	rjmp	.-284    	; 0x26ee <xTaskGenericCreate+0x114>
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    280a:	c5 01       	movw	r24, r10
    280c:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <pvPortMalloc>
    2810:	6c 01       	movw	r12, r24
    2812:	f8 01       	movw	r30, r16
    2814:	94 8f       	std	Z+28, r25	; 0x1c
    2816:	83 8f       	std	Z+27, r24	; 0x1b

		if( pxNewTCB->pxStack == NULL )
    2818:	00 97       	sbiw	r24, 0x00	; 0
    281a:	09 f0       	breq	.+2      	; 0x281e <xTaskGenericCreate+0x244>
    281c:	02 cf       	rjmp	.-508    	; 0x2622 <xTaskGenericCreate+0x48>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    281e:	c8 01       	movw	r24, r16
    2820:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2824:	8f ef       	ldi	r24, 0xFF	; 255
    2826:	96 cf       	rjmp	.-212    	; 0x2754 <xTaskGenericCreate+0x17a>

00002828 <uxTaskPriorityGet>:
	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
    2828:	0f b6       	in	r0, 0x3f	; 63
    282a:	f8 94       	cli
    282c:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    282e:	00 97       	sbiw	r24, 0x00	; 0
    2830:	29 f0       	breq	.+10     	; 0x283c <uxTaskPriorityGet+0x14>
    2832:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    2834:	0f 90       	pop	r0
    2836:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    2838:	82 8d       	ldd	r24, Z+26	; 0x1a
    283a:	08 95       	ret

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    283c:	e0 91 f2 19 	lds	r30, 0x19F2
    2840:	f0 91 f3 19 	lds	r31, 0x19F3
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    2844:	0f 90       	pop	r0
    2846:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    2848:	82 8d       	ldd	r24, Z+26	; 0x1a
    284a:	08 95       	ret

0000284c <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    284c:	ef 92       	push	r14
    284e:	ff 92       	push	r15
    2850:	1f 93       	push	r17
    2852:	cf 93       	push	r28
    2854:	df 93       	push	r29
    2856:	e6 2f       	mov	r30, r22
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    2858:	64 30       	cpi	r22, 0x04	; 4
    285a:	08 f0       	brcs	.+2      	; 0x285e <vTaskPrioritySet+0x12>
    285c:	e3 e0       	ldi	r30, 0x03	; 3
		if( uxNewPriority >= configMAX_PRIORITIES )
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
		}

		taskENTER_CRITICAL();
    285e:	0f b6       	in	r0, 0x3f	; 63
    2860:	f8 94       	cli
    2862:	0f 92       	push	r0
		{
			if( pxTask == pxCurrentTCB )
    2864:	20 91 f2 19 	lds	r18, 0x19F2
    2868:	30 91 f3 19 	lds	r19, 0x19F3
    286c:	82 17       	cp	r24, r18
    286e:	93 07       	cpc	r25, r19
    2870:	09 f4       	brne	.+2      	; 0x2874 <vTaskPrioritySet+0x28>
    2872:	48 c0       	rjmp	.+144    	; 0x2904 <vTaskPrioritySet+0xb8>
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    2874:	00 97       	sbiw	r24, 0x00	; 0
    2876:	09 f4       	brne	.+2      	; 0x287a <vTaskPrioritySet+0x2e>
    2878:	45 c0       	rjmp	.+138    	; 0x2904 <vTaskPrioritySet+0xb8>
    287a:	ec 01       	movw	r28, r24

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
    287c:	2f a1       	lds	r18, 0x4f
			{
				uxCurrentPriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    287e:	2e 17       	cp	r18, r30
    2880:	71 f1       	breq	.+92     	; 0x28de <vTaskPrioritySet+0x92>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    2882:	11 e0       	ldi	r17, 0x01	; 1

			if( uxCurrentPriority != uxNewPriority )
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    2884:	2e 17       	cp	r18, r30
    2886:	98 f5       	brcc	.+102    	; 0x28ee <vTaskPrioritySet+0xa2>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    2888:	00 97       	sbiw	r24, 0x00	; 0
    288a:	99 f1       	breq	.+102    	; 0x28f2 <vTaskPrioritySet+0xa6>

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    288c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    288e:	28 17       	cp	r18, r24
    2890:	a1 f1       	breq	.+104    	; 0x28fa <vTaskPrioritySet+0xae>
					{
						pxTCB->uxPriority = uxNewPriority;
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    2892:	ef a3       	lds	r30, 0x5f
				{
					pxTCB->uxPriority = uxNewPriority;
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    2894:	44 e0       	ldi	r20, 0x04	; 4
    2896:	50 e0       	ldi	r21, 0x00	; 0
    2898:	60 e0       	ldi	r22, 0x00	; 0
    289a:	70 e0       	ldi	r23, 0x00	; 0
    289c:	4e 1b       	sub	r20, r30
    289e:	51 09       	sbc	r21, r1
    28a0:	61 09       	sbc	r22, r1
    28a2:	71 09       	sbc	r23, r1
    28a4:	4e 87       	std	Y+14, r20	; 0x0e
    28a6:	5f 87       	std	Y+15, r21	; 0x0f
    28a8:	68 8b       	std	Y+16, r22	; 0x10
    28aa:	79 8b       	std	Y+17, r23	; 0x11

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    28ac:	82 2f       	mov	r24, r18
    28ae:	90 e0       	ldi	r25, 0x00	; 0
    28b0:	ac 01       	movw	r20, r24
    28b2:	44 0f       	add	r20, r20
    28b4:	55 1f       	adc	r21, r21
    28b6:	9c 01       	movw	r18, r24
    28b8:	22 0f       	add	r18, r18
    28ba:	33 1f       	adc	r19, r19
    28bc:	22 0f       	add	r18, r18
    28be:	33 1f       	adc	r19, r19
    28c0:	22 0f       	add	r18, r18
    28c2:	33 1f       	adc	r19, r19
    28c4:	42 0f       	add	r20, r18
    28c6:	53 1f       	adc	r21, r19
    28c8:	48 0f       	add	r20, r24
    28ca:	59 1f       	adc	r21, r25
    28cc:	4d 5f       	subi	r20, 0xFD	; 253
    28ce:	55 4e       	sbci	r21, 0xE5	; 229
    28d0:	8c 85       	ldd	r24, Y+12	; 0x0c
    28d2:	9d 85       	ldd	r25, Y+13	; 0x0d
    28d4:	84 17       	cp	r24, r20
    28d6:	95 07       	cpc	r25, r21
    28d8:	e1 f0       	breq	.+56     	; 0x2912 <vTaskPrioritySet+0xc6>
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
				}

				if( xYieldRequired == pdTRUE )
    28da:	11 30       	cpi	r17, 0x01	; 1
    28dc:	81 f0       	breq	.+32     	; 0x28fe <vTaskPrioritySet+0xb2>
				{
					portYIELD_WITHIN_API();
				}
			}
		}
		taskEXIT_CRITICAL();
    28de:	0f 90       	pop	r0
    28e0:	0f be       	out	0x3f, r0	; 63
	}
    28e2:	df 91       	pop	r29
    28e4:	cf 91       	pop	r28
    28e6:	1f 91       	pop	r17
    28e8:	ff 90       	pop	r15
    28ea:	ef 90       	pop	r14
    28ec:	08 95       	ret
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    28ee:	00 97       	sbiw	r24, 0x00	; 0
    28f0:	69 f2       	breq	.-102    	; 0x288c <vTaskPrioritySet+0x40>
    28f2:	10 e0       	ldi	r17, 0x00	; 0

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    28f4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    28f6:	28 17       	cp	r18, r24
    28f8:	61 f6       	brne	.-104    	; 0x2892 <vTaskPrioritySet+0x46>
					{
						pxTCB->uxPriority = uxNewPriority;
    28fa:	ea 8f       	std	Y+26, r30	; 0x1a
    28fc:	ca cf       	rjmp	.-108    	; 0x2892 <vTaskPrioritySet+0x46>
					prvAddTaskToReadyQueue( pxTCB );
				}

				if( xYieldRequired == pdTRUE )
				{
					portYIELD_WITHIN_API();
    28fe:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <vPortYield>
    2902:	ed cf       	rjmp	.-38     	; 0x28de <vTaskPrioritySet+0x92>
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    2904:	c0 91 f2 19 	lds	r28, 0x19F2
    2908:	d0 91 f3 19 	lds	r29, 0x19F3
    290c:	80 e0       	ldi	r24, 0x00	; 0
    290e:	90 e0       	ldi	r25, 0x00	; 0
    2910:	b5 cf       	rjmp	.-150    	; 0x287c <vTaskPrioritySet+0x30>
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    2912:	82 e0       	ldi	r24, 0x02	; 2
    2914:	e8 2e       	mov	r14, r24
    2916:	f1 2c       	mov	r15, r1
    2918:	ec 0e       	add	r14, r28
    291a:	fd 1e       	adc	r15, r29
    291c:	c7 01       	movw	r24, r14
    291e:	0e 94 a3 1a 	call	0x3546	; 0x3546 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2922:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2924:	80 91 f9 19 	lds	r24, 0x19F9
    2928:	82 17       	cp	r24, r18
    292a:	10 f4       	brcc	.+4      	; 0x2930 <vTaskPrioritySet+0xe4>
    292c:	20 93 f9 19 	sts	0x19F9, r18
    2930:	30 e0       	ldi	r19, 0x00	; 0
    2932:	c9 01       	movw	r24, r18
    2934:	88 0f       	add	r24, r24
    2936:	99 1f       	adc	r25, r25
    2938:	a9 01       	movw	r20, r18
    293a:	44 0f       	add	r20, r20
    293c:	55 1f       	adc	r21, r21
    293e:	44 0f       	add	r20, r20
    2940:	55 1f       	adc	r21, r21
    2942:	44 0f       	add	r20, r20
    2944:	55 1f       	adc	r21, r21
    2946:	84 0f       	add	r24, r20
    2948:	95 1f       	adc	r25, r21
    294a:	82 0f       	add	r24, r18
    294c:	93 1f       	adc	r25, r19
    294e:	8d 5f       	subi	r24, 0xFD	; 253
    2950:	95 4e       	sbci	r25, 0xE5	; 229
    2952:	b7 01       	movw	r22, r14
    2954:	0e 94 28 1a 	call	0x3450	; 0x3450 <vListInsertEnd>
    2958:	c0 cf       	rjmp	.-128    	; 0x28da <vTaskPrioritySet+0x8e>

0000295a <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    295a:	af 92       	push	r10
    295c:	bf 92       	push	r11
    295e:	cf 92       	push	r12
    2960:	df 92       	push	r13
    2962:	ef 92       	push	r14
    2964:	ff 92       	push	r15
    2966:	0f 93       	push	r16
	/* Add the idle task at the lowest priority. */
	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
	{
		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
		be returned by the xTaskGetIdleTaskHandle() function. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
    2968:	84 e9       	ldi	r24, 0x94	; 148
    296a:	92 e1       	ldi	r25, 0x12	; 18
    296c:	60 e9       	ldi	r22, 0x90	; 144
    296e:	72 e0       	ldi	r23, 0x02	; 2
    2970:	44 e6       	ldi	r20, 0x64	; 100
    2972:	50 e0       	ldi	r21, 0x00	; 0
    2974:	20 e0       	ldi	r18, 0x00	; 0
    2976:	30 e0       	ldi	r19, 0x00	; 0
    2978:	00 e0       	ldi	r16, 0x00	; 0
    297a:	f2 e5       	ldi	r31, 0x52	; 82
    297c:	ef 2e       	mov	r14, r31
    297e:	fa e1       	ldi	r31, 0x1A	; 26
    2980:	ff 2e       	mov	r15, r31
    2982:	cc 24       	eor	r12, r12
    2984:	dd 24       	eor	r13, r13
    2986:	aa 24       	eor	r10, r10
    2988:	bb 24       	eor	r11, r11
    298a:	0e 94 ed 12 	call	0x25da	; 0x25da <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    298e:	81 30       	cpi	r24, 0x01	; 1
    2990:	41 f0       	breq	.+16     	; 0x29a2 <vTaskStartScheduler+0x48>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    2992:	0f 91       	pop	r16
    2994:	ff 90       	pop	r15
    2996:	ef 90       	pop	r14
    2998:	df 90       	pop	r13
    299a:	cf 90       	pop	r12
    299c:	bf 90       	pop	r11
    299e:	af 90       	pop	r10
    29a0:	08 95       	ret
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    29a2:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    29a4:	80 93 f8 19 	sts	0x19F8, r24
		xTickCount = ( portTickType ) 0U;
    29a8:	10 92 fa 19 	sts	0x19FA, r1
    29ac:	10 92 fb 19 	sts	0x19FB, r1
    29b0:	10 92 fc 19 	sts	0x19FC, r1
    29b4:	10 92 fd 19 	sts	0x19FD, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    29b8:	0e 94 1f 0e 	call	0x1c3e	; 0x1c3e <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    29bc:	0f 91       	pop	r16
    29be:	ff 90       	pop	r15
    29c0:	ef 90       	pop	r14
    29c2:	df 90       	pop	r13
    29c4:	cf 90       	pop	r12
    29c6:	bf 90       	pop	r11
    29c8:	af 90       	pop	r10
    29ca:	08 95       	ret

000029cc <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    29cc:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    29ce:	10 92 f8 19 	sts	0x19F8, r1
	vPortEndScheduler();
    29d2:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vPortEndScheduler>
}
    29d6:	08 95       	ret

000029d8 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    29d8:	80 91 f7 19 	lds	r24, 0x19F7
    29dc:	8f 5f       	subi	r24, 0xFF	; 255
    29de:	80 93 f7 19 	sts	0x19F7, r24
}
    29e2:	08 95       	ret

000029e4 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    29e4:	0f 93       	push	r16
    29e6:	1f 93       	push	r17
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    29e8:	0f b6       	in	r0, 0x3f	; 63
    29ea:	f8 94       	cli
    29ec:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    29ee:	00 91 fa 19 	lds	r16, 0x19FA
    29f2:	10 91 fb 19 	lds	r17, 0x19FB
    29f6:	20 91 fc 19 	lds	r18, 0x19FC
    29fa:	30 91 fd 19 	lds	r19, 0x19FD
	}
	taskEXIT_CRITICAL();
    29fe:	0f 90       	pop	r0
    2a00:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    2a02:	b8 01       	movw	r22, r16
    2a04:	c9 01       	movw	r24, r18
    2a06:	1f 91       	pop	r17
    2a08:	0f 91       	pop	r16
    2a0a:	08 95       	ret

00002a0c <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    2a0c:	0f 93       	push	r16
    2a0e:	1f 93       	push	r17
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    2a10:	00 91 fa 19 	lds	r16, 0x19FA
    2a14:	10 91 fb 19 	lds	r17, 0x19FB
    2a18:	20 91 fc 19 	lds	r18, 0x19FC
    2a1c:	30 91 fd 19 	lds	r19, 0x19FD
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2a20:	b8 01       	movw	r22, r16
    2a22:	c9 01       	movw	r24, r18
    2a24:	1f 91       	pop	r17
    2a26:	0f 91       	pop	r16
    2a28:	08 95       	ret

00002a2a <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2a2a:	80 91 fe 19 	lds	r24, 0x19FE
}
    2a2e:	08 95       	ret

00002a30 <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    2a30:	00 97       	sbiw	r24, 0x00	; 0
    2a32:	11 f0       	breq	.+4      	; 0x2a38 <pcTaskGetTaskName+0x8>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
    2a34:	4d 96       	adiw	r24, 0x1d	; 29
	}
    2a36:	08 95       	ret
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    2a38:	80 91 f2 19 	lds	r24, 0x19F2
    2a3c:	90 91 f3 19 	lds	r25, 0x19F3
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
    2a40:	4d 96       	adiw	r24, 0x1d	; 29
	}
    2a42:	08 95       	ret

00002a44 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    2a44:	80 91 52 1a 	lds	r24, 0x1A52
    2a48:	90 91 53 1a 	lds	r25, 0x1A53
    2a4c:	08 95       	ret

00002a4e <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2a4e:	0f 93       	push	r16
    2a50:	1f 93       	push	r17
    2a52:	cf 93       	push	r28
    2a54:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2a56:	80 91 f7 19 	lds	r24, 0x19F7
    2a5a:	88 23       	and	r24, r24
    2a5c:	09 f0       	breq	.+2      	; 0x2a60 <vTaskIncrementTick+0x12>
    2a5e:	93 c0       	rjmp	.+294    	; 0x2b86 <vTaskIncrementTick+0x138>
	{
		++xTickCount;
    2a60:	80 91 fa 19 	lds	r24, 0x19FA
    2a64:	90 91 fb 19 	lds	r25, 0x19FB
    2a68:	a0 91 fc 19 	lds	r26, 0x19FC
    2a6c:	b0 91 fd 19 	lds	r27, 0x19FD
    2a70:	01 96       	adiw	r24, 0x01	; 1
    2a72:	a1 1d       	adc	r26, r1
    2a74:	b1 1d       	adc	r27, r1
    2a76:	80 93 fa 19 	sts	0x19FA, r24
    2a7a:	90 93 fb 19 	sts	0x19FB, r25
    2a7e:	a0 93 fc 19 	sts	0x19FC, r26
    2a82:	b0 93 fd 19 	sts	0x19FD, r27
		if( xTickCount == ( portTickType ) 0U )
    2a86:	80 91 fa 19 	lds	r24, 0x19FA
    2a8a:	90 91 fb 19 	lds	r25, 0x19FB
    2a8e:	a0 91 fc 19 	lds	r26, 0x19FC
    2a92:	b0 91 fd 19 	lds	r27, 0x19FD
    2a96:	00 97       	sbiw	r24, 0x00	; 0
    2a98:	a1 05       	cpc	r26, r1
    2a9a:	b1 05       	cpc	r27, r1
    2a9c:	09 f4       	brne	.+2      	; 0x2aa0 <vTaskIncrementTick+0x52>
    2a9e:	7d c0       	rjmp	.+250    	; 0x2b9a <vTaskIncrementTick+0x14c>
    2aa0:	80 91 95 02 	lds	r24, 0x0295
    2aa4:	90 91 96 02 	lds	r25, 0x0296
    2aa8:	a0 91 97 02 	lds	r26, 0x0297
    2aac:	b0 91 98 02 	lds	r27, 0x0298
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2ab0:	40 91 fa 19 	lds	r20, 0x19FA
    2ab4:	50 91 fb 19 	lds	r21, 0x19FB
    2ab8:	60 91 fc 19 	lds	r22, 0x19FC
    2abc:	70 91 fd 19 	lds	r23, 0x19FD
    2ac0:	48 17       	cp	r20, r24
    2ac2:	59 07       	cpc	r21, r25
    2ac4:	6a 07       	cpc	r22, r26
    2ac6:	7b 07       	cpc	r23, r27
    2ac8:	08 f0       	brcs	.+2      	; 0x2acc <vTaskIncrementTick+0x7e>
    2aca:	45 c0       	rjmp	.+138    	; 0x2b56 <vTaskIncrementTick+0x108>
    2acc:	61 c0       	rjmp	.+194    	; 0x2b90 <vTaskIncrementTick+0x142>
    2ace:	e0 91 01 1a 	lds	r30, 0x1A01
    2ad2:	f0 91 02 1a 	lds	r31, 0x1A02
    2ad6:	07 80       	ldd	r0, Z+7	; 0x07
    2ad8:	f0 85       	ldd	r31, Z+8	; 0x08
    2ada:	e0 2d       	mov	r30, r0
    2adc:	c0 85       	ldd	r28, Z+8	; 0x08
    2ade:	d1 85       	ldd	r29, Z+9	; 0x09
    2ae0:	8a 81       	ldd	r24, Y+2	; 0x02
    2ae2:	9b 81       	ldd	r25, Y+3	; 0x03
    2ae4:	ac 81       	ldd	r26, Y+4	; 0x04
    2ae6:	bd 81       	ldd	r27, Y+5	; 0x05
    2ae8:	40 91 fa 19 	lds	r20, 0x19FA
    2aec:	50 91 fb 19 	lds	r21, 0x19FB
    2af0:	60 91 fc 19 	lds	r22, 0x19FC
    2af4:	70 91 fd 19 	lds	r23, 0x19FD
    2af8:	48 17       	cp	r20, r24
    2afa:	59 07       	cpc	r21, r25
    2afc:	6a 07       	cpc	r22, r26
    2afe:	7b 07       	cpc	r23, r27
    2b00:	08 f4       	brcc	.+2      	; 0x2b04 <vTaskIncrementTick+0xb6>
    2b02:	8a c0       	rjmp	.+276    	; 0x2c18 <vTaskIncrementTick+0x1ca>
    2b04:	8e 01       	movw	r16, r28
    2b06:	0e 5f       	subi	r16, 0xFE	; 254
    2b08:	1f 4f       	sbci	r17, 0xFF	; 255
    2b0a:	c8 01       	movw	r24, r16
    2b0c:	0e 94 a3 1a 	call	0x3546	; 0x3546 <vListRemove>
    2b10:	88 8d       	ldd	r24, Y+24	; 0x18
    2b12:	99 8d       	ldd	r25, Y+25	; 0x19
    2b14:	00 97       	sbiw	r24, 0x00	; 0
    2b16:	21 f0       	breq	.+8      	; 0x2b20 <vTaskIncrementTick+0xd2>
    2b18:	ce 01       	movw	r24, r28
    2b1a:	0e 96       	adiw	r24, 0x0e	; 14
    2b1c:	0e 94 a3 1a 	call	0x3546	; 0x3546 <vListRemove>
    2b20:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2b22:	80 91 f9 19 	lds	r24, 0x19F9
    2b26:	82 17       	cp	r24, r18
    2b28:	10 f4       	brcc	.+4      	; 0x2b2e <vTaskIncrementTick+0xe0>
    2b2a:	20 93 f9 19 	sts	0x19F9, r18
    2b2e:	30 e0       	ldi	r19, 0x00	; 0
    2b30:	c9 01       	movw	r24, r18
    2b32:	88 0f       	add	r24, r24
    2b34:	99 1f       	adc	r25, r25
    2b36:	a9 01       	movw	r20, r18
    2b38:	44 0f       	add	r20, r20
    2b3a:	55 1f       	adc	r21, r21
    2b3c:	44 0f       	add	r20, r20
    2b3e:	55 1f       	adc	r21, r21
    2b40:	44 0f       	add	r20, r20
    2b42:	55 1f       	adc	r21, r21
    2b44:	84 0f       	add	r24, r20
    2b46:	95 1f       	adc	r25, r21
    2b48:	82 0f       	add	r24, r18
    2b4a:	93 1f       	adc	r25, r19
    2b4c:	8d 5f       	subi	r24, 0xFD	; 253
    2b4e:	95 4e       	sbci	r25, 0xE5	; 229
    2b50:	b8 01       	movw	r22, r16
    2b52:	0e 94 28 1a 	call	0x3450	; 0x3450 <vListInsertEnd>
    2b56:	e0 91 01 1a 	lds	r30, 0x1A01
    2b5a:	f0 91 02 1a 	lds	r31, 0x1A02
    2b5e:	80 81       	ld	r24, Z
    2b60:	88 23       	and	r24, r24
    2b62:	09 f0       	breq	.+2      	; 0x2b66 <vTaskIncrementTick+0x118>
    2b64:	b4 cf       	rjmp	.-152    	; 0x2ace <vTaskIncrementTick+0x80>
    2b66:	8f ef       	ldi	r24, 0xFF	; 255
    2b68:	9f ef       	ldi	r25, 0xFF	; 255
    2b6a:	dc 01       	movw	r26, r24
    2b6c:	80 93 95 02 	sts	0x0295, r24
    2b70:	90 93 96 02 	sts	0x0296, r25
    2b74:	a0 93 97 02 	sts	0x0297, r26
    2b78:	b0 93 98 02 	sts	0x0298, r27
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2b7c:	df 91       	pop	r29
    2b7e:	cf 91       	pop	r28
    2b80:	1f 91       	pop	r17
    2b82:	0f 91       	pop	r16
    2b84:	08 95       	ret
		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
	}
	else
	{
		++uxMissedTicks;
    2b86:	80 91 f6 19 	lds	r24, 0x19F6
    2b8a:	8f 5f       	subi	r24, 0xFF	; 255
    2b8c:	80 93 f6 19 	sts	0x19F6, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2b90:	df 91       	pop	r29
    2b92:	cf 91       	pop	r28
    2b94:	1f 91       	pop	r17
    2b96:	0f 91       	pop	r16
    2b98:	08 95       	ret
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2b9a:	80 91 01 1a 	lds	r24, 0x1A01
    2b9e:	90 91 02 1a 	lds	r25, 0x1A02
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2ba2:	20 91 ff 19 	lds	r18, 0x19FF
    2ba6:	30 91 00 1a 	lds	r19, 0x1A00
    2baa:	30 93 02 1a 	sts	0x1A02, r19
    2bae:	20 93 01 1a 	sts	0x1A01, r18
			pxOverflowDelayedTaskList = pxTemp;
    2bb2:	90 93 00 1a 	sts	0x1A00, r25
    2bb6:	80 93 ff 19 	sts	0x19FF, r24
			xNumOfOverflows++;
    2bba:	80 91 f4 19 	lds	r24, 0x19F4
    2bbe:	8f 5f       	subi	r24, 0xFF	; 255
    2bc0:	80 93 f4 19 	sts	0x19F4, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2bc4:	e0 91 01 1a 	lds	r30, 0x1A01
    2bc8:	f0 91 02 1a 	lds	r31, 0x1A02
    2bcc:	80 81       	ld	r24, Z
    2bce:	88 23       	and	r24, r24
    2bd0:	61 f4       	brne	.+24     	; 0x2bea <vTaskIncrementTick+0x19c>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2bd2:	8f ef       	ldi	r24, 0xFF	; 255
    2bd4:	9f ef       	ldi	r25, 0xFF	; 255
    2bd6:	dc 01       	movw	r26, r24
    2bd8:	80 93 95 02 	sts	0x0295, r24
    2bdc:	90 93 96 02 	sts	0x0296, r25
    2be0:	a0 93 97 02 	sts	0x0297, r26
    2be4:	b0 93 98 02 	sts	0x0298, r27
    2be8:	63 cf       	rjmp	.-314    	; 0x2ab0 <vTaskIncrementTick+0x62>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2bea:	e0 91 01 1a 	lds	r30, 0x1A01
    2bee:	f0 91 02 1a 	lds	r31, 0x1A02
    2bf2:	07 80       	ldd	r0, Z+7	; 0x07
    2bf4:	f0 85       	ldd	r31, Z+8	; 0x08
    2bf6:	e0 2d       	mov	r30, r0
    2bf8:	00 84       	ldd	r0, Z+8	; 0x08
    2bfa:	f1 85       	ldd	r31, Z+9	; 0x09
    2bfc:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2bfe:	82 81       	ldd	r24, Z+2	; 0x02
    2c00:	93 81       	ldd	r25, Z+3	; 0x03
    2c02:	a4 81       	ldd	r26, Z+4	; 0x04
    2c04:	b5 81       	ldd	r27, Z+5	; 0x05
    2c06:	80 93 95 02 	sts	0x0295, r24
    2c0a:	90 93 96 02 	sts	0x0296, r25
    2c0e:	a0 93 97 02 	sts	0x0297, r26
    2c12:	b0 93 98 02 	sts	0x0298, r27
    2c16:	4c cf       	rjmp	.-360    	; 0x2ab0 <vTaskIncrementTick+0x62>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2c18:	80 93 95 02 	sts	0x0295, r24
    2c1c:	90 93 96 02 	sts	0x0296, r25
    2c20:	a0 93 97 02 	sts	0x0297, r26
    2c24:	b0 93 98 02 	sts	0x0298, r27
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2c28:	df 91       	pop	r29
    2c2a:	cf 91       	pop	r28
    2c2c:	1f 91       	pop	r17
    2c2e:	0f 91       	pop	r16
    2c30:	08 95       	ret

00002c32 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2c32:	ef 92       	push	r14
    2c34:	ff 92       	push	r15
    2c36:	0f 93       	push	r16
    2c38:	1f 93       	push	r17
    2c3a:	cf 93       	push	r28
    2c3c:	df 93       	push	r29
    2c3e:	0f 92       	push	r0
    2c40:	cd b7       	in	r28, 0x3d	; 61
    2c42:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2c44:	0f b6       	in	r0, 0x3f	; 63
    2c46:	f8 94       	cli
    2c48:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2c4a:	80 91 f7 19 	lds	r24, 0x19F7
    2c4e:	81 50       	subi	r24, 0x01	; 1
    2c50:	80 93 f7 19 	sts	0x19F7, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2c54:	80 91 f7 19 	lds	r24, 0x19F7
    2c58:	88 23       	and	r24, r24
    2c5a:	09 f0       	breq	.+2      	; 0x2c5e <xTaskResumeAll+0x2c>
    2c5c:	64 c0       	rjmp	.+200    	; 0x2d26 <xTaskResumeAll+0xf4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2c5e:	80 91 fe 19 	lds	r24, 0x19FE
    2c62:	88 23       	and	r24, r24
    2c64:	09 f4       	brne	.+2      	; 0x2c68 <xTaskResumeAll+0x36>
    2c66:	55 c0       	rjmp	.+170    	; 0x2d12 <xTaskResumeAll+0xe0>
    2c68:	19 82       	std	Y+1, r1	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2c6a:	80 91 45 1a 	lds	r24, 0x1A45
    2c6e:	88 23       	and	r24, r24
    2c70:	09 f4       	brne	.+2      	; 0x2c74 <xTaskResumeAll+0x42>
    2c72:	3f c0       	rjmp	.+126    	; 0x2cf2 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2c74:	e0 91 4c 1a 	lds	r30, 0x1A4C
    2c78:	f0 91 4d 1a 	lds	r31, 0x1A4D
    2c7c:	e0 84       	ldd	r14, Z+8	; 0x08
    2c7e:	f1 84       	ldd	r15, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    2c80:	c7 01       	movw	r24, r14
    2c82:	0e 96       	adiw	r24, 0x0e	; 14
    2c84:	0e 94 a3 1a 	call	0x3546	; 0x3546 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2c88:	87 01       	movw	r16, r14
    2c8a:	0e 5f       	subi	r16, 0xFE	; 254
    2c8c:	1f 4f       	sbci	r17, 0xFF	; 255
    2c8e:	c8 01       	movw	r24, r16
    2c90:	0e 94 a3 1a 	call	0x3546	; 0x3546 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2c94:	d7 01       	movw	r26, r14
    2c96:	5a 96       	adiw	r26, 0x1a	; 26
    2c98:	2c 91       	ld	r18, X
    2c9a:	5a 97       	sbiw	r26, 0x1a	; 26
    2c9c:	80 91 f9 19 	lds	r24, 0x19F9
    2ca0:	82 17       	cp	r24, r18
    2ca2:	10 f4       	brcc	.+4      	; 0x2ca8 <xTaskResumeAll+0x76>
    2ca4:	20 93 f9 19 	sts	0x19F9, r18
    2ca8:	30 e0       	ldi	r19, 0x00	; 0
    2caa:	c9 01       	movw	r24, r18
    2cac:	88 0f       	add	r24, r24
    2cae:	99 1f       	adc	r25, r25
    2cb0:	a9 01       	movw	r20, r18
    2cb2:	44 0f       	add	r20, r20
    2cb4:	55 1f       	adc	r21, r21
    2cb6:	44 0f       	add	r20, r20
    2cb8:	55 1f       	adc	r21, r21
    2cba:	44 0f       	add	r20, r20
    2cbc:	55 1f       	adc	r21, r21
    2cbe:	84 0f       	add	r24, r20
    2cc0:	95 1f       	adc	r25, r21
    2cc2:	82 0f       	add	r24, r18
    2cc4:	93 1f       	adc	r25, r19
    2cc6:	8d 5f       	subi	r24, 0xFD	; 253
    2cc8:	95 4e       	sbci	r25, 0xE5	; 229
    2cca:	b8 01       	movw	r22, r16
    2ccc:	0e 94 28 1a 	call	0x3450	; 0x3450 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2cd0:	e0 91 f2 19 	lds	r30, 0x19F2
    2cd4:	f0 91 f3 19 	lds	r31, 0x19F3
    2cd8:	d7 01       	movw	r26, r14
    2cda:	5a 96       	adiw	r26, 0x1a	; 26
    2cdc:	9c 91       	ld	r25, X
    2cde:	5a 97       	sbiw	r26, 0x1a	; 26
    2ce0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ce2:	98 17       	cp	r25, r24
    2ce4:	10 f2       	brcs	.-124    	; 0x2c6a <xTaskResumeAll+0x38>
					{
						xYieldRequired = pdTRUE;
    2ce6:	b1 e0       	ldi	r27, 0x01	; 1
    2ce8:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2cea:	80 91 45 1a 	lds	r24, 0x1A45
    2cee:	88 23       	and	r24, r24
    2cf0:	09 f6       	brne	.-126    	; 0x2c74 <xTaskResumeAll+0x42>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2cf2:	80 91 f6 19 	lds	r24, 0x19F6
    2cf6:	88 23       	and	r24, r24
    2cf8:	c1 f4       	brne	.+48     	; 0x2d2a <xTaskResumeAll+0xf8>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2cfa:	e9 81       	ldd	r30, Y+1	; 0x01
    2cfc:	e1 30       	cpi	r30, 0x01	; 1
    2cfe:	21 f0       	breq	.+8      	; 0x2d08 <xTaskResumeAll+0xd6>
    2d00:	80 91 f5 19 	lds	r24, 0x19F5
    2d04:	81 30       	cpi	r24, 0x01	; 1
    2d06:	79 f4       	brne	.+30     	; 0x2d26 <xTaskResumeAll+0xf4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    2d08:	10 92 f5 19 	sts	0x19F5, r1
					portYIELD_WITHIN_API();
    2d0c:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    2d10:	81 e0       	ldi	r24, 0x01	; 1
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2d12:	0f 90       	pop	r0
    2d14:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    2d16:	0f 90       	pop	r0
    2d18:	df 91       	pop	r29
    2d1a:	cf 91       	pop	r28
    2d1c:	1f 91       	pop	r17
    2d1e:	0f 91       	pop	r16
    2d20:	ff 90       	pop	r15
    2d22:	ef 90       	pop	r14
    2d24:	08 95       	ret
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2d26:	80 e0       	ldi	r24, 0x00	; 0
    2d28:	f4 cf       	rjmp	.-24     	; 0x2d12 <xTaskResumeAll+0xe0>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2d2a:	80 91 f6 19 	lds	r24, 0x19F6
    2d2e:	88 23       	and	r24, r24
    2d30:	59 f3       	breq	.-42     	; 0x2d08 <xTaskResumeAll+0xd6>
					{
						vTaskIncrementTick();
    2d32:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskIncrementTick>
						--uxMissedTicks;
    2d36:	80 91 f6 19 	lds	r24, 0x19F6
    2d3a:	81 50       	subi	r24, 0x01	; 1
    2d3c:	80 93 f6 19 	sts	0x19F6, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2d40:	80 91 f6 19 	lds	r24, 0x19F6
    2d44:	88 23       	and	r24, r24
    2d46:	a9 f7       	brne	.-22     	; 0x2d32 <xTaskResumeAll+0x100>
    2d48:	df cf       	rjmp	.-66     	; 0x2d08 <xTaskResumeAll+0xd6>

00002d4a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2d4a:	cf 92       	push	r12
    2d4c:	df 92       	push	r13
    2d4e:	ef 92       	push	r14
    2d50:	ff 92       	push	r15
    2d52:	dc 01       	movw	r26, r24
    2d54:	cb 01       	movw	r24, r22
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2d56:	00 97       	sbiw	r24, 0x00	; 0
    2d58:	a1 05       	cpc	r26, r1
    2d5a:	b1 05       	cpc	r27, r1
    2d5c:	39 f4       	brne	.+14     	; 0x2d6c <vTaskDelay+0x22>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
    2d5e:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <vPortYield>
		}
	}
    2d62:	ff 90       	pop	r15
    2d64:	ef 90       	pop	r14
    2d66:	df 90       	pop	r13
    2d68:	cf 90       	pop	r12
    2d6a:	08 95       	ret

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2d6c:	20 91 f7 19 	lds	r18, 0x19F7
    2d70:	2f 5f       	subi	r18, 0xFF	; 255
    2d72:	20 93 f7 19 	sts	0x19F7, r18
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2d76:	c0 90 fa 19 	lds	r12, 0x19FA
    2d7a:	d0 90 fb 19 	lds	r13, 0x19FB
    2d7e:	e0 90 fc 19 	lds	r14, 0x19FC
    2d82:	f0 90 fd 19 	lds	r15, 0x19FD
    2d86:	c8 0e       	add	r12, r24
    2d88:	d9 1e       	adc	r13, r25
    2d8a:	ea 1e       	adc	r14, r26
    2d8c:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2d8e:	80 91 f2 19 	lds	r24, 0x19F2
    2d92:	90 91 f3 19 	lds	r25, 0x19F3
    2d96:	02 96       	adiw	r24, 0x02	; 2
    2d98:	0e 94 a3 1a 	call	0x3546	; 0x3546 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2d9c:	c7 01       	movw	r24, r14
    2d9e:	b6 01       	movw	r22, r12
    2da0:	0e 94 9b 12 	call	0x2536	; 0x2536 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2da4:	0e 94 19 16 	call	0x2c32	; 0x2c32 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2da8:	88 23       	and	r24, r24
    2daa:	c9 f2       	breq	.-78     	; 0x2d5e <vTaskDelay+0x14>
		{
			portYIELD_WITHIN_API();
		}
	}
    2dac:	ff 90       	pop	r15
    2dae:	ef 90       	pop	r14
    2db0:	df 90       	pop	r13
    2db2:	cf 90       	pop	r12
    2db4:	08 95       	ret

00002db6 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2db6:	cf 92       	push	r12
    2db8:	df 92       	push	r13
    2dba:	ef 92       	push	r14
    2dbc:	ff 92       	push	r15
    2dbe:	fc 01       	movw	r30, r24
    2dc0:	6a 01       	movw	r12, r20
    2dc2:	7b 01       	movw	r14, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2dc4:	80 91 f7 19 	lds	r24, 0x19F7
    2dc8:	8f 5f       	subi	r24, 0xFF	; 255
    2dca:	80 93 f7 19 	sts	0x19F7, r24
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2dce:	80 81       	ld	r24, Z
    2dd0:	91 81       	ldd	r25, Z+1	; 0x01
    2dd2:	a2 81       	ldd	r26, Z+2	; 0x02
    2dd4:	b3 81       	ldd	r27, Z+3	; 0x03
    2dd6:	c8 0e       	add	r12, r24
    2dd8:	d9 1e       	adc	r13, r25
    2dda:	ea 1e       	adc	r14, r26
    2ddc:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2dde:	40 91 fa 19 	lds	r20, 0x19FA
    2de2:	50 91 fb 19 	lds	r21, 0x19FB
    2de6:	60 91 fc 19 	lds	r22, 0x19FC
    2dea:	70 91 fd 19 	lds	r23, 0x19FD
    2dee:	48 17       	cp	r20, r24
    2df0:	59 07       	cpc	r21, r25
    2df2:	6a 07       	cpc	r22, r26
    2df4:	7b 07       	cpc	r23, r27
    2df6:	60 f5       	brcc	.+88     	; 0x2e50 <vTaskDelayUntil+0x9a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2df8:	c8 16       	cp	r12, r24
    2dfa:	d9 06       	cpc	r13, r25
    2dfc:	ea 06       	cpc	r14, r26
    2dfe:	fb 06       	cpc	r15, r27
    2e00:	68 f5       	brcc	.+90     	; 0x2e5c <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2e02:	80 91 fa 19 	lds	r24, 0x19FA
    2e06:	90 91 fb 19 	lds	r25, 0x19FB
    2e0a:	a0 91 fc 19 	lds	r26, 0x19FC
    2e0e:	b0 91 fd 19 	lds	r27, 0x19FD
    2e12:	8c 15       	cp	r24, r12
    2e14:	9d 05       	cpc	r25, r13
    2e16:	ae 05       	cpc	r26, r14
    2e18:	bf 05       	cpc	r27, r15
    2e1a:	00 f5       	brcc	.+64     	; 0x2e5c <vTaskDelayUntil+0xa6>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2e1c:	c0 82       	st	Z, r12
    2e1e:	d1 82       	std	Z+1, r13	; 0x01
    2e20:	e2 82       	std	Z+2, r14	; 0x02
    2e22:	f3 82       	std	Z+3, r15	; 0x03
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2e24:	80 91 f2 19 	lds	r24, 0x19F2
    2e28:	90 91 f3 19 	lds	r25, 0x19F3
    2e2c:	02 96       	adiw	r24, 0x02	; 2
    2e2e:	0e 94 a3 1a 	call	0x3546	; 0x3546 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2e32:	c7 01       	movw	r24, r14
    2e34:	b6 01       	movw	r22, r12
    2e36:	0e 94 9b 12 	call	0x2536	; 0x2536 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2e3a:	0e 94 19 16 	call	0x2c32	; 0x2c32 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2e3e:	88 23       	and	r24, r24
    2e40:	11 f4       	brne	.+4      	; 0x2e46 <vTaskDelayUntil+0x90>
		{
			portYIELD_WITHIN_API();
    2e42:	0e 94 5b 0e 	call	0x1cb6	; 0x1cb6 <vPortYield>
		}
	}
    2e46:	ff 90       	pop	r15
    2e48:	ef 90       	pop	r14
    2e4a:	df 90       	pop	r13
    2e4c:	cf 90       	pop	r12
    2e4e:	08 95       	ret
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2e50:	c8 16       	cp	r12, r24
    2e52:	d9 06       	cpc	r13, r25
    2e54:	ea 06       	cpc	r14, r26
    2e56:	fb 06       	cpc	r15, r27
    2e58:	08 f3       	brcs	.-62     	; 0x2e1c <vTaskDelayUntil+0x66>
    2e5a:	d3 cf       	rjmp	.-90     	; 0x2e02 <vTaskDelayUntil+0x4c>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2e5c:	c0 82       	st	Z, r12
    2e5e:	d1 82       	std	Z+1, r13	; 0x01
    2e60:	e2 82       	std	Z+2, r14	; 0x02
    2e62:	f3 82       	std	Z+3, r15	; 0x03
    2e64:	ea cf       	rjmp	.-44     	; 0x2e3a <vTaskDelayUntil+0x84>

00002e66 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2e66:	80 91 f7 19 	lds	r24, 0x19F7
    2e6a:	88 23       	and	r24, r24
    2e6c:	31 f0       	breq	.+12     	; 0x2e7a <vTaskSwitchContext+0x14>
    2e6e:	44 c0       	rjmp	.+136    	; 0x2ef8 <vTaskSwitchContext+0x92>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2e70:	80 91 f9 19 	lds	r24, 0x19F9
    2e74:	81 50       	subi	r24, 0x01	; 1
    2e76:	80 93 f9 19 	sts	0x19F9, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2e7a:	80 91 f9 19 	lds	r24, 0x19F9
    2e7e:	90 e0       	ldi	r25, 0x00	; 0
    2e80:	fc 01       	movw	r30, r24
    2e82:	ee 0f       	add	r30, r30
    2e84:	ff 1f       	adc	r31, r31
    2e86:	9c 01       	movw	r18, r24
    2e88:	22 0f       	add	r18, r18
    2e8a:	33 1f       	adc	r19, r19
    2e8c:	22 0f       	add	r18, r18
    2e8e:	33 1f       	adc	r19, r19
    2e90:	22 0f       	add	r18, r18
    2e92:	33 1f       	adc	r19, r19
    2e94:	e2 0f       	add	r30, r18
    2e96:	f3 1f       	adc	r31, r19
    2e98:	e8 0f       	add	r30, r24
    2e9a:	f9 1f       	adc	r31, r25
    2e9c:	ed 5f       	subi	r30, 0xFD	; 253
    2e9e:	f5 4e       	sbci	r31, 0xE5	; 229
    2ea0:	80 81       	ld	r24, Z
    2ea2:	88 23       	and	r24, r24
    2ea4:	29 f3       	breq	.-54     	; 0x2e70 <vTaskSwitchContext+0xa>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2ea6:	80 91 f9 19 	lds	r24, 0x19F9
    2eaa:	90 e0       	ldi	r25, 0x00	; 0
    2eac:	fc 01       	movw	r30, r24
    2eae:	ee 0f       	add	r30, r30
    2eb0:	ff 1f       	adc	r31, r31
    2eb2:	9c 01       	movw	r18, r24
    2eb4:	22 0f       	add	r18, r18
    2eb6:	33 1f       	adc	r19, r19
    2eb8:	22 0f       	add	r18, r18
    2eba:	33 1f       	adc	r19, r19
    2ebc:	22 0f       	add	r18, r18
    2ebe:	33 1f       	adc	r19, r19
    2ec0:	e2 0f       	add	r30, r18
    2ec2:	f3 1f       	adc	r31, r19
    2ec4:	e8 0f       	add	r30, r24
    2ec6:	f9 1f       	adc	r31, r25
    2ec8:	ed 5f       	subi	r30, 0xFD	; 253
    2eca:	f5 4e       	sbci	r31, 0xE5	; 229
    2ecc:	a1 81       	ldd	r26, Z+1	; 0x01
    2ece:	b2 81       	ldd	r27, Z+2	; 0x02
    2ed0:	14 96       	adiw	r26, 0x04	; 4
    2ed2:	0d 90       	ld	r0, X+
    2ed4:	bc 91       	ld	r27, X
    2ed6:	a0 2d       	mov	r26, r0
    2ed8:	b2 83       	std	Z+2, r27	; 0x02
    2eda:	a1 83       	std	Z+1, r26	; 0x01
    2edc:	cf 01       	movw	r24, r30
    2ede:	03 96       	adiw	r24, 0x03	; 3
    2ee0:	a8 17       	cp	r26, r24
    2ee2:	b9 07       	cpc	r27, r25
    2ee4:	69 f0       	breq	.+26     	; 0x2f00 <vTaskSwitchContext+0x9a>
    2ee6:	18 96       	adiw	r26, 0x08	; 8
    2ee8:	8d 91       	ld	r24, X+
    2eea:	9c 91       	ld	r25, X
    2eec:	19 97       	sbiw	r26, 0x09	; 9
    2eee:	90 93 f3 19 	sts	0x19F3, r25
    2ef2:	80 93 f2 19 	sts	0x19F2, r24
    2ef6:	08 95       	ret
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2ef8:	81 e0       	ldi	r24, 0x01	; 1
    2efa:	80 93 f5 19 	sts	0x19F5, r24
    2efe:	08 95       	ret
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2f00:	14 96       	adiw	r26, 0x04	; 4
    2f02:	0d 90       	ld	r0, X+
    2f04:	bc 91       	ld	r27, X
    2f06:	a0 2d       	mov	r26, r0
    2f08:	b2 83       	std	Z+2, r27	; 0x02
    2f0a:	a1 83       	std	Z+1, r26	; 0x01
    2f0c:	ec cf       	rjmp	.-40     	; 0x2ee6 <vTaskSwitchContext+0x80>

00002f0e <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2f0e:	cf 92       	push	r12
    2f10:	df 92       	push	r13
    2f12:	ef 92       	push	r14
    2f14:	ff 92       	push	r15
    2f16:	6a 01       	movw	r12, r20
    2f18:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2f1a:	60 91 f2 19 	lds	r22, 0x19F2
    2f1e:	70 91 f3 19 	lds	r23, 0x19F3
    2f22:	62 5f       	subi	r22, 0xF2	; 242
    2f24:	7f 4f       	sbci	r23, 0xFF	; 255
    2f26:	0e 94 4f 1a 	call	0x349e	; 0x349e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2f2a:	80 91 f2 19 	lds	r24, 0x19F2
    2f2e:	90 91 f3 19 	lds	r25, 0x19F3
    2f32:	02 96       	adiw	r24, 0x02	; 2
    2f34:	0e 94 a3 1a 	call	0x3546	; 0x3546 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2f38:	80 91 fa 19 	lds	r24, 0x19FA
    2f3c:	90 91 fb 19 	lds	r25, 0x19FB
    2f40:	a0 91 fc 19 	lds	r26, 0x19FC
    2f44:	b0 91 fd 19 	lds	r27, 0x19FD
    2f48:	8c 0d       	add	r24, r12
    2f4a:	9d 1d       	adc	r25, r13
    2f4c:	ae 1d       	adc	r26, r14
    2f4e:	bf 1d       	adc	r27, r15
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2f50:	bc 01       	movw	r22, r24
    2f52:	cd 01       	movw	r24, r26
    2f54:	0e 94 9b 12 	call	0x2536	; 0x2536 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2f58:	ff 90       	pop	r15
    2f5a:	ef 90       	pop	r14
    2f5c:	df 90       	pop	r13
    2f5e:	cf 90       	pop	r12
    2f60:	08 95       	ret

00002f62 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2f62:	0f 93       	push	r16
    2f64:	1f 93       	push	r17
    2f66:	cf 93       	push	r28
    2f68:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2f6a:	dc 01       	movw	r26, r24
    2f6c:	17 96       	adiw	r26, 0x07	; 7
    2f6e:	ed 91       	ld	r30, X+
    2f70:	fc 91       	ld	r31, X
    2f72:	18 97       	sbiw	r26, 0x08	; 8
    2f74:	00 85       	ldd	r16, Z+8	; 0x08
    2f76:	11 85       	ldd	r17, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2f78:	e8 01       	movw	r28, r16
    2f7a:	2e 96       	adiw	r28, 0x0e	; 14
    2f7c:	ce 01       	movw	r24, r28
    2f7e:	0e 94 a3 1a 	call	0x3546	; 0x3546 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2f82:	80 91 f7 19 	lds	r24, 0x19F7
    2f86:	88 23       	and	r24, r24
    2f88:	89 f5       	brne	.+98     	; 0x2fec <xTaskRemoveFromEventList+0x8a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2f8a:	e8 01       	movw	r28, r16
    2f8c:	22 96       	adiw	r28, 0x02	; 2
    2f8e:	ce 01       	movw	r24, r28
    2f90:	0e 94 a3 1a 	call	0x3546	; 0x3546 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2f94:	f8 01       	movw	r30, r16
    2f96:	22 8d       	ldd	r18, Z+26	; 0x1a
    2f98:	80 91 f9 19 	lds	r24, 0x19F9
    2f9c:	82 17       	cp	r24, r18
    2f9e:	60 f1       	brcs	.+88     	; 0x2ff8 <xTaskRemoveFromEventList+0x96>
    2fa0:	30 e0       	ldi	r19, 0x00	; 0
    2fa2:	c9 01       	movw	r24, r18
    2fa4:	88 0f       	add	r24, r24
    2fa6:	99 1f       	adc	r25, r25
    2fa8:	a9 01       	movw	r20, r18
    2faa:	44 0f       	add	r20, r20
    2fac:	55 1f       	adc	r21, r21
    2fae:	44 0f       	add	r20, r20
    2fb0:	55 1f       	adc	r21, r21
    2fb2:	44 0f       	add	r20, r20
    2fb4:	55 1f       	adc	r21, r21
    2fb6:	84 0f       	add	r24, r20
    2fb8:	95 1f       	adc	r25, r21
    2fba:	82 0f       	add	r24, r18
    2fbc:	93 1f       	adc	r25, r19
    2fbe:	8d 5f       	subi	r24, 0xFD	; 253
    2fc0:	95 4e       	sbci	r25, 0xE5	; 229
    2fc2:	be 01       	movw	r22, r28
    2fc4:	0e 94 28 1a 	call	0x3450	; 0x3450 <vListInsertEnd>
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2fc8:	e0 91 f2 19 	lds	r30, 0x19F2
    2fcc:	f0 91 f3 19 	lds	r31, 0x19F3
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2fd0:	81 e0       	ldi	r24, 0x01	; 1
    2fd2:	d8 01       	movw	r26, r16
    2fd4:	5a 96       	adiw	r26, 0x1a	; 26
    2fd6:	2c 91       	ld	r18, X
    2fd8:	5a 97       	sbiw	r26, 0x1a	; 26
    2fda:	92 8d       	ldd	r25, Z+26	; 0x1a
    2fdc:	29 17       	cp	r18, r25
    2fde:	08 f4       	brcc	.+2      	; 0x2fe2 <xTaskRemoveFromEventList+0x80>
    2fe0:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    2fe2:	df 91       	pop	r29
    2fe4:	cf 91       	pop	r28
    2fe6:	1f 91       	pop	r17
    2fe8:	0f 91       	pop	r16
    2fea:	08 95       	ret
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2fec:	85 e4       	ldi	r24, 0x45	; 69
    2fee:	9a e1       	ldi	r25, 0x1A	; 26
    2ff0:	be 01       	movw	r22, r28
    2ff2:	0e 94 28 1a 	call	0x3450	; 0x3450 <vListInsertEnd>
    2ff6:	e8 cf       	rjmp	.-48     	; 0x2fc8 <xTaskRemoveFromEventList+0x66>
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2ff8:	20 93 f9 19 	sts	0x19F9, r18
    2ffc:	d1 cf       	rjmp	.-94     	; 0x2fa0 <xTaskRemoveFromEventList+0x3e>

00002ffe <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2ffe:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3000:	80 91 f4 19 	lds	r24, 0x19F4
    3004:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3006:	40 91 fa 19 	lds	r20, 0x19FA
    300a:	50 91 fb 19 	lds	r21, 0x19FB
    300e:	60 91 fc 19 	lds	r22, 0x19FC
    3012:	70 91 fd 19 	lds	r23, 0x19FD
    3016:	41 83       	std	Z+1, r20	; 0x01
    3018:	52 83       	std	Z+2, r21	; 0x02
    301a:	63 83       	std	Z+3, r22	; 0x03
    301c:	74 83       	std	Z+4, r23	; 0x04
}
    301e:	08 95       	ret

00003020 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    3020:	0f 93       	push	r16
    3022:	1f 93       	push	r17
    3024:	cf 93       	push	r28
    3026:	df 93       	push	r29
    3028:	fc 01       	movw	r30, r24
    302a:	eb 01       	movw	r28, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    302c:	0f b6       	in	r0, 0x3f	; 63
    302e:	f8 94       	cli
    3030:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    3032:	80 91 f4 19 	lds	r24, 0x19F4
    3036:	90 81       	ld	r25, Z
    3038:	98 17       	cp	r25, r24
    303a:	09 f4       	brne	.+2      	; 0x303e <xTaskCheckForTimeOut+0x1e>
    303c:	53 c0       	rjmp	.+166    	; 0x30e4 <xTaskCheckForTimeOut+0xc4>
    303e:	81 81       	ldd	r24, Z+1	; 0x01
    3040:	92 81       	ldd	r25, Z+2	; 0x02
    3042:	a3 81       	ldd	r26, Z+3	; 0x03
    3044:	b4 81       	ldd	r27, Z+4	; 0x04
    3046:	40 91 fa 19 	lds	r20, 0x19FA
    304a:	50 91 fb 19 	lds	r21, 0x19FB
    304e:	60 91 fc 19 	lds	r22, 0x19FC
    3052:	70 91 fd 19 	lds	r23, 0x19FD
    3056:	48 17       	cp	r20, r24
    3058:	59 07       	cpc	r21, r25
    305a:	6a 07       	cpc	r22, r26
    305c:	7b 07       	cpc	r23, r27
    305e:	d0 f5       	brcc	.+116    	; 0x30d4 <xTaskCheckForTimeOut+0xb4>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    3060:	40 91 fa 19 	lds	r20, 0x19FA
    3064:	50 91 fb 19 	lds	r21, 0x19FB
    3068:	60 91 fc 19 	lds	r22, 0x19FC
    306c:	70 91 fd 19 	lds	r23, 0x19FD
    3070:	08 81       	ld	r16, Y
    3072:	19 81       	ldd	r17, Y+1	; 0x01
    3074:	2a 81       	ldd	r18, Y+2	; 0x02
    3076:	3b 81       	ldd	r19, Y+3	; 0x03
    3078:	48 1b       	sub	r20, r24
    307a:	59 0b       	sbc	r21, r25
    307c:	6a 0b       	sbc	r22, r26
    307e:	7b 0b       	sbc	r23, r27
    3080:	40 17       	cp	r20, r16
    3082:	51 07       	cpc	r21, r17
    3084:	62 07       	cpc	r22, r18
    3086:	73 07       	cpc	r23, r19
    3088:	28 f5       	brcc	.+74     	; 0x30d4 <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    308a:	40 91 fa 19 	lds	r20, 0x19FA
    308e:	50 91 fb 19 	lds	r21, 0x19FB
    3092:	60 91 fc 19 	lds	r22, 0x19FC
    3096:	70 91 fd 19 	lds	r23, 0x19FD
    309a:	04 1b       	sub	r16, r20
    309c:	15 0b       	sbc	r17, r21
    309e:	26 0b       	sbc	r18, r22
    30a0:	37 0b       	sbc	r19, r23
    30a2:	08 0f       	add	r16, r24
    30a4:	19 1f       	adc	r17, r25
    30a6:	2a 1f       	adc	r18, r26
    30a8:	3b 1f       	adc	r19, r27
    30aa:	08 83       	st	Y, r16
    30ac:	19 83       	std	Y+1, r17	; 0x01
    30ae:	2a 83       	std	Y+2, r18	; 0x02
    30b0:	3b 83       	std	Y+3, r19	; 0x03
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    30b2:	80 91 f4 19 	lds	r24, 0x19F4
    30b6:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    30b8:	80 91 fa 19 	lds	r24, 0x19FA
    30bc:	90 91 fb 19 	lds	r25, 0x19FB
    30c0:	a0 91 fc 19 	lds	r26, 0x19FC
    30c4:	b0 91 fd 19 	lds	r27, 0x19FD
    30c8:	81 83       	std	Z+1, r24	; 0x01
    30ca:	92 83       	std	Z+2, r25	; 0x02
    30cc:	a3 83       	std	Z+3, r26	; 0x03
    30ce:	b4 83       	std	Z+4, r27	; 0x04
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
    30d0:	80 e0       	ldi	r24, 0x00	; 0
    30d2:	01 c0       	rjmp	.+2      	; 0x30d6 <xTaskCheckForTimeOut+0xb6>
		}
		else
		{
			xReturn = pdTRUE;
    30d4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    30d6:	0f 90       	pop	r0
    30d8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    30da:	df 91       	pop	r29
    30dc:	cf 91       	pop	r28
    30de:	1f 91       	pop	r17
    30e0:	0f 91       	pop	r16
    30e2:	08 95       	ret
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    30e4:	81 81       	ldd	r24, Z+1	; 0x01
    30e6:	92 81       	ldd	r25, Z+2	; 0x02
    30e8:	a3 81       	ldd	r26, Z+3	; 0x03
    30ea:	b4 81       	ldd	r27, Z+4	; 0x04
    30ec:	b9 cf       	rjmp	.-142    	; 0x3060 <xTaskCheckForTimeOut+0x40>

000030ee <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    30ee:	81 e0       	ldi	r24, 0x01	; 1
    30f0:	80 93 f5 19 	sts	0x19F5, r24
}
    30f4:	08 95       	ret

000030f6 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    30f6:	00 97       	sbiw	r24, 0x00	; 0
    30f8:	79 f0       	breq	.+30     	; 0x3118 <uxTaskGetStackHighWaterMark+0x22>
    30fa:	fc 01       	movw	r30, r24

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    30fc:	03 8c       	ldd	r0, Z+27	; 0x1b
    30fe:	f4 8d       	ldd	r31, Z+28	; 0x1c
    3100:	e0 2d       	mov	r30, r0

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    3102:	80 81       	ld	r24, Z
    3104:	81 31       	cpi	r24, 0x11	; 17
    3106:	69 f4       	brne	.+26     	; 0x3122 <uxTaskGetStackHighWaterMark+0x2c>
#endif
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
    3108:	31 96       	adiw	r30, 0x01	; 1

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    310a:	80 e0       	ldi	r24, 0x00	; 0
    310c:	90 e0       	ldi	r25, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    310e:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    3110:	21 91       	ld	r18, Z+
    3112:	21 31       	cpi	r18, 0x11	; 17
    3114:	e1 f3       	breq	.-8      	; 0x310e <uxTaskGetStackHighWaterMark+0x18>
    3116:	08 95       	ret
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    3118:	e0 91 f2 19 	lds	r30, 0x19F2
    311c:	f0 91 f3 19 	lds	r31, 0x19F3
    3120:	ed cf       	rjmp	.-38     	; 0x30fc <uxTaskGetStackHighWaterMark+0x6>

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    3122:	80 e0       	ldi	r24, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    3124:	08 95       	ret

00003126 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    3126:	80 91 f2 19 	lds	r24, 0x19F2
    312a:	90 91 f3 19 	lds	r25, 0x19F3

		return xReturn;
	}
    312e:	08 95       	ret

00003130 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    3130:	0f 93       	push	r16
    3132:	1f 93       	push	r17
    3134:	cf 93       	push	r28
    3136:	df 93       	push	r29
    3138:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    313a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    313c:	e0 91 f2 19 	lds	r30, 0x19F2
    3140:	f0 91 f3 19 	lds	r31, 0x19F3
    3144:	92 8d       	ldd	r25, Z+26	; 0x1a
    3146:	89 17       	cp	r24, r25
    3148:	68 f5       	brcc	.+90     	; 0x31a4 <vTaskPriorityInherit+0x74>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    314a:	e0 91 f2 19 	lds	r30, 0x19F2
    314e:	f0 91 f3 19 	lds	r31, 0x19F3
    3152:	92 8d       	ldd	r25, Z+26	; 0x1a
    3154:	44 e0       	ldi	r20, 0x04	; 4
    3156:	50 e0       	ldi	r21, 0x00	; 0
    3158:	60 e0       	ldi	r22, 0x00	; 0
    315a:	70 e0       	ldi	r23, 0x00	; 0
    315c:	49 1b       	sub	r20, r25
    315e:	51 09       	sbc	r21, r1
    3160:	61 09       	sbc	r22, r1
    3162:	71 09       	sbc	r23, r1
    3164:	4e 87       	std	Y+14, r20	; 0x0e
    3166:	5f 87       	std	Y+15, r21	; 0x0f
    3168:	68 8b       	std	Y+16, r22	; 0x10
    316a:	79 8b       	std	Y+17, r23	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    316c:	90 e0       	ldi	r25, 0x00	; 0
    316e:	ac 01       	movw	r20, r24
    3170:	44 0f       	add	r20, r20
    3172:	55 1f       	adc	r21, r21
    3174:	9c 01       	movw	r18, r24
    3176:	22 0f       	add	r18, r18
    3178:	33 1f       	adc	r19, r19
    317a:	22 0f       	add	r18, r18
    317c:	33 1f       	adc	r19, r19
    317e:	22 0f       	add	r18, r18
    3180:	33 1f       	adc	r19, r19
    3182:	42 0f       	add	r20, r18
    3184:	53 1f       	adc	r21, r19
    3186:	48 0f       	add	r20, r24
    3188:	59 1f       	adc	r21, r25
    318a:	4d 5f       	subi	r20, 0xFD	; 253
    318c:	55 4e       	sbci	r21, 0xE5	; 229
    318e:	8c 85       	ldd	r24, Y+12	; 0x0c
    3190:	9d 85       	ldd	r25, Y+13	; 0x0d
    3192:	84 17       	cp	r24, r20
    3194:	95 07       	cpc	r25, r21
    3196:	59 f0       	breq	.+22     	; 0x31ae <vTaskPriorityInherit+0x7e>
				prvAddTaskToReadyQueue( pxTCB );
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3198:	e0 91 f2 19 	lds	r30, 0x19F2
    319c:	f0 91 f3 19 	lds	r31, 0x19F3
    31a0:	82 8d       	ldd	r24, Z+26	; 0x1a
    31a2:	8a 8f       	std	Y+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    31a4:	df 91       	pop	r29
    31a6:	cf 91       	pop	r28
    31a8:	1f 91       	pop	r17
    31aa:	0f 91       	pop	r16
    31ac:	08 95       	ret

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    31ae:	8e 01       	movw	r16, r28
    31b0:	0e 5f       	subi	r16, 0xFE	; 254
    31b2:	1f 4f       	sbci	r17, 0xFF	; 255
    31b4:	c8 01       	movw	r24, r16
    31b6:	0e 94 a3 1a 	call	0x3546	; 0x3546 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    31ba:	e0 91 f2 19 	lds	r30, 0x19F2
    31be:	f0 91 f3 19 	lds	r31, 0x19F3
    31c2:	22 8d       	ldd	r18, Z+26	; 0x1a
    31c4:	2a 8f       	std	Y+26, r18	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    31c6:	80 91 f9 19 	lds	r24, 0x19F9
    31ca:	82 17       	cp	r24, r18
    31cc:	10 f4       	brcc	.+4      	; 0x31d2 <vTaskPriorityInherit+0xa2>
    31ce:	20 93 f9 19 	sts	0x19F9, r18
    31d2:	30 e0       	ldi	r19, 0x00	; 0
    31d4:	c9 01       	movw	r24, r18
    31d6:	88 0f       	add	r24, r24
    31d8:	99 1f       	adc	r25, r25
    31da:	a9 01       	movw	r20, r18
    31dc:	44 0f       	add	r20, r20
    31de:	55 1f       	adc	r21, r21
    31e0:	44 0f       	add	r20, r20
    31e2:	55 1f       	adc	r21, r21
    31e4:	44 0f       	add	r20, r20
    31e6:	55 1f       	adc	r21, r21
    31e8:	84 0f       	add	r24, r20
    31ea:	95 1f       	adc	r25, r21
    31ec:	82 0f       	add	r24, r18
    31ee:	93 1f       	adc	r25, r19
    31f0:	8d 5f       	subi	r24, 0xFD	; 253
    31f2:	95 4e       	sbci	r25, 0xE5	; 229
    31f4:	b8 01       	movw	r22, r16
    31f6:	0e 94 28 1a 	call	0x3450	; 0x3450 <vListInsertEnd>
    31fa:	d4 cf       	rjmp	.-88     	; 0x31a4 <vTaskPriorityInherit+0x74>

000031fc <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    31fc:	0f 93       	push	r16
    31fe:	1f 93       	push	r17
    3200:	cf 93       	push	r28
    3202:	df 93       	push	r29
    3204:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    3206:	00 97       	sbiw	r24, 0x00	; 0
    3208:	81 f1       	breq	.+96     	; 0x326a <vTaskPriorityDisinherit+0x6e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    320a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    320c:	8f a1       	lds	r24, 0x4f
    320e:	98 17       	cp	r25, r24
    3210:	61 f1       	breq	.+88     	; 0x326a <vTaskPriorityDisinherit+0x6e>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    3212:	8e 01       	movw	r16, r28
    3214:	0e 5f       	subi	r16, 0xFE	; 254
    3216:	1f 4f       	sbci	r17, 0xFF	; 255
    3218:	c8 01       	movw	r24, r16
    321a:	0e 94 a3 1a 	call	0x3546	; 0x3546 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    321e:	2f a1       	lds	r18, 0x4f
    3220:	2a 8f       	std	Y+26, r18	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    3222:	84 e0       	ldi	r24, 0x04	; 4
    3224:	90 e0       	ldi	r25, 0x00	; 0
    3226:	a0 e0       	ldi	r26, 0x00	; 0
    3228:	b0 e0       	ldi	r27, 0x00	; 0
    322a:	82 1b       	sub	r24, r18
    322c:	91 09       	sbc	r25, r1
    322e:	a1 09       	sbc	r26, r1
    3230:	b1 09       	sbc	r27, r1
    3232:	8e 87       	std	Y+14, r24	; 0x0e
    3234:	9f 87       	std	Y+15, r25	; 0x0f
    3236:	a8 8b       	std	Y+16, r26	; 0x10
    3238:	b9 8b       	std	Y+17, r27	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    323a:	80 91 f9 19 	lds	r24, 0x19F9
    323e:	82 17       	cp	r24, r18
    3240:	c8 f0       	brcs	.+50     	; 0x3274 <vTaskPriorityDisinherit+0x78>
    3242:	30 e0       	ldi	r19, 0x00	; 0
    3244:	c9 01       	movw	r24, r18
    3246:	88 0f       	add	r24, r24
    3248:	99 1f       	adc	r25, r25
    324a:	a9 01       	movw	r20, r18
    324c:	44 0f       	add	r20, r20
    324e:	55 1f       	adc	r21, r21
    3250:	44 0f       	add	r20, r20
    3252:	55 1f       	adc	r21, r21
    3254:	44 0f       	add	r20, r20
    3256:	55 1f       	adc	r21, r21
    3258:	84 0f       	add	r24, r20
    325a:	95 1f       	adc	r25, r21
    325c:	82 0f       	add	r24, r18
    325e:	93 1f       	adc	r25, r19
    3260:	8d 5f       	subi	r24, 0xFD	; 253
    3262:	95 4e       	sbci	r25, 0xE5	; 229
    3264:	b8 01       	movw	r22, r16
    3266:	0e 94 28 1a 	call	0x3450	; 0x3450 <vListInsertEnd>
			}
		}
	}
    326a:	df 91       	pop	r29
    326c:	cf 91       	pop	r28
    326e:	1f 91       	pop	r17
    3270:	0f 91       	pop	r16
    3272:	08 95       	ret
				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
    3274:	20 93 f9 19 	sts	0x19F9, r18
    3278:	e4 cf       	rjmp	.-56     	; 0x3242 <vTaskPriorityDisinherit+0x46>

0000327a <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    327a:	cf 92       	push	r12
    327c:	df 92       	push	r13
    327e:	ef 92       	push	r14
    3280:	ff 92       	push	r15
    3282:	cf 93       	push	r28
    3284:	df 93       	push	r29
    3286:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    3288:	68 81       	ld	r22, Y
    328a:	79 81       	ldd	r23, Y+1	; 0x01
    328c:	8a 81       	ldd	r24, Y+2	; 0x02
    328e:	9b 81       	ldd	r25, Y+3	; 0x03
    3290:	28 ee       	ldi	r18, 0xE8	; 232
    3292:	c2 2e       	mov	r12, r18
    3294:	23 e0       	ldi	r18, 0x03	; 3
    3296:	d2 2e       	mov	r13, r18
    3298:	e1 2c       	mov	r14, r1
    329a:	f1 2c       	mov	r15, r1
    329c:	a7 01       	movw	r20, r14
    329e:	96 01       	movw	r18, r12
    32a0:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__udivmodsi4>
    32a4:	20 e4       	ldi	r18, 0x40	; 64
    32a6:	32 e4       	ldi	r19, 0x42	; 66
    32a8:	4f e0       	ldi	r20, 0x0F	; 15
    32aa:	50 e0       	ldi	r21, 0x00	; 0
    32ac:	0e 94 2a 1b 	call	0x3654	; 0x3654 <__mulsi3>
    32b0:	a7 01       	movw	r20, r14
    32b2:	96 01       	movw	r18, r12
    32b4:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__udivmodsi4>
    32b8:	69 01       	movw	r12, r18
    32ba:	7a 01       	movw	r14, r20
    32bc:	6c 81       	ldd	r22, Y+4	; 0x04
    32be:	7d 81       	ldd	r23, Y+5	; 0x05
    32c0:	80 e0       	ldi	r24, 0x00	; 0
    32c2:	90 e0       	ldi	r25, 0x00	; 0
    32c4:	20 e4       	ldi	r18, 0x40	; 64
    32c6:	32 e4       	ldi	r19, 0x42	; 66
    32c8:	4f e0       	ldi	r20, 0x0F	; 15
    32ca:	50 e0       	ldi	r21, 0x00	; 0
    32cc:	0e 94 2a 1b 	call	0x3654	; 0x3654 <__mulsi3>
    32d0:	20 e8       	ldi	r18, 0x80	; 128
    32d2:	34 e8       	ldi	r19, 0x84	; 132
    32d4:	4e e1       	ldi	r20, 0x1E	; 30
    32d6:	50 e0       	ldi	r21, 0x00	; 0
    32d8:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__udivmodsi4>
    32dc:	c2 0e       	add	r12, r18
    32de:	d3 1e       	adc	r13, r19
    32e0:	e4 1e       	adc	r14, r20
    32e2:	f5 1e       	adc	r15, r21
}
    32e4:	b6 01       	movw	r22, r12
    32e6:	c7 01       	movw	r24, r14
    32e8:	df 91       	pop	r29
    32ea:	cf 91       	pop	r28
    32ec:	ff 90       	pop	r15
    32ee:	ef 90       	pop	r14
    32f0:	df 90       	pop	r13
    32f2:	cf 90       	pop	r12
    32f4:	08 95       	ret

000032f6 <_ZN7base232C1Ejh>:
 *                     1 only exists on some processors). The default is port 0 
 */

// This section compiles for the AVR microcontroller
#ifdef __AVR
base232::base232 (unsigned int baud_rate, unsigned char port_number)
    32f6:	0f 93       	push	r16
    32f8:	1f 93       	push	r17
    32fa:	cf 93       	push	r28
    32fc:	df 93       	push	r29
    32fe:	ec 01       	movw	r28, r24
{
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A
		if (port_number == 0)
    3300:	44 23       	and	r20, r20
    3302:	09 f4       	brne	.+2      	; 0x3306 <_ZN7base232C1Ejh+0x10>
    3304:	45 c0       	rjmp	.+138    	; 0x3390 <_ZN7base232C1Ejh+0x9a>
			mask_TXC = (1 << TXC0);
		}
		else	// The port number isn't 0, so it presumably must be serial port 1
		{
		#if defined UCSR1A
			p_UDR = &UDR1;
    3306:	8e ec       	ldi	r24, 0xCE	; 206
    3308:	90 e0       	ldi	r25, 0x00	; 0
    330a:	99 83       	std	Y+1, r25	; 0x01
    330c:	88 83       	st	Y, r24
			p_USR = &UCSR1A;
    330e:	88 ec       	ldi	r24, 0xC8	; 200
    3310:	90 e0       	ldi	r25, 0x00	; 0
    3312:	9b 83       	std	Y+3, r25	; 0x03
    3314:	8a 83       	std	Y+2, r24	; 0x02
			p_UCR = &UCSR1B;
    3316:	89 ec       	ldi	r24, 0xC9	; 201
    3318:	90 e0       	ldi	r25, 0x00	; 0
    331a:	9d 83       	std	Y+5, r25	; 0x05
    331c:	8c 83       	std	Y+4, r24	; 0x04
			UCSR1B = (1 << RXEN1) | (1 << TXEN1);
    331e:	88 e1       	ldi	r24, 0x18	; 24
    3320:	80 93 c9 00 	sts	0x00C9, r24
			UCSR1C = (1 << UCSZ11) | (1 << UCSZ10); // | (1 << USBS1);
    3324:	86 e0       	ldi	r24, 0x06	; 6
    3326:	80 93 ca 00 	sts	0x00CA, r24
			UBRR1H = 0x00;
    332a:	10 92 cd 00 	sts	0x00CD, r1
			UBRR1L = calc_baud_div (baud_rate);
    332e:	8b 01       	movw	r16, r22
    3330:	20 e0       	ldi	r18, 0x00	; 0
    3332:	30 e0       	ldi	r19, 0x00	; 0
    3334:	00 0f       	add	r16, r16
    3336:	11 1f       	adc	r17, r17
    3338:	22 1f       	adc	r18, r18
    333a:	33 1f       	adc	r19, r19
    333c:	00 0f       	add	r16, r16
    333e:	11 1f       	adc	r17, r17
    3340:	22 1f       	adc	r18, r18
    3342:	33 1f       	adc	r19, r19
    3344:	00 0f       	add	r16, r16
    3346:	11 1f       	adc	r17, r17
    3348:	22 1f       	adc	r18, r18
    334a:	33 1f       	adc	r19, r19
    334c:	00 0f       	add	r16, r16
    334e:	11 1f       	adc	r17, r17
    3350:	22 1f       	adc	r18, r18
    3352:	33 1f       	adc	r19, r19
    3354:	60 e0       	ldi	r22, 0x00	; 0
    3356:	74 e2       	ldi	r23, 0x24	; 36
    3358:	84 ef       	ldi	r24, 0xF4	; 244
    335a:	90 e0       	ldi	r25, 0x00	; 0
    335c:	a9 01       	movw	r20, r18
    335e:	98 01       	movw	r18, r16
    3360:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__udivmodsi4>
    3364:	20 93 cc 00 	sts	0x00CC, r18
			#ifdef UART_DOUBLE_SPEED		// If double-speed macro has been defined,
				UCSR1A |= U2X1;				// turn on double-speed operation
    3368:	80 91 c8 00 	lds	r24, 0x00C8
    336c:	81 60       	ori	r24, 0x01	; 1
    336e:	80 93 c8 00 	sts	0x00C8, r24
			#endif
			mask_UDRE = (1 << UDRE1);
    3372:	80 e2       	ldi	r24, 0x20	; 32
    3374:	8e 83       	std	Y+6, r24	; 0x06
			mask_RXC = (1 << RXC1);
    3376:	80 e8       	ldi	r24, 0x80	; 128
    3378:	8f 83       	std	Y+7, r24	; 0x07
			mask_TXC = (1 << TXC1);
    337a:	80 e4       	ldi	r24, 0x40	; 64
    337c:	88 87       	std	Y+8, r24	; 0x08
			mask_TXC = (1 << TXC);
		#endif // UCSRA
	#endif // UCSR0A

	// Read the data register to ensure that it's empty
	port_number = *p_UDR;
    337e:	e8 81       	ld	r30, Y
    3380:	f9 81       	ldd	r31, Y+1	; 0x01
    3382:	80 81       	ld	r24, Z
	port_number = *p_UDR;
    3384:	80 81       	ld	r24, Z
}
    3386:	df 91       	pop	r29
    3388:	cf 91       	pop	r28
    338a:	1f 91       	pop	r17
    338c:	0f 91       	pop	r16
    338e:	08 95       	ret
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A
		if (port_number == 0)
		{
			p_UDR = &UDR0;
    3390:	86 ec       	ldi	r24, 0xC6	; 198
    3392:	90 e0       	ldi	r25, 0x00	; 0
    3394:	99 83       	std	Y+1, r25	; 0x01
    3396:	88 83       	st	Y, r24
			p_USR = &UCSR0A;
    3398:	80 ec       	ldi	r24, 0xC0	; 192
    339a:	90 e0       	ldi	r25, 0x00	; 0
    339c:	9b 83       	std	Y+3, r25	; 0x03
    339e:	8a 83       	std	Y+2, r24	; 0x02
			p_UCR = &UCSR0B;
    33a0:	81 ec       	ldi	r24, 0xC1	; 193
    33a2:	90 e0       	ldi	r25, 0x00	; 0
    33a4:	9d 83       	std	Y+5, r25	; 0x05
    33a6:	8c 83       	std	Y+4, r24	; 0x04
			UCSR0B = (1 << RXEN0) | (1 << TXEN0);
    33a8:	88 e1       	ldi	r24, 0x18	; 24
    33aa:	80 93 c1 00 	sts	0x00C1, r24
			UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); // | (1 << USBS0);
    33ae:	86 e0       	ldi	r24, 0x06	; 6
    33b0:	80 93 c2 00 	sts	0x00C2, r24
			UBRR0H = 0x00;
    33b4:	10 92 c5 00 	sts	0x00C5, r1
			UBRR0L = calc_baud_div (baud_rate);
    33b8:	8b 01       	movw	r16, r22
    33ba:	20 e0       	ldi	r18, 0x00	; 0
    33bc:	30 e0       	ldi	r19, 0x00	; 0
    33be:	00 0f       	add	r16, r16
    33c0:	11 1f       	adc	r17, r17
    33c2:	22 1f       	adc	r18, r18
    33c4:	33 1f       	adc	r19, r19
    33c6:	00 0f       	add	r16, r16
    33c8:	11 1f       	adc	r17, r17
    33ca:	22 1f       	adc	r18, r18
    33cc:	33 1f       	adc	r19, r19
    33ce:	00 0f       	add	r16, r16
    33d0:	11 1f       	adc	r17, r17
    33d2:	22 1f       	adc	r18, r18
    33d4:	33 1f       	adc	r19, r19
    33d6:	00 0f       	add	r16, r16
    33d8:	11 1f       	adc	r17, r17
    33da:	22 1f       	adc	r18, r18
    33dc:	33 1f       	adc	r19, r19
    33de:	60 e0       	ldi	r22, 0x00	; 0
    33e0:	74 e2       	ldi	r23, 0x24	; 36
    33e2:	84 ef       	ldi	r24, 0xF4	; 244
    33e4:	90 e0       	ldi	r25, 0x00	; 0
    33e6:	a9 01       	movw	r20, r18
    33e8:	98 01       	movw	r18, r16
    33ea:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__udivmodsi4>
    33ee:	20 93 c4 00 	sts	0x00C4, r18
			#ifdef UART_DOUBLE_SPEED					// Activate double speed mode
				UCSR0A |= U2X0;							// if required
    33f2:	80 91 c0 00 	lds	r24, 0x00C0
    33f6:	81 60       	ori	r24, 0x01	; 1
    33f8:	80 93 c0 00 	sts	0x00C0, r24
    33fc:	ba cf       	rjmp	.-140    	; 0x3372 <_ZN7base232C1Ejh+0x7c>

000033fe <_ZN7base23213ready_to_sendEv>:
 *  tests whether transmitter buffer is empty. 
 *  @return True if the serial port is ready to send, and false if not
 */

bool base232::ready_to_send (void)
{
    33fe:	fc 01       	movw	r30, r24
#ifdef __AVR
	// If transmitter buffer is full, we're not ready to send
	if (*p_USR & mask_UDRE)
    3400:	a2 81       	ldd	r26, Z+2	; 0x02
    3402:	b3 81       	ldd	r27, Z+3	; 0x03
    3404:	9c 91       	ld	r25, X
    3406:	86 81       	ldd	r24, Z+6	; 0x06
    3408:	98 23       	and	r25, r24
/** This method checks if the serial port transmitter is ready to send data.  It 
 *  tests whether transmitter buffer is empty. 
 *  @return True if the serial port is ready to send, and false if not
 */

bool base232::ready_to_send (void)
    340a:	81 e0       	ldi	r24, 0x01	; 1
    340c:	09 f4       	brne	.+2      	; 0x3410 <_ZN7base23213ready_to_sendEv+0x12>
    340e:	80 e0       	ldi	r24, 0x00	; 0
	return (false);
#else
	// The non-AVR (that is, PC) serial port buffer should always be ready
	return (true);
#endif
}
    3410:	08 95       	ret

00003412 <_ZN7base23210is_sendingEv>:
 *  has been sent. 
 *  @return True if the port is currently sending a character, false if it's idle
 */

bool base232::is_sending (void)
{
    3412:	fc 01       	movw	r30, r24
#ifdef __AVR
	if (*p_USR & mask_TXC)
    3414:	a2 81       	ldd	r26, Z+2	; 0x02
    3416:	b3 81       	ldd	r27, Z+3	; 0x03
    3418:	9c 91       	ld	r25, X
    341a:	80 85       	ldd	r24, Z+8	; 0x08
    341c:	98 23       	and	r25, r24
 *  last one; it would be a bad idea to put the processor to sleep before the character
 *  has been sent. 
 *  @return True if the port is currently sending a character, false if it's idle
 */

bool base232::is_sending (void)
    341e:	81 e0       	ldi	r24, 0x01	; 1
    3420:	09 f0       	breq	.+2      	; 0x3424 <_ZN7base23210is_sendingEv+0x12>
    3422:	80 e0       	ldi	r24, 0x00	; 0
		return (true);
#else
	// We don't really care if a PC is sending, as it has a buffer anyway
	return (false);
#endif
}
    3424:	08 95       	ret

00003426 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    3426:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    3428:	03 96       	adiw	r24, 0x03	; 3
    342a:	92 83       	std	Z+2, r25	; 0x02
    342c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    342e:	4f ef       	ldi	r20, 0xFF	; 255
    3430:	5f ef       	ldi	r21, 0xFF	; 255
    3432:	ba 01       	movw	r22, r20
    3434:	43 83       	std	Z+3, r20	; 0x03
    3436:	54 83       	std	Z+4, r21	; 0x04
    3438:	65 83       	std	Z+5, r22	; 0x05
    343a:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    343c:	90 87       	std	Z+8, r25	; 0x08
    343e:	87 83       	std	Z+7, r24	; 0x07
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    3440:	92 87       	std	Z+10, r25	; 0x0a
    3442:	81 87       	std	Z+9, r24	; 0x09

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    3444:	10 82       	st	Z, r1
}
    3446:	08 95       	ret

00003448 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    3448:	fc 01       	movw	r30, r24
    344a:	13 86       	std	Z+11, r1	; 0x0b
    344c:	12 86       	std	Z+10, r1	; 0x0a
}
    344e:	08 95       	ret

00003450 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    3450:	cf 93       	push	r28
    3452:	df 93       	push	r29
    3454:	ec 01       	movw	r28, r24
    3456:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    3458:	89 81       	ldd	r24, Y+1	; 0x01
    345a:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    345c:	dc 01       	movw	r26, r24
    345e:	14 96       	adiw	r26, 0x04	; 4
    3460:	2d 91       	ld	r18, X+
    3462:	3c 91       	ld	r19, X
    3464:	15 97       	sbiw	r26, 0x05	; 5
    3466:	35 83       	std	Z+5, r19	; 0x05
    3468:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxList->pxIndex;
    346a:	97 83       	std	Z+7, r25	; 0x07
    346c:	86 83       	std	Z+6, r24	; 0x06
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    346e:	14 96       	adiw	r26, 0x04	; 4
    3470:	2d 91       	ld	r18, X+
    3472:	3c 91       	ld	r19, X
    3474:	15 97       	sbiw	r26, 0x05	; 5
    3476:	d9 01       	movw	r26, r18
    3478:	17 96       	adiw	r26, 0x07	; 7
    347a:	7c 93       	st	X, r23
    347c:	6e 93       	st	-X, r22
    347e:	16 97       	sbiw	r26, 0x06	; 6
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    3480:	dc 01       	movw	r26, r24
    3482:	15 96       	adiw	r26, 0x05	; 5
    3484:	7c 93       	st	X, r23
    3486:	6e 93       	st	-X, r22
    3488:	14 97       	sbiw	r26, 0x04	; 4
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    348a:	7a 83       	std	Y+2, r23	; 0x02
    348c:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    348e:	d3 87       	std	Z+11, r29	; 0x0b
    3490:	c2 87       	std	Z+10, r28	; 0x0a

	( pxList->uxNumberOfItems )++;
    3492:	88 81       	ld	r24, Y
    3494:	8f 5f       	subi	r24, 0xFF	; 255
    3496:	88 83       	st	Y, r24
}
    3498:	df 91       	pop	r29
    349a:	cf 91       	pop	r28
    349c:	08 95       	ret

0000349e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    349e:	cf 92       	push	r12
    34a0:	df 92       	push	r13
    34a2:	ef 92       	push	r14
    34a4:	ff 92       	push	r15
    34a6:	cf 93       	push	r28
    34a8:	df 93       	push	r29
    34aa:	9c 01       	movw	r18, r24
    34ac:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    34ae:	48 81       	ld	r20, Y
    34b0:	59 81       	ldd	r21, Y+1	; 0x01
    34b2:	6a 81       	ldd	r22, Y+2	; 0x02
    34b4:	7b 81       	ldd	r23, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    34b6:	4f 3f       	cpi	r20, 0xFF	; 255
    34b8:	8f ef       	ldi	r24, 0xFF	; 255
    34ba:	58 07       	cpc	r21, r24
    34bc:	8f ef       	ldi	r24, 0xFF	; 255
    34be:	68 07       	cpc	r22, r24
    34c0:	8f ef       	ldi	r24, 0xFF	; 255
    34c2:	78 07       	cpc	r23, r24
    34c4:	d1 f1       	breq	.+116    	; 0x353a <vListInsert+0x9c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    34c6:	f9 01       	movw	r30, r18
    34c8:	33 96       	adiw	r30, 0x03	; 3
    34ca:	d9 01       	movw	r26, r18
    34cc:	17 96       	adiw	r26, 0x07	; 7
    34ce:	8d 91       	ld	r24, X+
    34d0:	9c 91       	ld	r25, X
    34d2:	18 97       	sbiw	r26, 0x08	; 8
    34d4:	dc 01       	movw	r26, r24
    34d6:	cd 90       	ld	r12, X+
    34d8:	dd 90       	ld	r13, X+
    34da:	ed 90       	ld	r14, X+
    34dc:	fc 90       	ld	r15, X
    34de:	13 97       	sbiw	r26, 0x03	; 3
    34e0:	4c 15       	cp	r20, r12
    34e2:	5d 05       	cpc	r21, r13
    34e4:	6e 05       	cpc	r22, r14
    34e6:	7f 05       	cpc	r23, r15
    34e8:	78 f0       	brcs	.+30     	; 0x3508 <vListInsert+0x6a>
    34ea:	04 80       	ldd	r0, Z+4	; 0x04
    34ec:	f5 81       	ldd	r31, Z+5	; 0x05
    34ee:	e0 2d       	mov	r30, r0
    34f0:	a4 81       	ldd	r26, Z+4	; 0x04
    34f2:	b5 81       	ldd	r27, Z+5	; 0x05
    34f4:	8d 91       	ld	r24, X+
    34f6:	9d 91       	ld	r25, X+
    34f8:	0d 90       	ld	r0, X+
    34fa:	bc 91       	ld	r27, X
    34fc:	a0 2d       	mov	r26, r0
    34fe:	48 17       	cp	r20, r24
    3500:	59 07       	cpc	r21, r25
    3502:	6a 07       	cpc	r22, r26
    3504:	7b 07       	cpc	r23, r27
    3506:	88 f7       	brcc	.-30     	; 0x34ea <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    3508:	a4 81       	ldd	r26, Z+4	; 0x04
    350a:	b5 81       	ldd	r27, Z+5	; 0x05
    350c:	bd 83       	std	Y+5, r27	; 0x05
    350e:	ac 83       	std	Y+4, r26	; 0x04
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    3510:	17 96       	adiw	r26, 0x07	; 7
    3512:	dc 93       	st	X, r29
    3514:	ce 93       	st	-X, r28
    3516:	16 97       	sbiw	r26, 0x06	; 6
	pxNewListItem->pxPrevious = pxIterator;
    3518:	ff 83       	std	Y+7, r31	; 0x07
    351a:	ee 83       	std	Y+6, r30	; 0x06
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    351c:	d5 83       	std	Z+5, r29	; 0x05
    351e:	c4 83       	std	Z+4, r28	; 0x04

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    3520:	3b 87       	std	Y+11, r19	; 0x0b
    3522:	2a 87       	std	Y+10, r18	; 0x0a

	( pxList->uxNumberOfItems )++;
    3524:	f9 01       	movw	r30, r18
    3526:	80 81       	ld	r24, Z
    3528:	8f 5f       	subi	r24, 0xFF	; 255
    352a:	80 83       	st	Z, r24
}
    352c:	df 91       	pop	r29
    352e:	cf 91       	pop	r28
    3530:	ff 90       	pop	r15
    3532:	ef 90       	pop	r14
    3534:	df 90       	pop	r13
    3536:	cf 90       	pop	r12
    3538:	08 95       	ret
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    353a:	d9 01       	movw	r26, r18
    353c:	19 96       	adiw	r26, 0x09	; 9
    353e:	ed 91       	ld	r30, X+
    3540:	fc 91       	ld	r31, X
    3542:	1a 97       	sbiw	r26, 0x0a	; 10
    3544:	e1 cf       	rjmp	.-62     	; 0x3508 <vListInsert+0x6a>

00003546 <vListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    3546:	cf 93       	push	r28
    3548:	df 93       	push	r29
    354a:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    354c:	a4 81       	ldd	r26, Z+4	; 0x04
    354e:	b5 81       	ldd	r27, Z+5	; 0x05
    3550:	86 81       	ldd	r24, Z+6	; 0x06
    3552:	97 81       	ldd	r25, Z+7	; 0x07
    3554:	17 96       	adiw	r26, 0x07	; 7
    3556:	9c 93       	st	X, r25
    3558:	8e 93       	st	-X, r24
    355a:	16 97       	sbiw	r26, 0x06	; 6
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    355c:	c6 81       	ldd	r28, Z+6	; 0x06
    355e:	d7 81       	ldd	r29, Z+7	; 0x07
    3560:	bd 83       	std	Y+5, r27	; 0x05
    3562:	ac 83       	std	Y+4, r26	; 0x04
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    3564:	a2 85       	ldd	r26, Z+10	; 0x0a
    3566:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    3568:	11 96       	adiw	r26, 0x01	; 1
    356a:	8d 91       	ld	r24, X+
    356c:	9c 91       	ld	r25, X
    356e:	12 97       	sbiw	r26, 0x02	; 2
    3570:	8e 17       	cp	r24, r30
    3572:	9f 07       	cpc	r25, r31
    3574:	41 f0       	breq	.+16     	; 0x3586 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
	}

	pxItemToRemove->pvContainer = NULL;
    3576:	13 86       	std	Z+11, r1	; 0x0b
    3578:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
    357a:	8c 91       	ld	r24, X
    357c:	81 50       	subi	r24, 0x01	; 1
    357e:	8c 93       	st	X, r24
}
    3580:	df 91       	pop	r29
    3582:	cf 91       	pop	r28
    3584:	08 95       	ret
	pxList = ( xList * ) pxItemToRemove->pvContainer;

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    3586:	12 96       	adiw	r26, 0x02	; 2
    3588:	dc 93       	st	X, r29
    358a:	ce 93       	st	-X, r28
    358c:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    358e:	13 86       	std	Z+11, r1	; 0x0b
    3590:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
    3592:	8c 91       	ld	r24, X
    3594:	81 50       	subi	r24, 0x01	; 1
    3596:	8c 93       	st	X, r24
}
    3598:	df 91       	pop	r29
    359a:	cf 91       	pop	r28
    359c:	08 95       	ret

0000359e <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    359e:	0f 93       	push	r16
    35a0:	1f 93       	push	r17
    35a2:	cf 93       	push	r28
    35a4:	df 93       	push	r29
    35a6:	cd b7       	in	r28, 0x3d	; 61
    35a8:	de b7       	in	r29, 0x3e	; 62
    35aa:	62 97       	sbiw	r28, 0x12	; 18
    35ac:	0f b6       	in	r0, 0x3f	; 63
    35ae:	f8 94       	cli
    35b0:	de bf       	out	0x3e, r29	; 62
    35b2:	0f be       	out	0x3f, r0	; 63
    35b4:	cd bf       	out	0x3d, r28	; 61
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on
	MCUSR = 0;
    35b6:	14 be       	out	0x34, r1	; 52
	wdt_disable ();
    35b8:	88 e1       	ldi	r24, 0x18	; 24
    35ba:	0f b6       	in	r0, 0x3f	; 63
    35bc:	f8 94       	cli
    35be:	80 93 60 00 	sts	0x0060, r24
    35c2:	10 92 60 00 	sts	0x0060, r1
    35c6:	0f be       	out	0x3f, r0	; 63

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_port (9600, 1);
    35c8:	ce 01       	movw	r24, r28
    35ca:	01 96       	adiw	r24, 0x01	; 1
    35cc:	60 e8       	ldi	r22, 0x80	; 128
    35ce:	75 e2       	ldi	r23, 0x25	; 37
    35d0:	41 e0       	ldi	r20, 0x01	; 1
    35d2:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <_ZN5rs232C1Ejh>
	ser_port << clrscr << PMS ("ME405 Lab 1 Starting Program") << endl;
    35d6:	ce 01       	movw	r24, r28
    35d8:	01 96       	adiw	r24, 0x01	; 1
    35da:	67 e0       	ldi	r22, 0x07	; 7
    35dc:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
    35e0:	6a e0       	ldi	r22, 0x0A	; 10
    35e2:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
    35e6:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    35e8:	6c ec       	ldi	r22, 0xCC	; 204
    35ea:	70 e0       	ldi	r23, 0x00	; 0
    35ec:	0e 94 47 0a 	call	0x148e	; 0x148e <_ZN8emstream4putsEPKc>
    35f0:	c8 01       	movw	r24, r16
    35f2:	66 e0       	ldi	r22, 0x06	; 6
    35f4:	0e 94 88 0a 	call	0x1510	; 0x1510 <_ZN8emstreamlsE15ser_manipulator>
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	//new task_user ("UserInt", task_priority (1), 260, &ser_port);

	// Create a task which reads the A/D and adjusts an LED's brightness accordingly
	new task_brightness ("Bright", task_priority (2), 280, &ser_port);
    35f8:	82 e1       	ldi	r24, 0x12	; 18
    35fa:	90 e0       	ldi	r25, 0x00	; 0
    35fc:	0e 94 10 0a 	call	0x1420	; 0x1420 <_Znwj>
    3600:	60 e0       	ldi	r22, 0x00	; 0
    3602:	72 e0       	ldi	r23, 0x02	; 2
    3604:	42 e0       	ldi	r20, 0x02	; 2
    3606:	28 e1       	ldi	r18, 0x18	; 24
    3608:	31 e0       	ldi	r19, 0x01	; 1
    360a:	8e 01       	movw	r16, r28
    360c:	0f 5f       	subi	r16, 0xFF	; 255
    360e:	1f 4f       	sbci	r17, 0xFF	; 255
    3610:	0e 94 85 04 	call	0x90a	; 0x90a <_ZN15task_brightnessC1EPKchjP8emstream>

	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3614:	0e 94 ad 14 	call	0x295a	; 0x295a <vTaskStartScheduler>
}
    3618:	80 e0       	ldi	r24, 0x00	; 0
    361a:	90 e0       	ldi	r25, 0x00	; 0
    361c:	62 96       	adiw	r28, 0x12	; 18
    361e:	0f b6       	in	r0, 0x3f	; 63
    3620:	f8 94       	cli
    3622:	de bf       	out	0x3e, r29	; 62
    3624:	0f be       	out	0x3f, r0	; 63
    3626:	cd bf       	out	0x3d, r28	; 61
    3628:	df 91       	pop	r29
    362a:	cf 91       	pop	r28
    362c:	1f 91       	pop	r17
    362e:	0f 91       	pop	r16
    3630:	08 95       	ret

00003632 <_GLOBAL__sub_I_print_ser_queue>:
    3632:	0f 93       	push	r16
    3634:	1f 93       	push	r17
/** This is a print queue, descended from \c emstream so that things can be printed 
 *  into the queue using the "<<" operator and they'll come out the other end as a 
 *  stream of characters. It's used by tasks that send things to the user interface 
 *  task to be printed. 
 */
frt_text_queue print_ser_queue (32, NULL, 10);
    3636:	8a e9       	ldi	r24, 0x9A	; 154
    3638:	92 e0       	ldi	r25, 0x02	; 2
    363a:	60 e2       	ldi	r22, 0x20	; 32
    363c:	70 e0       	ldi	r23, 0x00	; 0
    363e:	40 e0       	ldi	r20, 0x00	; 0
    3640:	50 e0       	ldi	r21, 0x00	; 0
    3642:	0a e0       	ldi	r16, 0x0A	; 10
    3644:	10 e0       	ldi	r17, 0x00	; 0
    3646:	20 e0       	ldi	r18, 0x00	; 0
    3648:	30 e0       	ldi	r19, 0x00	; 0
    364a:	0e 94 a4 08 	call	0x1148	; 0x1148 <_ZN14frt_text_queueC1EjP8emstreamm>
	new task_brightness ("Bright", task_priority (2), 280, &ser_port);

	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    364e:	1f 91       	pop	r17
    3650:	0f 91       	pop	r16
    3652:	08 95       	ret

00003654 <__mulsi3>:
    3654:	62 9f       	mul	r22, r18
    3656:	d0 01       	movw	r26, r0
    3658:	73 9f       	mul	r23, r19
    365a:	f0 01       	movw	r30, r0
    365c:	82 9f       	mul	r24, r18
    365e:	e0 0d       	add	r30, r0
    3660:	f1 1d       	adc	r31, r1
    3662:	64 9f       	mul	r22, r20
    3664:	e0 0d       	add	r30, r0
    3666:	f1 1d       	adc	r31, r1
    3668:	92 9f       	mul	r25, r18
    366a:	f0 0d       	add	r31, r0
    366c:	83 9f       	mul	r24, r19
    366e:	f0 0d       	add	r31, r0
    3670:	74 9f       	mul	r23, r20
    3672:	f0 0d       	add	r31, r0
    3674:	65 9f       	mul	r22, r21
    3676:	f0 0d       	add	r31, r0
    3678:	99 27       	eor	r25, r25
    367a:	72 9f       	mul	r23, r18
    367c:	b0 0d       	add	r27, r0
    367e:	e1 1d       	adc	r30, r1
    3680:	f9 1f       	adc	r31, r25
    3682:	63 9f       	mul	r22, r19
    3684:	b0 0d       	add	r27, r0
    3686:	e1 1d       	adc	r30, r1
    3688:	f9 1f       	adc	r31, r25
    368a:	bd 01       	movw	r22, r26
    368c:	cf 01       	movw	r24, r30
    368e:	11 24       	eor	r1, r1
    3690:	08 95       	ret

00003692 <__udivmodhi4>:
    3692:	aa 1b       	sub	r26, r26
    3694:	bb 1b       	sub	r27, r27
    3696:	51 e1       	ldi	r21, 0x11	; 17
    3698:	07 c0       	rjmp	.+14     	; 0x36a8 <__udivmodhi4_ep>

0000369a <__udivmodhi4_loop>:
    369a:	aa 1f       	adc	r26, r26
    369c:	bb 1f       	adc	r27, r27
    369e:	a6 17       	cp	r26, r22
    36a0:	b7 07       	cpc	r27, r23
    36a2:	10 f0       	brcs	.+4      	; 0x36a8 <__udivmodhi4_ep>
    36a4:	a6 1b       	sub	r26, r22
    36a6:	b7 0b       	sbc	r27, r23

000036a8 <__udivmodhi4_ep>:
    36a8:	88 1f       	adc	r24, r24
    36aa:	99 1f       	adc	r25, r25
    36ac:	5a 95       	dec	r21
    36ae:	a9 f7       	brne	.-22     	; 0x369a <__udivmodhi4_loop>
    36b0:	80 95       	com	r24
    36b2:	90 95       	com	r25
    36b4:	bc 01       	movw	r22, r24
    36b6:	cd 01       	movw	r24, r26
    36b8:	08 95       	ret

000036ba <__udivmodsi4>:
    36ba:	a1 e2       	ldi	r26, 0x21	; 33
    36bc:	1a 2e       	mov	r1, r26
    36be:	aa 1b       	sub	r26, r26
    36c0:	bb 1b       	sub	r27, r27
    36c2:	fd 01       	movw	r30, r26
    36c4:	0d c0       	rjmp	.+26     	; 0x36e0 <__udivmodsi4_ep>

000036c6 <__udivmodsi4_loop>:
    36c6:	aa 1f       	adc	r26, r26
    36c8:	bb 1f       	adc	r27, r27
    36ca:	ee 1f       	adc	r30, r30
    36cc:	ff 1f       	adc	r31, r31
    36ce:	a2 17       	cp	r26, r18
    36d0:	b3 07       	cpc	r27, r19
    36d2:	e4 07       	cpc	r30, r20
    36d4:	f5 07       	cpc	r31, r21
    36d6:	20 f0       	brcs	.+8      	; 0x36e0 <__udivmodsi4_ep>
    36d8:	a2 1b       	sub	r26, r18
    36da:	b3 0b       	sbc	r27, r19
    36dc:	e4 0b       	sbc	r30, r20
    36de:	f5 0b       	sbc	r31, r21

000036e0 <__udivmodsi4_ep>:
    36e0:	66 1f       	adc	r22, r22
    36e2:	77 1f       	adc	r23, r23
    36e4:	88 1f       	adc	r24, r24
    36e6:	99 1f       	adc	r25, r25
    36e8:	1a 94       	dec	r1
    36ea:	69 f7       	brne	.-38     	; 0x36c6 <__udivmodsi4_loop>
    36ec:	60 95       	com	r22
    36ee:	70 95       	com	r23
    36f0:	80 95       	com	r24
    36f2:	90 95       	com	r25
    36f4:	9b 01       	movw	r18, r22
    36f6:	ac 01       	movw	r20, r24
    36f8:	bd 01       	movw	r22, r26
    36fa:	cf 01       	movw	r24, r30
    36fc:	08 95       	ret

000036fe <__divmodsi4>:
    36fe:	97 fb       	bst	r25, 7
    3700:	09 2e       	mov	r0, r25
    3702:	05 26       	eor	r0, r21
    3704:	0e d0       	rcall	.+28     	; 0x3722 <__divmodsi4_neg1>
    3706:	57 fd       	sbrc	r21, 7
    3708:	04 d0       	rcall	.+8      	; 0x3712 <__divmodsi4_neg2>
    370a:	d7 df       	rcall	.-82     	; 0x36ba <__udivmodsi4>
    370c:	0a d0       	rcall	.+20     	; 0x3722 <__divmodsi4_neg1>
    370e:	00 1c       	adc	r0, r0
    3710:	38 f4       	brcc	.+14     	; 0x3720 <__divmodsi4_exit>

00003712 <__divmodsi4_neg2>:
    3712:	50 95       	com	r21
    3714:	40 95       	com	r20
    3716:	30 95       	com	r19
    3718:	21 95       	neg	r18
    371a:	3f 4f       	sbci	r19, 0xFF	; 255
    371c:	4f 4f       	sbci	r20, 0xFF	; 255
    371e:	5f 4f       	sbci	r21, 0xFF	; 255

00003720 <__divmodsi4_exit>:
    3720:	08 95       	ret

00003722 <__divmodsi4_neg1>:
    3722:	f6 f7       	brtc	.-4      	; 0x3720 <__divmodsi4_exit>
    3724:	90 95       	com	r25
    3726:	80 95       	com	r24
    3728:	70 95       	com	r23
    372a:	61 95       	neg	r22
    372c:	7f 4f       	sbci	r23, 0xFF	; 255
    372e:	8f 4f       	sbci	r24, 0xFF	; 255
    3730:	9f 4f       	sbci	r25, 0xFF	; 255
    3732:	08 95       	ret

00003734 <__tablejump_elpm__>:
    3734:	07 90       	elpm	r0, Z+
    3736:	f6 91       	elpm	r31, Z
    3738:	e0 2d       	mov	r30, r0
    373a:	09 94       	ijmp

0000373c <memcpy>:
    373c:	fb 01       	movw	r30, r22
    373e:	dc 01       	movw	r26, r24
    3740:	02 c0       	rjmp	.+4      	; 0x3746 <memcpy+0xa>
    3742:	01 90       	ld	r0, Z+
    3744:	0d 92       	st	X+, r0
    3746:	41 50       	subi	r20, 0x01	; 1
    3748:	50 40       	sbci	r21, 0x00	; 0
    374a:	d8 f7       	brcc	.-10     	; 0x3742 <memcpy+0x6>
    374c:	08 95       	ret

0000374e <memset>:
    374e:	dc 01       	movw	r26, r24
    3750:	01 c0       	rjmp	.+2      	; 0x3754 <memset+0x6>
    3752:	6d 93       	st	X+, r22
    3754:	41 50       	subi	r20, 0x01	; 1
    3756:	50 40       	sbci	r21, 0x00	; 0
    3758:	e0 f7       	brcc	.-8      	; 0x3752 <memset+0x4>
    375a:	08 95       	ret

0000375c <strncpy>:
    375c:	fb 01       	movw	r30, r22
    375e:	dc 01       	movw	r26, r24
    3760:	41 50       	subi	r20, 0x01	; 1
    3762:	50 40       	sbci	r21, 0x00	; 0
    3764:	48 f0       	brcs	.+18     	; 0x3778 <strncpy+0x1c>
    3766:	01 90       	ld	r0, Z+
    3768:	0d 92       	st	X+, r0
    376a:	00 20       	and	r0, r0
    376c:	c9 f7       	brne	.-14     	; 0x3760 <strncpy+0x4>
    376e:	01 c0       	rjmp	.+2      	; 0x3772 <strncpy+0x16>
    3770:	1d 92       	st	X+, r1
    3772:	41 50       	subi	r20, 0x01	; 1
    3774:	50 40       	sbci	r21, 0x00	; 0
    3776:	e0 f7       	brcc	.-8      	; 0x3770 <strncpy+0x14>
    3778:	08 95       	ret

0000377a <ultoa>:
    377a:	fa 01       	movw	r30, r20
    377c:	cf 93       	push	r28
    377e:	ff 93       	push	r31
    3780:	ef 93       	push	r30
    3782:	22 30       	cpi	r18, 0x02	; 2
    3784:	cc f0       	brlt	.+50     	; 0x37b8 <ultoa+0x3e>
    3786:	25 32       	cpi	r18, 0x25	; 37
    3788:	bc f4       	brge	.+46     	; 0x37b8 <ultoa+0x3e>
    378a:	c2 2f       	mov	r28, r18
    378c:	2c 2f       	mov	r18, r28
    378e:	33 27       	eor	r19, r19
    3790:	44 27       	eor	r20, r20
    3792:	55 27       	eor	r21, r21
    3794:	ff 93       	push	r31
    3796:	ef 93       	push	r30
    3798:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <__udivmodsi4>
    379c:	ef 91       	pop	r30
    379e:	ff 91       	pop	r31
    37a0:	60 5d       	subi	r22, 0xD0	; 208
    37a2:	6a 33       	cpi	r22, 0x3A	; 58
    37a4:	0c f0       	brlt	.+2      	; 0x37a8 <ultoa+0x2e>
    37a6:	69 5d       	subi	r22, 0xD9	; 217
    37a8:	61 93       	st	Z+, r22
    37aa:	b9 01       	movw	r22, r18
    37ac:	ca 01       	movw	r24, r20
    37ae:	60 50       	subi	r22, 0x00	; 0
    37b0:	70 40       	sbci	r23, 0x00	; 0
    37b2:	80 40       	sbci	r24, 0x00	; 0
    37b4:	90 40       	sbci	r25, 0x00	; 0
    37b6:	51 f7       	brne	.-44     	; 0x378c <ultoa+0x12>
    37b8:	10 82       	st	Z, r1
    37ba:	8f 91       	pop	r24
    37bc:	9f 91       	pop	r25
    37be:	cf 91       	pop	r28
    37c0:	0c 94 f8 1b 	jmp	0x37f0	; 0x37f0 <strrev>

000037c4 <utoa>:
    37c4:	fb 01       	movw	r30, r22
    37c6:	9f 01       	movw	r18, r30
    37c8:	42 30       	cpi	r20, 0x02	; 2
    37ca:	74 f0       	brlt	.+28     	; 0x37e8 <utoa+0x24>
    37cc:	45 32       	cpi	r20, 0x25	; 37
    37ce:	64 f4       	brge	.+24     	; 0x37e8 <utoa+0x24>
    37d0:	64 2f       	mov	r22, r20
    37d2:	77 27       	eor	r23, r23
    37d4:	0e 94 49 1b 	call	0x3692	; 0x3692 <__udivmodhi4>
    37d8:	80 5d       	subi	r24, 0xD0	; 208
    37da:	8a 33       	cpi	r24, 0x3A	; 58
    37dc:	0c f0       	brlt	.+2      	; 0x37e0 <utoa+0x1c>
    37de:	89 5d       	subi	r24, 0xD9	; 217
    37e0:	81 93       	st	Z+, r24
    37e2:	cb 01       	movw	r24, r22
    37e4:	00 97       	sbiw	r24, 0x00	; 0
    37e6:	a1 f7       	brne	.-24     	; 0x37d0 <utoa+0xc>
    37e8:	10 82       	st	Z, r1
    37ea:	c9 01       	movw	r24, r18
    37ec:	0c 94 f8 1b 	jmp	0x37f0	; 0x37f0 <strrev>

000037f0 <strrev>:
    37f0:	dc 01       	movw	r26, r24
    37f2:	fc 01       	movw	r30, r24
    37f4:	67 2f       	mov	r22, r23
    37f6:	71 91       	ld	r23, Z+
    37f8:	77 23       	and	r23, r23
    37fa:	e1 f7       	brne	.-8      	; 0x37f4 <strrev+0x4>
    37fc:	32 97       	sbiw	r30, 0x02	; 2
    37fe:	04 c0       	rjmp	.+8      	; 0x3808 <strrev+0x18>
    3800:	7c 91       	ld	r23, X
    3802:	6d 93       	st	X+, r22
    3804:	70 83       	st	Z, r23
    3806:	62 91       	ld	r22, -Z
    3808:	ae 17       	cp	r26, r30
    380a:	bf 07       	cpc	r27, r31
    380c:	c8 f3       	brcs	.-14     	; 0x3800 <strrev+0x10>
    380e:	08 95       	ret

00003810 <_exit>:
    3810:	f8 94       	cli

00003812 <__stop_program>:
    3812:	ff cf       	rjmp	.-2      	; 0x3812 <__stop_program>
